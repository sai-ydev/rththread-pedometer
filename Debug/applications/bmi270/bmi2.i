# 1 "../applications/bmi270/bmi2.c"
# 1 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\Debug//"
# 1 "<built-in>"
#define __STDC__ 1
#define __STDC_VERSION__ 201112L
#define __STDC_UTF_16__ 1
#define __STDC_UTF_32__ 1
#define __STDC_HOSTED__ 1
#define __GNUC__ 8
#define __GNUC_MINOR__ 2
#define __GNUC_PATCHLEVEL__ 0
#define __VERSION__ "8.2.0"
#define __ATOMIC_RELAXED 0
#define __ATOMIC_SEQ_CST 5
#define __ATOMIC_ACQUIRE 2
#define __ATOMIC_RELEASE 3
#define __ATOMIC_ACQ_REL 4
#define __ATOMIC_CONSUME 1
#define __FINITE_MATH_ONLY__ 0
#define __SIZEOF_INT__ 4
#define __SIZEOF_LONG__ 4
#define __SIZEOF_LONG_LONG__ 8
#define __SIZEOF_SHORT__ 2
#define __SIZEOF_FLOAT__ 4
#define __SIZEOF_DOUBLE__ 8
#define __SIZEOF_LONG_DOUBLE__ 16
#define __SIZEOF_SIZE_T__ 4
#define __CHAR_BIT__ 8
#define __BIGGEST_ALIGNMENT__ 16
#define __ORDER_LITTLE_ENDIAN__ 1234
#define __ORDER_BIG_ENDIAN__ 4321
#define __ORDER_PDP_ENDIAN__ 3412
#define __BYTE_ORDER__ __ORDER_LITTLE_ENDIAN__
#define __FLOAT_WORD_ORDER__ __ORDER_LITTLE_ENDIAN__
#define __SIZEOF_POINTER__ 4
#define __SIZE_TYPE__ unsigned int
#define __PTRDIFF_TYPE__ int
#define __WCHAR_TYPE__ int
#define __WINT_TYPE__ unsigned int
#define __INTMAX_TYPE__ long long int
#define __UINTMAX_TYPE__ long long unsigned int
#define __CHAR16_TYPE__ short unsigned int
#define __CHAR32_TYPE__ long unsigned int
#define __SIG_ATOMIC_TYPE__ int
#define __INT8_TYPE__ signed char
#define __INT16_TYPE__ short int
#define __INT32_TYPE__ long int
#define __INT64_TYPE__ long long int
#define __UINT8_TYPE__ unsigned char
#define __UINT16_TYPE__ short unsigned int
#define __UINT32_TYPE__ long unsigned int
#define __UINT64_TYPE__ long long unsigned int
#define __INT_LEAST8_TYPE__ signed char
#define __INT_LEAST16_TYPE__ short int
#define __INT_LEAST32_TYPE__ long int
#define __INT_LEAST64_TYPE__ long long int
#define __UINT_LEAST8_TYPE__ unsigned char
#define __UINT_LEAST16_TYPE__ short unsigned int
#define __UINT_LEAST32_TYPE__ long unsigned int
#define __UINT_LEAST64_TYPE__ long long unsigned int
#define __INT_FAST8_TYPE__ int
#define __INT_FAST16_TYPE__ int
#define __INT_FAST32_TYPE__ int
#define __INT_FAST64_TYPE__ long long int
#define __UINT_FAST8_TYPE__ unsigned int
#define __UINT_FAST16_TYPE__ unsigned int
#define __UINT_FAST32_TYPE__ unsigned int
#define __UINT_FAST64_TYPE__ long long unsigned int
#define __INTPTR_TYPE__ int
#define __UINTPTR_TYPE__ unsigned int
#define __has_include(STR) __has_include__(STR)
#define __has_include_next(STR) __has_include_next__(STR)
#define __GXX_ABI_VERSION 1013
#define __SCHAR_MAX__ 0x7f
#define __SHRT_MAX__ 0x7fff
#define __INT_MAX__ 0x7fffffff
#define __LONG_MAX__ 0x7fffffffL
#define __LONG_LONG_MAX__ 0x7fffffffffffffffLL
#define __WCHAR_MAX__ 0x7fffffff
#define __WCHAR_MIN__ (-__WCHAR_MAX__ - 1)
#define __WINT_MAX__ 0xffffffffU
#define __WINT_MIN__ 0U
#define __PTRDIFF_MAX__ 0x7fffffff
#define __SIZE_MAX__ 0xffffffffU
#define __SCHAR_WIDTH__ 8
#define __SHRT_WIDTH__ 16
#define __INT_WIDTH__ 32
#define __LONG_WIDTH__ 32
#define __LONG_LONG_WIDTH__ 64
#define __WCHAR_WIDTH__ 32
#define __WINT_WIDTH__ 32
#define __PTRDIFF_WIDTH__ 32
#define __SIZE_WIDTH__ 32
#define __INTMAX_MAX__ 0x7fffffffffffffffLL
#define __INTMAX_C(c) c ## LL
#define __UINTMAX_MAX__ 0xffffffffffffffffULL
#define __UINTMAX_C(c) c ## ULL
#define __INTMAX_WIDTH__ 64
#define __SIG_ATOMIC_MAX__ 0x7fffffff
#define __SIG_ATOMIC_MIN__ (-__SIG_ATOMIC_MAX__ - 1)
#define __SIG_ATOMIC_WIDTH__ 32
#define __INT8_MAX__ 0x7f
#define __INT16_MAX__ 0x7fff
#define __INT32_MAX__ 0x7fffffffL
#define __INT64_MAX__ 0x7fffffffffffffffLL
#define __UINT8_MAX__ 0xff
#define __UINT16_MAX__ 0xffff
#define __UINT32_MAX__ 0xffffffffUL
#define __UINT64_MAX__ 0xffffffffffffffffULL
#define __INT_LEAST8_MAX__ 0x7f
#define __INT8_C(c) c
#define __INT_LEAST8_WIDTH__ 8
#define __INT_LEAST16_MAX__ 0x7fff
#define __INT16_C(c) c
#define __INT_LEAST16_WIDTH__ 16
#define __INT_LEAST32_MAX__ 0x7fffffffL
#define __INT32_C(c) c ## L
#define __INT_LEAST32_WIDTH__ 32
#define __INT_LEAST64_MAX__ 0x7fffffffffffffffLL
#define __INT64_C(c) c ## LL
#define __INT_LEAST64_WIDTH__ 64
#define __UINT_LEAST8_MAX__ 0xff
#define __UINT8_C(c) c
#define __UINT_LEAST16_MAX__ 0xffff
#define __UINT16_C(c) c
#define __UINT_LEAST32_MAX__ 0xffffffffUL
#define __UINT32_C(c) c ## UL
#define __UINT_LEAST64_MAX__ 0xffffffffffffffffULL
#define __UINT64_C(c) c ## ULL
#define __INT_FAST8_MAX__ 0x7fffffff
#define __INT_FAST8_WIDTH__ 32
#define __INT_FAST16_MAX__ 0x7fffffff
#define __INT_FAST16_WIDTH__ 32
#define __INT_FAST32_MAX__ 0x7fffffff
#define __INT_FAST32_WIDTH__ 32
#define __INT_FAST64_MAX__ 0x7fffffffffffffffLL
#define __INT_FAST64_WIDTH__ 64
#define __UINT_FAST8_MAX__ 0xffffffffU
#define __UINT_FAST16_MAX__ 0xffffffffU
#define __UINT_FAST32_MAX__ 0xffffffffU
#define __UINT_FAST64_MAX__ 0xffffffffffffffffULL
#define __INTPTR_MAX__ 0x7fffffff
#define __INTPTR_WIDTH__ 32
#define __UINTPTR_MAX__ 0xffffffffU
#define __GCC_IEC_559 0
#define __GCC_IEC_559_COMPLEX 0
#define __FLT_EVAL_METHOD__ 0
#define __FLT_EVAL_METHOD_TS_18661_3__ 0
#define __DEC_EVAL_METHOD__ 2
#define __FLT_RADIX__ 2
#define __FLT_MANT_DIG__ 24
#define __FLT_DIG__ 6
#define __FLT_MIN_EXP__ (-125)
#define __FLT_MIN_10_EXP__ (-37)
#define __FLT_MAX_EXP__ 128
#define __FLT_MAX_10_EXP__ 38
#define __FLT_DECIMAL_DIG__ 9
#define __FLT_MAX__ 3.40282346638528859811704183484516925e+38F
#define __FLT_MIN__ 1.17549435082228750796873653722224568e-38F
#define __FLT_EPSILON__ 1.19209289550781250000000000000000000e-7F
#define __FLT_DENORM_MIN__ 1.40129846432481707092372958328991613e-45F
#define __FLT_HAS_DENORM__ 1
#define __FLT_HAS_INFINITY__ 1
#define __FLT_HAS_QUIET_NAN__ 1
#define __DBL_MANT_DIG__ 53
#define __DBL_DIG__ 15
#define __DBL_MIN_EXP__ (-1021)
#define __DBL_MIN_10_EXP__ (-307)
#define __DBL_MAX_EXP__ 1024
#define __DBL_MAX_10_EXP__ 308
#define __DBL_DECIMAL_DIG__ 17
#define __DBL_MAX__ ((double)1.79769313486231570814527423731704357e+308L)
#define __DBL_MIN__ ((double)2.22507385850720138309023271733240406e-308L)
#define __DBL_EPSILON__ ((double)2.22044604925031308084726333618164062e-16L)
#define __DBL_DENORM_MIN__ ((double)4.94065645841246544176568792868221372e-324L)
#define __DBL_HAS_DENORM__ 1
#define __DBL_HAS_INFINITY__ 1
#define __DBL_HAS_QUIET_NAN__ 1
#define __LDBL_MANT_DIG__ 113
#define __LDBL_DIG__ 33
#define __LDBL_MIN_EXP__ (-16381)
#define __LDBL_MIN_10_EXP__ (-4931)
#define __LDBL_MAX_EXP__ 16384
#define __LDBL_MAX_10_EXP__ 4932
#define __DECIMAL_DIG__ 36
#define __LDBL_DECIMAL_DIG__ 36
#define __LDBL_MAX__ 1.18973149535723176508575932662800702e+4932L
#define __LDBL_MIN__ 3.36210314311209350626267781732175260e-4932L
#define __LDBL_EPSILON__ 1.92592994438723585305597794258492732e-34L
#define __LDBL_DENORM_MIN__ 6.47517511943802511092443895822764655e-4966L
#define __LDBL_HAS_DENORM__ 1
#define __LDBL_HAS_INFINITY__ 1
#define __LDBL_HAS_QUIET_NAN__ 1
#define __FLT32_MANT_DIG__ 24
#define __FLT32_DIG__ 6
#define __FLT32_MIN_EXP__ (-125)
#define __FLT32_MIN_10_EXP__ (-37)
#define __FLT32_MAX_EXP__ 128
#define __FLT32_MAX_10_EXP__ 38
#define __FLT32_DECIMAL_DIG__ 9
#define __FLT32_MAX__ 3.40282346638528859811704183484516925e+38F32
#define __FLT32_MIN__ 1.17549435082228750796873653722224568e-38F32
#define __FLT32_EPSILON__ 1.19209289550781250000000000000000000e-7F32
#define __FLT32_DENORM_MIN__ 1.40129846432481707092372958328991613e-45F32
#define __FLT32_HAS_DENORM__ 1
#define __FLT32_HAS_INFINITY__ 1
#define __FLT32_HAS_QUIET_NAN__ 1
#define __FLT64_MANT_DIG__ 53
#define __FLT64_DIG__ 15
#define __FLT64_MIN_EXP__ (-1021)
#define __FLT64_MIN_10_EXP__ (-307)
#define __FLT64_MAX_EXP__ 1024
#define __FLT64_MAX_10_EXP__ 308
#define __FLT64_DECIMAL_DIG__ 17
#define __FLT64_MAX__ 1.79769313486231570814527423731704357e+308F64
#define __FLT64_MIN__ 2.22507385850720138309023271733240406e-308F64
#define __FLT64_EPSILON__ 2.22044604925031308084726333618164062e-16F64
#define __FLT64_DENORM_MIN__ 4.94065645841246544176568792868221372e-324F64
#define __FLT64_HAS_DENORM__ 1
#define __FLT64_HAS_INFINITY__ 1
#define __FLT64_HAS_QUIET_NAN__ 1
#define __FLT128_MANT_DIG__ 113
#define __FLT128_DIG__ 33
#define __FLT128_MIN_EXP__ (-16381)
#define __FLT128_MIN_10_EXP__ (-4931)
#define __FLT128_MAX_EXP__ 16384
#define __FLT128_MAX_10_EXP__ 4932
#define __FLT128_DECIMAL_DIG__ 36
#define __FLT128_MAX__ 1.18973149535723176508575932662800702e+4932F128
#define __FLT128_MIN__ 3.36210314311209350626267781732175260e-4932F128
#define __FLT128_EPSILON__ 1.92592994438723585305597794258492732e-34F128
#define __FLT128_DENORM_MIN__ 6.47517511943802511092443895822764655e-4966F128
#define __FLT128_HAS_DENORM__ 1
#define __FLT128_HAS_INFINITY__ 1
#define __FLT128_HAS_QUIET_NAN__ 1
#define __FLT32X_MANT_DIG__ 53
#define __FLT32X_DIG__ 15
#define __FLT32X_MIN_EXP__ (-1021)
#define __FLT32X_MIN_10_EXP__ (-307)
#define __FLT32X_MAX_EXP__ 1024
#define __FLT32X_MAX_10_EXP__ 308
#define __FLT32X_DECIMAL_DIG__ 17
#define __FLT32X_MAX__ 1.79769313486231570814527423731704357e+308F32x
#define __FLT32X_MIN__ 2.22507385850720138309023271733240406e-308F32x
#define __FLT32X_EPSILON__ 2.22044604925031308084726333618164062e-16F32x
#define __FLT32X_DENORM_MIN__ 4.94065645841246544176568792868221372e-324F32x
#define __FLT32X_HAS_DENORM__ 1
#define __FLT32X_HAS_INFINITY__ 1
#define __FLT32X_HAS_QUIET_NAN__ 1
#define __FLT64X_MANT_DIG__ 113
#define __FLT64X_DIG__ 33
#define __FLT64X_MIN_EXP__ (-16381)
#define __FLT64X_MIN_10_EXP__ (-4931)
#define __FLT64X_MAX_EXP__ 16384
#define __FLT64X_MAX_10_EXP__ 4932
#define __FLT64X_DECIMAL_DIG__ 36
#define __FLT64X_MAX__ 1.18973149535723176508575932662800702e+4932F64x
#define __FLT64X_MIN__ 3.36210314311209350626267781732175260e-4932F64x
#define __FLT64X_EPSILON__ 1.92592994438723585305597794258492732e-34F64x
#define __FLT64X_DENORM_MIN__ 6.47517511943802511092443895822764655e-4966F64x
#define __FLT64X_HAS_DENORM__ 1
#define __FLT64X_HAS_INFINITY__ 1
#define __FLT64X_HAS_QUIET_NAN__ 1
#define __DEC32_MANT_DIG__ 7
#define __DEC32_MIN_EXP__ (-94)
#define __DEC32_MAX_EXP__ 97
#define __DEC32_MIN__ 1E-95DF
#define __DEC32_MAX__ 9.999999E96DF
#define __DEC32_EPSILON__ 1E-6DF
#define __DEC32_SUBNORMAL_MIN__ 0.000001E-95DF
#define __DEC64_MANT_DIG__ 16
#define __DEC64_MIN_EXP__ (-382)
#define __DEC64_MAX_EXP__ 385
#define __DEC64_MIN__ 1E-383DD
#define __DEC64_MAX__ 9.999999999999999E384DD
#define __DEC64_EPSILON__ 1E-15DD
#define __DEC64_SUBNORMAL_MIN__ 0.000000000000001E-383DD
#define __DEC128_MANT_DIG__ 34
#define __DEC128_MIN_EXP__ (-6142)
#define __DEC128_MAX_EXP__ 6145
#define __DEC128_MIN__ 1E-6143DL
#define __DEC128_MAX__ 9.999999999999999999999999999999999E6144DL
#define __DEC128_EPSILON__ 1E-33DL
#define __DEC128_SUBNORMAL_MIN__ 0.000000000000000000000000000000001E-6143DL
#define __REGISTER_PREFIX__ 
#define __USER_LABEL_PREFIX__ 
#define __GNUC_STDC_INLINE__ 1
#define __NO_INLINE__ 1
#define __CHAR_UNSIGNED__ 1
#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4 1
#define __GCC_ATOMIC_BOOL_LOCK_FREE 1
#define __GCC_ATOMIC_CHAR_LOCK_FREE 1
#define __GCC_ATOMIC_CHAR16_T_LOCK_FREE 1
#define __GCC_ATOMIC_CHAR32_T_LOCK_FREE 2
#define __GCC_ATOMIC_WCHAR_T_LOCK_FREE 2
#define __GCC_ATOMIC_SHORT_LOCK_FREE 1
#define __GCC_ATOMIC_INT_LOCK_FREE 2
#define __GCC_ATOMIC_LONG_LOCK_FREE 2
#define __GCC_ATOMIC_LLONG_LOCK_FREE 1
#define __GCC_ATOMIC_TEST_AND_SET_TRUEVAL 1
#define __GCC_ATOMIC_POINTER_LOCK_FREE 2
#define __GCC_HAVE_DWARF2_CFI_ASM 1
#define __PRAGMA_REDEFINE_EXTNAME 1
#define __SIZEOF_WCHAR_T__ 4
#define __SIZEOF_WINT_T__ 4
#define __SIZEOF_PTRDIFF_T__ 4
#define __riscv 1
#define __riscv_compressed 1
#define __riscv_atomic 1
#define __riscv_mul 1
#define __riscv_div 1
#define __riscv_muldiv 1
#define __riscv_xlen 32
#define __riscv_float_abi_soft 1
#define __riscv_cmodel_medany 1
#define __ELF__ 1
# 1 "<command-line>"
#define USE_PLIC 1
#define USE_M_TIME 1
#define NO_INIT 1
# 1 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rtconfig_preinc.h" 1


#define RTCONFIG_PREINC_H__ 




#define RTT_U8G2 
#define RT_USING_LIBC 
#define RT_USING_NEWLIBC 
#define _POSIX_C_SOURCE 1
#define __RTTHREAD__ 
# 1 "<command-line>" 2
# 1 "../applications/bmi270/bmi2.c"
# 1 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\applications/bmi270/bmi2.h" 1
# 51 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\applications/bmi270/bmi2.h"
#define BMI2_H_ 
# 62 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\applications/bmi270/bmi2.h"
# 1 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\applications/bmi270/bmi2_defs.h" 1
# 40 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\applications/bmi270/bmi2_defs.h"
#define BMI2_DEFS_H_ 
# 49 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\applications/bmi270/bmi2_defs.h"
# 1 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\stdint.h" 1 3
# 10 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\stdint.h" 3
#define _STDINT_H 

# 1 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\machine\\_default_types.h" 1 3





#define _MACHINE__DEFAULT_TYPES_H 

# 1 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\sys\\features.h" 1 3
# 22 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\sys\\features.h" 3
#define _SYS_FEATURES_H 





# 1 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\_newlib_version.h" 1 3



#define _NEWLIB_VERSION_H__ 1

#define _NEWLIB_VERSION "3.0.0"
#define __NEWLIB__ 3
#define __NEWLIB_MINOR__ 0
#define __NEWLIB_PATCHLEVEL__ 0
# 29 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\sys\\features.h" 2 3




#define __GNUC_PREREQ(maj,min) ((__GNUC__ << 16) + __GNUC_MINOR__ >= ((maj) << 16) + (min))






#define __GNUC_PREREQ__(ma,mi) __GNUC_PREREQ(ma, mi)
# 249 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\sys\\features.h" 3
#define __ATFILE_VISIBLE 0





#define __BSD_VISIBLE 0





#define __GNU_VISIBLE 0




#define __ISO_C_VISIBLE 2011
# 277 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\sys\\features.h" 3
#define __LARGEFILE_VISIBLE 0





#define __MISC_VISIBLE 0
# 297 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\sys\\features.h" 3
#define __POSIX_VISIBLE 199009







#define __SVID_VISIBLE 0
# 319 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\sys\\features.h" 3
#define __XSI_VISIBLE 0
# 330 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\sys\\features.h" 3
#define __SSP_FORTIFY_LEVEL 0
# 9 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\machine\\_default_types.h" 2 3






#define __EXP(x) __ ##x ##__
# 26 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\machine\\_default_types.h" 3
#define __have_longlong64 1






#define __have_long32 1








# 41 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\machine\\_default_types.h" 3
typedef signed char __int8_t;

typedef unsigned char __uint8_t;



#define ___int8_t_defined 1







typedef short int __int16_t;

typedef short unsigned int __uint16_t;



#define ___int16_t_defined 1
# 77 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\machine\\_default_types.h" 3
typedef long int __int32_t;

typedef long unsigned int __uint32_t;



#define ___int32_t_defined 1
# 103 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\machine\\_default_types.h" 3
typedef long long int __int64_t;

typedef long long unsigned int __uint64_t;



#define ___int64_t_defined 1
# 134 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\machine\\_default_types.h" 3
typedef signed char __int_least8_t;

typedef unsigned char __uint_least8_t;



#define ___int_least8_t_defined 1
# 160 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\machine\\_default_types.h" 3
typedef short int __int_least16_t;

typedef short unsigned int __uint_least16_t;



#define ___int_least16_t_defined 1
# 182 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\machine\\_default_types.h" 3
typedef long int __int_least32_t;

typedef long unsigned int __uint_least32_t;



#define ___int_least32_t_defined 1
# 200 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\machine\\_default_types.h" 3
typedef long long int __int_least64_t;

typedef long long unsigned int __uint_least64_t;



#define ___int_least64_t_defined 1







typedef long long int __intmax_t;







typedef long long unsigned int __uintmax_t;







typedef int __intptr_t;

typedef unsigned int __uintptr_t;
# 244 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\machine\\_default_types.h" 3
#undef __EXP
# 13 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\stdint.h" 2 3
# 1 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\sys\\_intsup.h" 1 3
# 10 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\sys\\_intsup.h" 3
#define _SYS__INTSUP_H 





#define __STDINT_EXP(x) __ ##x ##__
# 35 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\sys\\_intsup.h" 3
       
       
       
       
       
       
       
#undef signed
#undef unsigned
#undef char
#undef short
#undef int
#undef __int20
#undef long
#define signed +0
#define unsigned +0
#define char +0
#define short +1
#define __int20 +2
#define int +2
#define long +4
# 64 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\sys\\_intsup.h" 3
#define _INTPTR_EQ_INT 






#define _INT32_EQ_LONG 







#define __INT8 "hh"
# 90 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\sys\\_intsup.h" 3
#define __INT16 "h"
# 101 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\sys\\_intsup.h" 3
#define __INT32 "l"
# 110 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\sys\\_intsup.h" 3
#define __INT64 "ll"






#define __FAST8 
# 126 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\sys\\_intsup.h" 3
#define __FAST16 






#define __FAST32 
# 144 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\sys\\_intsup.h" 3
#define __FAST64 "ll"



#define __LEAST8 "hh"
# 159 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\sys\\_intsup.h" 3
#define __LEAST16 "h"
# 170 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\sys\\_intsup.h" 3
#define __LEAST32 "l"
# 179 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\sys\\_intsup.h" 3
#define __LEAST64 "ll"

#undef signed
#undef unsigned
#undef char
#undef short
#undef int
#undef long
       
       
       
       
       
# 191 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\sys\\_intsup.h" 3
#undef __int20
       
       
# 14 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\stdint.h" 2 3
# 1 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\sys\\_stdint.h" 1 3
# 10 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\sys\\_stdint.h" 3
#define _SYS__STDINT_H 
# 20 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\sys\\_stdint.h" 3
typedef __int8_t int8_t ;
#define _INT8_T_DECLARED 


typedef __uint8_t uint8_t ;
#define _UINT8_T_DECLARED 

#define __int8_t_defined 1




typedef __int16_t int16_t ;
#define _INT16_T_DECLARED 


typedef __uint16_t uint16_t ;
#define _UINT16_T_DECLARED 

#define __int16_t_defined 1




typedef __int32_t int32_t ;
#define _INT32_T_DECLARED 


typedef __uint32_t uint32_t ;
#define _UINT32_T_DECLARED 

#define __int32_t_defined 1




typedef __int64_t int64_t ;
#define _INT64_T_DECLARED 


typedef __uint64_t uint64_t ;
#define _UINT64_T_DECLARED 

#define __int64_t_defined 1



typedef __intmax_t intmax_t;
#define _INTMAX_T_DECLARED 



typedef __uintmax_t uintmax_t;
#define _UINTMAX_T_DECLARED 



typedef __intptr_t intptr_t;
#define _INTPTR_T_DECLARED 



typedef __uintptr_t uintptr_t;
#define _UINTPTR_T_DECLARED 
# 15 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\stdint.h" 2 3






typedef __int_least8_t int_least8_t;
typedef __uint_least8_t uint_least8_t;
#define __int_least8_t_defined 1



typedef __int_least16_t int_least16_t;
typedef __uint_least16_t uint_least16_t;
#define __int_least16_t_defined 1



typedef __int_least32_t int_least32_t;
typedef __uint_least32_t uint_least32_t;
#define __int_least32_t_defined 1



typedef __int_least64_t int_least64_t;
typedef __uint_least64_t uint_least64_t;
#define __int_least64_t_defined 1
# 51 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\stdint.h" 3
  typedef int int_fast8_t;
  typedef unsigned int uint_fast8_t;
#define __int_fast8_t_defined 1







  typedef int int_fast16_t;
  typedef unsigned int uint_fast16_t;
#define __int_fast16_t_defined 1







  typedef int int_fast32_t;
  typedef unsigned int uint_fast32_t;
#define __int_fast32_t_defined 1







  typedef long long int int_fast64_t;
  typedef long long unsigned int uint_fast64_t;
#define __int_fast64_t_defined 1
# 128 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\stdint.h" 3
#define INTPTR_MIN (-__INTPTR_MAX__ - 1)
#define INTPTR_MAX (__INTPTR_MAX__)
#define UINTPTR_MAX (__UINTPTR_MAX__)
# 152 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\stdint.h" 3
#define INT8_MIN (-__INT8_MAX__ - 1)
#define INT8_MAX (__INT8_MAX__)
#define UINT8_MAX (__UINT8_MAX__)







#define INT_LEAST8_MIN (-__INT_LEAST8_MAX__ - 1)
#define INT_LEAST8_MAX (__INT_LEAST8_MAX__)
#define UINT_LEAST8_MAX (__UINT_LEAST8_MAX__)
# 174 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\stdint.h" 3
#define INT16_MIN (-__INT16_MAX__ - 1)
#define INT16_MAX (__INT16_MAX__)
#define UINT16_MAX (__UINT16_MAX__)







#define INT_LEAST16_MIN (-__INT_LEAST16_MAX__ - 1)
#define INT_LEAST16_MAX (__INT_LEAST16_MAX__)
#define UINT_LEAST16_MAX (__UINT_LEAST16_MAX__)
# 196 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\stdint.h" 3
#define INT32_MIN (-__INT32_MAX__ - 1)
#define INT32_MAX (__INT32_MAX__)
#define UINT32_MAX (__UINT32_MAX__)
# 212 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\stdint.h" 3
#define INT_LEAST32_MIN (-__INT_LEAST32_MAX__ - 1)
#define INT_LEAST32_MAX (__INT_LEAST32_MAX__)
#define UINT_LEAST32_MAX (__UINT_LEAST32_MAX__)
# 230 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\stdint.h" 3
#define INT64_MIN (-__INT64_MAX__ - 1)
#define INT64_MAX (__INT64_MAX__)
#define UINT64_MAX (__UINT64_MAX__)
# 246 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\stdint.h" 3
#define INT_LEAST64_MIN (-__INT_LEAST64_MAX__ - 1)
#define INT_LEAST64_MAX (__INT_LEAST64_MAX__)
#define UINT_LEAST64_MAX (__UINT_LEAST64_MAX__)
# 262 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\stdint.h" 3
#define INT_FAST8_MIN (-__INT_FAST8_MAX__ - 1)
#define INT_FAST8_MAX (__INT_FAST8_MAX__)
#define UINT_FAST8_MAX (__UINT_FAST8_MAX__)
# 278 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\stdint.h" 3
#define INT_FAST16_MIN (-__INT_FAST16_MAX__ - 1)
#define INT_FAST16_MAX (__INT_FAST16_MAX__)
#define UINT_FAST16_MAX (__UINT_FAST16_MAX__)
# 294 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\stdint.h" 3
#define INT_FAST32_MIN (-__INT_FAST32_MAX__ - 1)
#define INT_FAST32_MAX (__INT_FAST32_MAX__)
#define UINT_FAST32_MAX (__UINT_FAST32_MAX__)
# 310 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\stdint.h" 3
#define INT_FAST64_MIN (-__INT_FAST64_MAX__ - 1)
#define INT_FAST64_MAX (__INT_FAST64_MAX__)
#define UINT_FAST64_MAX (__UINT_FAST64_MAX__)
# 326 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\stdint.h" 3
#define INTMAX_MAX (__INTMAX_MAX__)
#define INTMAX_MIN (-INTMAX_MAX - 1)







#define UINTMAX_MAX (__UINTMAX_MAX__)







#define SIZE_MAX (__SIZE_MAX__)





#define SIG_ATOMIC_MIN (-__STDINT_EXP(INT_MAX) - 1)
#define SIG_ATOMIC_MAX (__STDINT_EXP(INT_MAX))



#define PTRDIFF_MAX (__PTRDIFF_MAX__)



#define PTRDIFF_MIN (-PTRDIFF_MAX - 1)




#define WCHAR_MIN (__WCHAR_MIN__)
# 374 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\stdint.h" 3
#define WCHAR_MAX (__WCHAR_MAX__)
# 384 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\stdint.h" 3
#define WINT_MAX (__WINT_MAX__)




#define WINT_MIN (__WINT_MIN__)






#define INT8_C(x) __INT8_C(x)
#define UINT8_C(x) __UINT8_C(x)
# 408 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\stdint.h" 3
#define INT16_C(x) __INT16_C(x)
#define UINT16_C(x) __UINT16_C(x)
# 420 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\stdint.h" 3
#define INT32_C(x) __INT32_C(x)
#define UINT32_C(x) __UINT32_C(x)
# 433 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\stdint.h" 3
#define INT64_C(x) __INT64_C(x)
#define UINT64_C(x) __UINT64_C(x)
# 449 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\stdint.h" 3
#define INTMAX_C(x) __INTMAX_C(x)
#define UINTMAX_C(x) __UINTMAX_C(x)
# 50 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\applications/bmi270/bmi2_defs.h" 2
# 1 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\lib\\gcc\\riscv-none-embed\\8.2.0\\include\\stddef.h" 1 3 4
# 39 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\lib\\gcc\\riscv-none-embed\\8.2.0\\include\\stddef.h" 3 4
#define _STDDEF_H 
#define _STDDEF_H_ 

#define _ANSI_STDDEF_H 
# 137 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\lib\\gcc\\riscv-none-embed\\8.2.0\\include\\stddef.h" 3 4
#define _PTRDIFF_T 
#define _T_PTRDIFF_ 
#define _T_PTRDIFF 
#define __PTRDIFF_T 
#define _PTRDIFF_T_ 
#define _BSD_PTRDIFF_T_ 
#define ___int_ptrdiff_t_h 
#define _GCC_PTRDIFF_T 
#define _PTRDIFF_T_DECLARED 



typedef int ptrdiff_t;
# 161 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\lib\\gcc\\riscv-none-embed\\8.2.0\\include\\stddef.h" 3 4
#undef __need_ptrdiff_t
# 187 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\lib\\gcc\\riscv-none-embed\\8.2.0\\include\\stddef.h" 3 4
#define __size_t__ 
#define __SIZE_T__ 
#define _SIZE_T 
#define _SYS_SIZE_T_H 
#define _T_SIZE_ 
#define _T_SIZE 
#define __SIZE_T 
#define _SIZE_T_ 
#define _BSD_SIZE_T_ 
#define _SIZE_T_DEFINED_ 
#define _SIZE_T_DEFINED 
#define _BSD_SIZE_T_DEFINED_ 
#define _SIZE_T_DECLARED 
#define ___int_size_t_h 
#define _GCC_SIZE_T 
#define _SIZET_ 







#define __size_t 





typedef unsigned int size_t;
# 238 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\lib\\gcc\\riscv-none-embed\\8.2.0\\include\\stddef.h" 3 4
#undef __need_size_t
# 267 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\lib\\gcc\\riscv-none-embed\\8.2.0\\include\\stddef.h" 3 4
#define __wchar_t__ 
#define __WCHAR_T__ 
#define _WCHAR_T 
#define _T_WCHAR_ 
#define _T_WCHAR 
#define __WCHAR_T 
#define _WCHAR_T_ 
#define _BSD_WCHAR_T_ 
#define _WCHAR_T_DEFINED_ 
#define _WCHAR_T_DEFINED 
#define _WCHAR_T_H 
#define ___int_wchar_t_h 
#define __INT_WCHAR_T_H 
#define _GCC_WCHAR_T 
#define _WCHAR_T_DECLARED 
# 294 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\lib\\gcc\\riscv-none-embed\\8.2.0\\include\\stddef.h" 3 4
#undef _BSD_WCHAR_T_
# 328 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\lib\\gcc\\riscv-none-embed\\8.2.0\\include\\stddef.h" 3 4
typedef int wchar_t;
# 347 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\lib\\gcc\\riscv-none-embed\\8.2.0\\include\\stddef.h" 3 4
#undef __need_wchar_t
# 401 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\lib\\gcc\\riscv-none-embed\\8.2.0\\include\\stddef.h" 3 4
#undef NULL




#define NULL ((void *)0)





#undef __need_NULL




#define offsetof(TYPE,MEMBER) __builtin_offsetof (TYPE, MEMBER)




#define _GCC_MAX_ALIGN_T 



typedef struct {
  long long __max_align_ll __attribute__((__aligned__(__alignof__(long long))));
  long double __max_align_ld __attribute__((__aligned__(__alignof__(long double))));
# 437 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\lib\\gcc\\riscv-none-embed\\8.2.0\\include\\stddef.h" 3 4
} max_align_t;
# 51 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\applications/bmi270/bmi2_defs.h" 2
# 91 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\applications/bmi270/bmi2_defs.h"
#define BMI2_SET_BITS(reg_data,bitname,data) ((reg_data & ~(bitname ##_MASK)) | ((data << bitname ##_POS) & bitname ##_MASK))



#define BMI2_GET_BITS(reg_data,bitname) ((reg_data & (bitname ##_MASK)) >> (bitname ##_POS))



#define BMI2_SET_BIT_POS0(reg_data,bitname,data) ((reg_data & ~(bitname ##_MASK)) | (data & bitname ##_MASK))



#define BMI2_GET_BIT_POS0(reg_data,bitname) (reg_data & (bitname ##_MASK))
#define BMI2_SET_BIT_VAL0(reg_data,bitname) (reg_data & ~(bitname ##_MASK))


#define BMI2_GET_LSB(var) (uint8_t)(var & BMI2_SET_LOW_BYTE)
#define BMI2_GET_MSB(var) (uint8_t)((var & BMI2_SET_HIGH_BYTE) >> 8)


#define BMI2_INTF_RETURN_TYPE int8_t



#define BMI2_ABS(a) ((a) > 0 ? (a) : -(a))


#define BMI2_SET_LOW_BYTE UINT16_C(0x00FF)
#define BMI2_SET_HIGH_BYTE UINT16_C(0xFF00)
#define BMI2_SET_LOW_NIBBLE UINT8_C(0x0F)


#define BMI2_ENABLE UINT8_C(1)
#define BMI2_DISABLE UINT8_C(0)


#define BMI2_TRUE UINT8_C(1)
#define BMI2_FALSE UINT8_C(0)


#define BMI2_MAX_LEN UINT8_C(128)


#define BMI2_INTF_RET_SUCCESS INT8_C(0)


#define BMI2_OK INT8_C(0)


#define BMI2_E_NULL_PTR INT8_C(-1)
#define BMI2_E_COM_FAIL INT8_C(-2)
#define BMI2_E_DEV_NOT_FOUND INT8_C(-3)
#define BMI2_E_OUT_OF_RANGE INT8_C(-4)
#define BMI2_E_ACC_INVALID_CFG INT8_C(-5)
#define BMI2_E_GYRO_INVALID_CFG INT8_C(-6)
#define BMI2_E_ACC_GYR_INVALID_CFG INT8_C(-7)
#define BMI2_E_INVALID_SENSOR INT8_C(-8)
#define BMI2_E_CONFIG_LOAD INT8_C(-9)
#define BMI2_E_INVALID_PAGE INT8_C(-10)
#define BMI2_E_INVALID_FEAT_BIT INT8_C(-11)
#define BMI2_E_INVALID_INT_PIN INT8_C(-12)
#define BMI2_E_SET_APS_FAIL INT8_C(-13)
#define BMI2_E_AUX_INVALID_CFG INT8_C(-14)
#define BMI2_E_AUX_BUSY INT8_C(-15)
#define BMI2_E_SELF_TEST_FAIL INT8_C(-16)
#define BMI2_E_REMAP_ERROR INT8_C(-17)
#define BMI2_E_GYR_USER_GAIN_UPD_FAIL INT8_C(-18)
#define BMI2_E_SELF_TEST_NOT_DONE INT8_C(-19)
#define BMI2_E_INVALID_INPUT INT8_C(-20)
#define BMI2_E_INVALID_STATUS INT8_C(-21)
#define BMI2_E_CRT_ERROR INT8_C(-22)
#define BMI2_E_ST_ALREADY_RUNNING INT8_C(-23)
#define BMI2_E_CRT_READY_FOR_DL_FAIL_ABORT INT8_C(-24)
#define BMI2_E_DL_ERROR INT8_C(-25)
#define BMI2_E_PRECON_ERROR INT8_C(-26)
#define BMI2_E_ABORT_ERROR INT8_C(-27)
#define BMI2_E_GYRO_SELF_TEST_ERROR INT8_C(-28)
#define BMI2_E_GYRO_SELF_TEST_TIMEOUT INT8_C(-29)
#define BMI2_E_WRITE_CYCLE_ONGOING INT8_C(-30)
#define BMI2_E_WRITE_CYCLE_TIMEOUT INT8_C(-31)
#define BMI2_E_ST_NOT_RUNING INT8_C(-32)
#define BMI2_E_DATA_RDY_INT_FAILED INT8_C(-33)
#define BMI2_E_INVALID_FOC_POSITION INT8_C(-34)


#define BMI2_W_FIFO_EMPTY INT8_C(1)
#define BMI2_W_PARTIAL_READ INT8_C(2)
#define BMI2_W_DUMMY_BYTE INT8_C(3)


#define BMI2_FIFO_HEADERLESS_DUMMY_ACC UINT8_C(0x01)
#define BMI2_FIFO_HEADERLESS_DUMMY_GYR UINT8_C(0x02)
#define BMI2_FIFO_HEADERLESS_DUMMY_AUX UINT8_C(0x03)
#define BMI2_FIFO_HEADERLESS_DUMMY_BYTE_1 UINT8_C(0x7F)
#define BMI2_FIFO_HEADERLESS_DUMMY_BYTE_2 UINT8_C(0x00)
#define BMI2_FIFO_HEADERLESS_DUMMY_BYTE_3 UINT8_C(0x80)


#define BMI2_I_MIN_VALUE UINT8_C(1)
#define BMI2_I_MAX_VALUE UINT8_C(2)


#define BMI2_CHIP_ID_ADDR UINT8_C(0x00)
#define BMI2_STATUS_ADDR UINT8_C(0x03)
#define BMI2_AUX_X_LSB_ADDR UINT8_C(0x04)
#define BMI2_ACC_X_LSB_ADDR UINT8_C(0x0C)
#define BMI2_GYR_X_LSB_ADDR UINT8_C(0x12)
#define BMI2_SENSORTIME_ADDR UINT8_C(0x18)
#define BMI2_EVENT_ADDR UINT8_C(0x1B)
#define BMI2_INT_STATUS_0_ADDR UINT8_C(0x1C)
#define BMI2_INT_STATUS_1_ADDR UINT8_C(0x1D)
#define BMI2_SC_OUT_0_ADDR UINT8_C(0x1E)
#define BMI2_SYNC_COMMAND_ADDR UINT8_C(0x1E)
#define BMI2_GYR_CAS_GPIO0_ADDR UINT8_C(0x1E)
#define BMI2_INTERNAL_STATUS_ADDR UINT8_C(0x21)
#define BMI2_FIFO_LENGTH_0_ADDR UINT8_C(0x24)
#define BMI2_FIFO_DATA_ADDR UINT8_C(0x26)
#define BMI2_FEAT_PAGE_ADDR UINT8_C(0x2F)
#define BMI2_FEATURES_REG_ADDR UINT8_C(0x30)
#define BMI2_ACC_CONF_ADDR UINT8_C(0x40)
#define BMI2_GYR_CONF_ADDR UINT8_C(0x42)
#define BMI2_AUX_CONF_ADDR UINT8_C(0x44)
#define BMI2_FIFO_DOWNS_ADDR UINT8_C(0x45)
#define BMI2_FIFO_WTM_0_ADDR UINT8_C(0x46)
#define BMI2_FIFO_WTM_1_ADDR UINT8_C(0x47)
#define BMI2_FIFO_CONFIG_0_ADDR UINT8_C(0x48)
#define BMI2_FIFO_CONFIG_1_ADDR UINT8_C(0x49)
#define BMI2_AUX_DEV_ID_ADDR UINT8_C(0x4B)
#define BMI2_AUX_IF_CONF_ADDR UINT8_C(0x4C)
#define BMI2_AUX_RD_ADDR UINT8_C(0x4D)
#define BMI2_AUX_WR_ADDR UINT8_C(0x4E)
#define BMI2_AUX_WR_DATA_ADDR UINT8_C(0x4F)
#define BMI2_INT1_IO_CTRL_ADDR UINT8_C(0x53)
#define BMI2_INT2_IO_CTRL_ADDR UINT8_C(0x54)
#define BMI2_INT_LATCH_ADDR UINT8_C(0x55)
#define BMI2_INT1_MAP_FEAT_ADDR UINT8_C(0x56)
#define BMI2_INT2_MAP_FEAT_ADDR UINT8_C(0x57)
#define BMI2_INT_MAP_DATA_ADDR UINT8_C(0x58)
#define BMI2_INIT_CTRL_ADDR UINT8_C(0x59)
#define BMI2_INIT_ADDR_0 UINT8_C(0x5B)
#define BMI2_INIT_ADDR_1 UINT8_C(0x5C)
#define BMI2_INIT_DATA_ADDR UINT8_C(0x5E)
#define BMI2_AUX_IF_TRIM UINT8_C(0x68)
#define BMI2_GYR_CRT_CONF_ADDR UINT8_C(0x69)
#define BMI2_NVM_CONF_ADDR UINT8_C(0x6A)
#define BMI2_IF_CONF_ADDR UINT8_C(0x6B)
#define BMI2_ACC_SELF_TEST_ADDR UINT8_C(0x6D)
#define BMI2_GYR_SELF_TEST_AXES_ADDR UINT8_C(0x6E)
#define BMI2_SELF_TEST_MEMS_ADDR UINT8_C(0x6F)
#define BMI2_NV_CONF_ADDR UINT8_C(0x70)
#define BMI2_ACC_OFF_COMP_0_ADDR UINT8_C(0x71)
#define BMI2_GYR_OFF_COMP_3_ADDR UINT8_C(0x74)
#define BMI2_GYR_OFF_COMP_6_ADDR UINT8_C(0x77)
#define BMI2_GYR_USR_GAIN_0_ADDR UINT8_C(0x78)
#define BMI2_PWR_CONF_ADDR UINT8_C(0x7C)
#define BMI2_PWR_CTRL_ADDR UINT8_C(0x7D)
#define BMI2_CMD_REG_ADDR UINT8_C(0x7E)


#define BMI2_I2C_PRIM_ADDR UINT8_C(0x68)
#define BMI2_I2C_SEC_ADDR UINT8_C(0x69)


#define BMI2_G_TRIGGER_CMD UINT8_C(0x02)
#define BMI2_USR_GAIN_CMD UINT8_C(0x03)
#define BMI2_NVM_PROG_CMD UINT8_C(0xA0)
#define BMI2_SOFT_RESET_CMD UINT8_C(0xB6)
#define BMI2_FIFO_FLUSH_CMD UINT8_C(0xB0)



#define BMI2_AUX_NUM_BYTES UINT8_C(8)
#define BMI2_ACC_NUM_BYTES UINT8_C(6)
#define BMI2_GYR_NUM_BYTES UINT8_C(6)
#define BMI2_ACC_GYR_NUM_BYTES UINT8_C(12)
#define BMI2_AUX_ACC_NUM_BYTES UINT8_C(14)
#define BMI2_ACC_GYR_AUX_NUM_BYTES UINT8_C(20)
#define BMI2_CRT_CONFIG_FILE_SIZE UINT16_C(2048)
#define BMI2_FEAT_SIZE_IN_BYTES UINT8_C(16)
#define BMI2_ACC_CONFIG_LENGTH UINT8_C(2)


#define BMI2_CONFIG_LOAD_SUCCESS UINT8_C(1)


#define BMI2_PAGE_0 UINT8_C(0)
#define BMI2_PAGE_1 UINT8_C(1)
#define BMI2_PAGE_2 UINT8_C(2)
#define BMI2_PAGE_3 UINT8_C(3)
#define BMI2_PAGE_4 UINT8_C(4)
#define BMI2_PAGE_5 UINT8_C(5)
#define BMI2_PAGE_6 UINT8_C(6)
#define BMI2_PAGE_7 UINT8_C(7)


#define BMI2_SENSOR_TIME_LSB_BYTE UINT8_C(0)
#define BMI2_SENSOR_TIME_XLSB_BYTE UINT8_C(1)
#define BMI2_SENSOR_TIME_MSB_BYTE UINT8_C(2)


#define BMI2_GYR_RDY_FOR_DL_MASK UINT8_C(0x08)
#define BMI2_GYR_CRT_RUNNING_MASK UINT8_C(0x04)


#define BMI2_AUX_BUSY_MASK UINT8_C(0x04)
#define BMI2_CMD_RDY_MASK UINT8_C(0x10)
#define BMI2_DRDY_AUX_MASK UINT8_C(0x20)
#define BMI2_DRDY_GYR_MASK UINT8_C(0x40)
#define BMI2_DRDY_ACC_MASK UINT8_C(0x80)


#define BMI2_SPI_RD_MASK UINT8_C(0x80)
#define BMI2_SPI_WR_MASK UINT8_C(0x7F)


#define BMI2_ADV_POW_EN_MASK UINT8_C(0x01)


#define BMI2_CONF_LOAD_EN_MASK UINT8_C(0x01)


#define BMI2_AUX_EN_MASK UINT8_C(0x01)
#define BMI2_GYR_EN_MASK UINT8_C(0x02)
#define BMI2_ACC_EN_MASK UINT8_C(0x04)
#define BMI2_TEMP_EN_MASK UINT8_C(0x08)


#define BMI2_EVENT_FLAG_MASK UINT8_C(0x1C)


#define BMI2_SWITCH_PAGE_EN_MASK UINT8_C(0x07)


#define BMI2_NV_ACC_OFFSET_MASK UINT8_C(0x08)


#define BMI2_CONFIG_MAJOR_MASK UINT16_C(0x3C0)
#define BMI2_CONFIG_MINOR_MASK UINT8_C(0x3F)


#define BMI2_ACT_RECG_POST_PROS_EN_DIS_MASK UINT8_C(0x01)
#define BMI2_ACT_RECG_BUFF_SIZE_MASK UINT8_C(0x0F)
#define BMI2_ACT_RECG_MIN_SEG_CONF_MASK UINT8_C(0x0F)


#define BMI2_HC_ACT_RECG_SEGMENT_SIZE_MASK UINT8_C(0x03)
#define BMI2_HC_ACT_RECG_PP_EN_MASK UINT8_C(0x01)
#define BMI2_HC_ACT_RECG_MIN_GDI_THRES_MASK UINT16_C(0xFFFF)
#define BMI2_HC_ACT_RECG_MAX_GDI_THRES_MASK UINT16_C(0xFFFF)
#define BMI2_HC_ACT_RECG_BUF_SIZE_MASK UINT16_C(0xFFFF)
#define BMI2_HC_ACT_RECG_MIN_SEG_CONF_MASK UINT16_C(0xFFFF)

#define BMI2_GYRO_CROSS_AXES_SENSE_MASK UINT8_C(0x7F)
#define BMI2_GYRO_CROSS_AXES_SENSE_SIGN_BIT_MASK UINT8_C(0x40)


#define BMI2_GYR_RDY_FOR_DL_POS UINT8_C(0x03)
#define BMI2_GYR_CRT_RUNNING_POS UINT8_C(0x02)


#define BMI2_AUX_BUSY_POS UINT8_C(0x02)
#define BMI2_CMD_RDY_POS UINT8_C(0x04)
#define BMI2_DRDY_AUX_POS UINT8_C(0x05)
#define BMI2_DRDY_GYR_POS UINT8_C(0x06)
#define BMI2_DRDY_ACC_POS UINT8_C(0x07)


#define BMI2_GYR_EN_POS UINT8_C(0x01)
#define BMI2_ACC_EN_POS UINT8_C(0x02)
#define BMI2_TEMP_EN_POS UINT8_C(0x03)


#define BMI2_EVENT_FLAG_POS UINT8_C(0x02)


#define BMI2_NV_ACC_OFFSET_POS UINT8_C(0x03)


#define BMI2_CONFIG_MAJOR_POS UINT8_C(0x06)



#define BMI2_POWER_OPT_MODE UINT8_C(0)


#define BMI2_PERF_OPT_MODE UINT8_C(1)


#define BMI2_CONFIG_INFO_LOWER UINT8_C(52)
#define BMI2_CONFIG_INFO_HIGHER UINT8_C(53)


#define BMI2_DRDY_ACC UINT8_C(0x80)
#define BMI2_DRDY_GYR UINT8_C(0x40)
#define BMI2_DRDY_AUX UINT8_C(0x20)
#define BMI2_CMD_RDY UINT8_C(0x10)
#define BMI2_AUX_BUSY UINT8_C(0x04)


#define BMI2_FOC_ACC_CONF_VAL UINT8_C(0xB7)


#define BMI2_FOC_GYR_CONF_VAL UINT8_C(0xB6)


#define BMI2_X_AXIS UINT8_C(0)
#define BMI2_Y_AXIS UINT8_C(1)
#define BMI2_Z_AXIS UINT8_C(2)


#define BMI2_INTERNAL_STATUS_READ_DELAY_MS UINT32_C(140000)





#define BMI2_ACCEL UINT8_C(0)
#define BMI2_GYRO UINT8_C(1)
#define BMI2_AUX UINT8_C(2)
#define BMI2_SIG_MOTION UINT8_C(3)
#define BMI2_ANY_MOTION UINT8_C(4)
#define BMI2_NO_MOTION UINT8_C(5)
#define BMI2_STEP_DETECTOR UINT8_C(6)
#define BMI2_STEP_COUNTER UINT8_C(7)
#define BMI2_STEP_ACTIVITY UINT8_C(8)
#define BMI2_GYRO_GAIN_UPDATE UINT8_C(9)
#define BMI2_TILT UINT8_C(10)
#define BMI2_UP_HOLD_TO_WAKE UINT8_C(11)
#define BMI2_GLANCE_DETECTOR UINT8_C(12)
#define BMI2_WAKE_UP UINT8_C(13)
#define BMI2_ORIENTATION UINT8_C(14)
#define BMI2_HIGH_G UINT8_C(15)
#define BMI2_LOW_G UINT8_C(16)
#define BMI2_FLAT UINT8_C(17)
#define BMI2_EXT_SENS_SYNC UINT8_C(18)
#define BMI2_WRIST_GESTURE UINT8_C(19)
#define BMI2_WRIST_WEAR_WAKE_UP UINT8_C(20)
#define BMI2_WRIST_WEAR_WAKE_UP_WH UINT8_C(21)
#define BMI2_WRIST_GESTURE_WH UINT8_C(22)
#define BMI2_PRIMARY_OIS UINT8_C(23)
#define BMI2_FREE_FALL_DET UINT8_C(24)
#define BMI2_SINGLE_TAP UINT8_C(25)
#define BMI2_DOUBLE_TAP UINT8_C(26)
#define BMI2_TRIPLE_TAP UINT8_C(27)
#define BMI2_TAP UINT8_C(28)


#define BMI2_STEP_COUNTER_PARAMS UINT8_C(29)
#define BMI2_TAP_DETECTOR_1 UINT8_C(30)
#define BMI2_TAP_DETECTOR_2 UINT8_C(31)
#define BMI2_TEMP UINT8_C(32)
#define BMI2_ACCEL_SELF_TEST UINT8_C(33)
#define BMI2_GYRO_SELF_OFF UINT8_C(34)
#define BMI2_ACTIVITY_RECOGNITION UINT8_C(35)
#define BMI2_MAX_BURST_LEN UINT8_C(36)
#define BMI2_SENS_MAX_NUM UINT8_C(37)
#define BMI2_AXIS_MAP UINT8_C(38)
#define BMI2_NVM_STATUS UINT8_C(39)
#define BMI2_VFRM_STATUS UINT8_C(40)
#define BMI2_GYRO_CROSS_SENSE UINT8_C(41)
#define BMI2_CRT_GYRO_SELF_TEST UINT8_C(42)
#define BMI2_ABORT_CRT_GYRO_SELF_TEST UINT8_C(43)
#define BMI2_NVM_PROG_PREP UINT8_C(44)
#define BMI2_ACTIVITY_RECOGNITION_SETTINGS UINT8_C(45)
#define BMI2_OIS_OUTPUT UINT8_C(46)
#define BMI2_CONFIG_ID UINT8_C(47)
#define BMI2_EXT_TCO UINT8_C(48)
#define BMI2_LPD UINT8_C(49)
#define BMI2_LAPTOP_POSITION_DETECTOR_1 UINT8_C(50)
#define BMI2_LAPTOP_POSITION_DETECTOR_2 UINT8_C(51)
#define BMI2_LAPTOP_POSITION_DETECTOR_3 UINT8_C(52)
#define BMI2_LAPTOP_POSITION_DETECTOR_4 UINT8_C(53)
#define BMI2_WRIST_GESTURE_WH_1 UINT8_C(54)
#define BMI2_WRIST_GESTURE_WH_2 UINT8_C(55)


#define BMI2_ACCEL_SENS_SEL (1)
#define BMI2_GYRO_SENS_SEL (1 << BMI2_GYRO)
#define BMI2_AUX_SENS_SEL (1 << BMI2_AUX)
#define BMI2_TEMP_SENS_SEL ((uint64_t)1 << BMI2_TEMP)
#define BMI2_ANY_MOT_SEL (1 << BMI2_ANY_MOTION)
#define BMI2_NO_MOT_SEL (1 << BMI2_NO_MOTION)
#define BMI2_TILT_SEL (1 << BMI2_TILT)
#define BMI2_ORIENT_SEL (1 << BMI2_ORIENTATION)
#define BMI2_SIG_MOTION_SEL (1 << BMI2_SIG_MOTION)
#define BMI2_STEP_DETECT_SEL (1 << BMI2_STEP_DETECTOR)
#define BMI2_STEP_COUNT_SEL (1 << BMI2_STEP_COUNTER)
#define BMI2_STEP_ACT_SEL (1 << BMI2_STEP_ACTIVITY)
#define BMI2_GYRO_GAIN_UPDATE_SEL (1 << BMI2_GYRO_GAIN_UPDATE)
#define BMI2_UP_HOLD_TO_WAKE_SEL (1 << BMI2_UP_HOLD_TO_WAKE)
#define BMI2_GLANCE_DET_SEL (1 << BMI2_GLANCE_DETECTOR)
#define BMI2_WAKE_UP_SEL (1 << BMI2_WAKE_UP)
#define BMI2_TAP_SEL (1 << BMI2_TAP)
#define BMI2_HIGH_G_SEL (1 << BMI2_HIGH_G)
#define BMI2_LOW_G_SEL (1 << BMI2_LOW_G)
#define BMI2_FLAT_SEL (1 << BMI2_FLAT)
#define BMI2_EXT_SENS_SEL (1 << BMI2_EXT_SENS_SYNC)
#define BMI2_SINGLE_TAP_SEL (1 << BMI2_SINGLE_TAP)
#define BMI2_DOUBLE_TAP_SEL (1 << BMI2_DOUBLE_TAP)
#define BMI2_TRIPLE_TAP_SEL (1 << BMI2_TRIPLE_TAP)
#define BMI2_GYRO_SELF_OFF_SEL ((uint64_t)1 << BMI2_GYRO_SELF_OFF)
#define BMI2_WRIST_GEST_SEL (1 << BMI2_WRIST_GESTURE)
#define BMI2_WRIST_WEAR_WAKE_UP_SEL (1 << BMI2_WRIST_WEAR_WAKE_UP)
#define BMI2_ACTIVITY_RECOGNITION_SEL ((uint64_t)1 << BMI2_ACTIVITY_RECOGNITION)
#define BMI2_ACCEL_SELF_TEST_SEL ((uint64_t)1 << BMI2_ACCEL_SELF_TEST)
#define BMI2_WRIST_GEST_W_SEL (1 << BMI2_WRIST_GESTURE_WH)
#define BMI2_WRIST_WEAR_WAKE_UP_WH_SEL (1 << BMI2_WRIST_WEAR_WAKE_UP_WH)
#define BMI2_PRIMARY_OIS_SEL (1 << BMI2_PRIMARY_OIS)
#define BMI2_FREE_FALL_DET_SEL (1 << BMI2_FREE_FALL_DET)
#define BMI2_EXT_TCO_SEL ((uint64_t)1 << BMI2_EXT_TCO)
#define BMI2_LPD_SEL ((uint64_t)1 << BMI2_LPD)


#define BMI2_WAKEUP_SENSITIVITY_MASK UINT8_C(0x0E)
#define BMI2_WAKEUP_SINGLE_TAP_EN_MASK UINT8_C(0x01)
#define BMI2_WAKEUP_DOUBLE_TAP_EN_MASK UINT8_C(0x02)
#define BMI2_WAKEUP_TRIPLE_TAP_EN_MASK UINT8_C(0x04)
#define BMI2_WAKEUP_DATA_REG_EN_MASK UINT8_C(0x08)
#define BMI2_WAKEUP_AXIS_SEL_MASK UINT8_C(0x03)


#define BMI2_WAKEUP_SENSITIVITY_POS UINT8_C(0x01)
#define BMI2_WAKEUP_DOUBLE_TAP_EN_POS UINT8_C(0x01)
#define BMI2_WAKEUP_TRIPLE_TAP_EN_POS UINT8_C(0x02)
#define BMI2_WAKEUP_DATA_REG_EN_POS UINT8_C(0x03)


#define BMI2_TAP_SENSITIVITY_MASK UINT8_C(0x0E)
#define BMI2_TAP_SINGLE_TAP_EN_MASK UINT8_C(0x01)
#define BMI2_TAP_DOUBLE_TAP_EN_MASK UINT8_C(0x02)
#define BMI2_TAP_TRIPLE_TAP_EN_MASK UINT8_C(0x04)
#define BMI2_TAP_DATA_REG_EN_MASK UINT8_C(0x08)
#define BMI2_TAP_AXIS_SEL_MASK UINT8_C(0x03)


#define BMI2_TAP_SENSITIVITY_POS UINT8_C(0x01)
#define BMI2_TAP_DOUBLE_TAP_EN_POS UINT8_C(0x01)
#define BMI2_TAP_TRIPLE_TAP_EN_POS UINT8_C(0x02)
#define BMI2_TAP_DATA_REG_EN_POS UINT8_C(0x03)


#define BMI2_WAKE_UP_SENSITIVITY_MASK UINT16_C(0x000E)
#define BMI2_WAKE_UP_SINGLE_TAP_EN_MASK UINT16_C(0x0010)


#define BMI2_WAKE_UP_SENSITIVITY_POS UINT8_C(0x01)
#define BMI2_WAKE_UP_SINGLE_TAP_EN_POS UINT8_C(0x04)


#define BMI2_ANY_MOT_FEAT_EN_OFFSET UINT8_C(0x03)
#define BMI2_NO_MOT_FEAT_EN_OFFSET UINT8_C(0x03)
#define BMI2_SIG_MOT_FEAT_EN_OFFSET UINT8_C(0x0A)
#define BMI2_STEP_COUNT_FEAT_EN_OFFSET UINT8_C(0x01)
#define BMI2_GYR_USER_GAIN_FEAT_EN_OFFSET UINT8_C(0x05)
#define BMI2_HIGH_G_FEAT_EN_OFFSET UINT8_C(0x03)
#define BMI2_LOW_G_FEAT_EN_OFFSET UINT8_C(0x03)
#define BMI2_TILT_FEAT_EN_OFFSET UINT8_C(0x00)


#define BMI2_ANY_NO_MOT_EN_MASK UINT8_C(0x80)
#define BMI2_TILT_FEAT_EN_MASK UINT8_C(0x01)
#define BMI2_ORIENT_FEAT_EN_MASK UINT8_C(0x01)
#define BMI2_SIG_MOT_FEAT_EN_MASK UINT8_C(0x01)
#define BMI2_STEP_DET_FEAT_EN_MASK UINT8_C(0x08)
#define BMI2_STEP_COUNT_FEAT_EN_MASK UINT8_C(0x10)
#define BMI2_STEP_ACT_FEAT_EN_MASK UINT8_C(0x20)
#define BMI2_GYR_USER_GAIN_FEAT_EN_MASK UINT8_C(0x08)
#define BMI2_UP_HOLD_TO_WAKE_FEAT_EN_MASK UINT8_C(0x01)
#define BMI2_GLANCE_FEAT_EN_MASK UINT8_C(0x01)
#define BMI2_WAKE_UP_FEAT_EN_MASK UINT8_C(0x01)
#define BMI2_TAP_FEAT_EN_MASK UINT8_C(0x01)
#define BMI2_HIGH_G_FEAT_EN_MASK UINT8_C(0x80)
#define BMI2_LOW_G_FEAT_EN_MASK UINT8_C(0x10)
#define BMI2_FLAT_FEAT_EN_MASK UINT8_C(0x01)
#define BMI2_EXT_SENS_SYNC_FEAT_EN_MASK UINT8_C(0x01)
#define BMI2_GYR_SELF_OFF_CORR_FEAT_EN_MASK UINT8_C(0x02)
#define BMI2_WRIST_GEST_FEAT_EN_MASK UINT8_C(0x20)
#define BMI2_WRIST_WEAR_WAKE_UP_FEAT_EN_MASK UINT8_C(0x10)
#define BMI2_ACTIVITY_RECOG_EN_MASK UINT8_C(0x01)
#define BMI2_ACC_SELF_TEST_FEAT_EN_MASK UINT8_C(0x02)
#define BMI2_GYRO_SELF_TEST_CRT_EN_MASK UINT8_C(0x01)
#define BMI2_ABORT_FEATURE_EN_MASK UINT8_C(0x02)
#define BMI2_NVM_PREP_FEATURE_EN_MASK UINT8_C(0x04)
#define BMI2_FREE_FALL_DET_FEAT_EN_MASK UINT8_C(0x01)
#define BMI2_WRIST_GEST_WH_FEAT_EN_MASK UINT8_C(0x02)


#define BMI2_ANY_NO_MOT_EN_POS UINT8_C(0x07)
#define BMI2_STEP_DET_FEAT_EN_POS UINT8_C(0x03)
#define BMI2_STEP_COUNT_FEAT_EN_POS UINT8_C(0x04)
#define BMI2_STEP_ACT_FEAT_EN_POS UINT8_C(0x05)
#define BMI2_GYR_USER_GAIN_FEAT_EN_POS UINT8_C(0x03)
#define BMI2_HIGH_G_FEAT_EN_POS UINT8_C(0x07)
#define BMI2_LOW_G_FEAT_EN_POS UINT8_C(0x04)
#define BMI2_GYR_SELF_OFF_CORR_FEAT_EN_POS UINT8_C(0x01)
#define BMI2_WRIST_GEST_FEAT_EN_POS UINT8_C(0x05)
#define BMI2_WRIST_WEAR_WAKE_UP_FEAT_EN_POS UINT8_C(0x04)
#define BMI2_ACC_SELF_TEST_FEAT_EN_POS UINT8_C(0x01)
#define BMI2_ABORT_FEATURE_EN_POS UINT8_C(0x1)
#define BMI2_NVM_PREP_FEATURE_EN_POS UINT8_C(0x02)
#define BMI2_WRIST_GEST_WH_FEAT_EN_POS UINT8_C(0x01)


#define BMI2_LP_FILTER_EN_MASK UINT8_C(0x01)

#define BMI2_LP_FILTER_CONFIG_POS UINT8_C(0x01)
#define BMI2_LP_FILTER_CONFIG_MASK UINT8_C(0x06)

#define BMI2_PRIMARY_OIS_GYR_EN_POS UINT8_C(0x06)
#define BMI2_PRIMARY_OIS_GYR_EN_MASK UINT8_C(0x40)

#define BMI2_PRIMARY_OIS_ACC_EN_POS UINT8_C(0x07)
#define BMI2_PRIMARY_OIS_ACC_EN_MASK UINT8_C(0x80)


#define BMI2_ANY_NO_MOT_DUR_MASK UINT16_C(0x1FFF)
#define BMI2_ANY_NO_MOT_X_SEL_MASK UINT16_C(0x2000)
#define BMI2_ANY_NO_MOT_Y_SEL_MASK UINT16_C(0x4000)
#define BMI2_ANY_NO_MOT_Z_SEL_MASK UINT16_C(0x8000)
#define BMI2_ANY_NO_MOT_THRES_MASK UINT16_C(0x07FF)
#define BMI2_ANY_MOT_INT_MASK UINT8_C(0x40)


#define BMI2_NO_MOT_INT_MASK UINT8_C(0x20)




#define BMI2_ANY_NO_MOT_X_SEL_POS UINT8_C(0x0D)
#define BMI2_ANY_NO_MOT_Y_SEL_POS UINT8_C(0x0E)
#define BMI2_ANY_NO_MOT_Z_SEL_POS UINT8_C(0x0F)


#define BMI2_ORIENT_UP_DOWN_MASK UINT16_C(0x0002)
#define BMI2_ORIENT_SYMM_MODE_MASK UINT16_C(0x000C)
#define BMI2_ORIENT_BLOCK_MODE_MASK UINT16_C(0x0030)
#define BMI2_ORIENT_THETA_MASK UINT16_C(0x0FC0)
#define BMI2_ORIENT_HYST_MASK UINT16_C(0x07FF)


#define BMI2_ORIENT_UP_DOWN_POS UINT8_C(0x01)
#define BMI2_ORIENT_SYMM_MODE_POS UINT8_C(0x02)
#define BMI2_ORIENT_BLOCK_MODE_POS UINT8_C(0x04)
#define BMI2_ORIENT_THETA_POS UINT8_C(0x06)


#define BMI2_SIG_MOT_PARAM_1_MASK UINT16_C(0xFFFF)
#define BMI2_SIG_MOT_PARAM_2_MASK UINT16_C(0xFFFF)
#define BMI2_SIG_MOT_PARAM_3_MASK UINT16_C(0xFFFF)
#define BMI2_SIG_MOT_PARAM_4_MASK UINT16_C(0xFFFF)
#define BMI2_SIG_MOT_PARAM_5_MASK UINT16_C(0xFFFF)


#define BMI2_STEP_COUNT_PARAMS_MASK UINT16_C(0xFFFF)


#define BMI2_STEP_COUNT_WM_LEVEL_MASK UINT16_C(0x03FF)
#define BMI2_STEP_COUNT_RST_CNT_MASK UINT16_C(0x0400)
#define BMI2_STEP_BUFFER_SIZE_MASK UINT16_C(0xFF00)
#define BMI2_STEP_COUNT_INT_MASK UINT8_C(0x02)
#define BMI2_STEP_ACT_INT_MASK UINT8_C(0x04)




#define BMI2_STEP_COUNT_RST_CNT_POS UINT8_C(0x0A)
#define BMI2_STEP_BUFFER_SIZE_POS UINT8_C(0x08)




#define BMI2_GYR_USER_GAIN_RATIO_X_MASK UINT16_C(0x07FF)
#define BMI2_GYR_USER_GAIN_RATIO_Y_MASK UINT16_C(0x07FF)
#define BMI2_GYR_USER_GAIN_RATIO_Z_MASK UINT16_C(0x07FF)


#define BMI2_GYR_USER_GAIN_SAT_STAT_X_MASK UINT8_C(0x01)
#define BMI2_GYR_USER_GAIN_SAT_STAT_Y_MASK UINT8_C(0x02)
#define BMI2_GYR_USER_GAIN_SAT_STAT_Z_MASK UINT8_C(0x04)
#define BMI2_G_TRIGGER_STAT_MASK UINT8_C(0x38)


#define BMI2_GYR_USER_GAIN_SAT_STAT_Y_POS UINT8_C(0x01)
#define BMI2_GYR_USER_GAIN_SAT_STAT_Z_POS UINT8_C(0x02)
#define BMI2_G_TRIGGER_STAT_POS UINT8_C(0x03)


#define BMI2_GYR_OFF_COMP_MSB_X_MASK UINT8_C(0x03)
#define BMI2_GYR_OFF_COMP_MSB_Y_MASK UINT8_C(0x0C)
#define BMI2_GYR_OFF_COMP_MSB_Z_MASK UINT8_C(0x30)


#define BMI2_GYR_OFF_COMP_MSB_Y_POS UINT8_C(0x02)
#define BMI2_GYR_OFF_COMP_MSB_Z_POS UINT8_C(0x04)


#define BMI2_GYR_OFF_COMP_MSB_MASK UINT16_C(0x0300)
#define BMI2_GYR_OFF_COMP_LSB_MASK UINT16_C(0x00FF)


#define BMI2_ORIENT_DETECT_MASK UINT8_C(0x03)
#define BMI2_ORIENT_FACE_UP_DWN_MASK UINT8_C(0x04)


#define BMI2_ORIENT_FACE_UP_DWN_POS UINT8_C(0x02)


#define BMI2_NVM_LOAD_ERR_STATUS_MASK UINT8_C(0x01)
#define BMI2_NVM_PROG_ERR_STATUS_MASK UINT8_C(0x02)
#define BMI2_NVM_ERASE_ERR_STATUS_MASK UINT8_C(0x04)
#define BMI2_NVM_END_EXCEED_STATUS_MASK UINT8_C(0x08)
#define BMI2_NVM_PRIV_ERR_STATUS_MASK UINT8_C(0x10)
#define BMI2_VFRM_LOCK_ERR_STATUS_MASK UINT8_C(0x20)
#define BMI2_VFRM_WRITE_ERR_STATUS_MASK UINT8_C(0x40)
#define BMI2_VFRM_FATAL_ERR_STATUS_MASK UINT8_C(0x80)


#define BMI2_NVM_PROG_ERR_STATUS_POS UINT8_C(0x01)
#define BMI2_NVM_ERASE_ERR_STATUS_POS UINT8_C(0x02)
#define BMI2_NVM_END_EXCEED_STATUS_POS UINT8_C(0x03)
#define BMI2_NVM_PRIV_ERR_STATUS_POS UINT8_C(0x04)
#define BMI2_VFRM_LOCK_ERR_STATUS_POS UINT8_C(0x05)
#define BMI2_VFRM_WRITE_ERR_STATUS_POS UINT8_C(0x06)
#define BMI2_VFRM_FATAL_ERR_STATUS_POS UINT8_C(0x07)


#define BMI2_ACC_SELF_TEST_DONE_MASK UINT8_C(0x01)
#define BMI2_ACC_X_OK_MASK UINT8_C(0x02)
#define BMI2_ACC_Y_OK_MASK UINT8_C(0x04)
#define BMI2_ACC_Z_OK_MASK UINT8_C(0x08)


#define BMI2_ACC_X_OK_POS UINT8_C(0x01)
#define BMI2_ACC_Y_OK_POS UINT8_C(0x02)
#define BMI2_ACC_Z_OK_POS UINT8_C(0x03)


#define BMI2_HIGH_G_THRES_MASK UINT16_C(0x7FFF)
#define BMI2_HIGH_G_HYST_MASK UINT16_C(0x0FFF)
#define BMI2_HIGH_G_X_SEL_MASK UINT16_C(0x1000)
#define BMI2_HIGH_G_Y_SEL_MASK UINT16_C(0x2000)
#define BMI2_HIGH_G_Z_SEL_MASK UINT16_C(0x4000)
#define BMI2_HIGH_G_DUR_MASK UINT16_C(0x0FFF)


#define BMI2_HIGH_G_X_SEL_POS UINT8_C(0x0C)
#define BMI2_HIGH_G_Y_SEL_POS UINT8_C(0x0D)
#define BMI2_HIGH_G_Z_SEL_POS UINT8_C(0x0E)


#define BMI2_LOW_G_THRES_MASK UINT16_C(0x7FFF)
#define BMI2_LOW_G_HYST_MASK UINT16_C(0x0FFF)
#define BMI2_LOW_G_DUR_MASK UINT16_C(0x0FFF)


#define BMI2_FREE_FALL_ACCEL_SETT_MASK UINT16_C(0xFFFF)


#define BMI2_FLAT_THETA_MASK UINT16_C(0x007E)
#define BMI2_FLAT_BLOCK_MASK UINT16_C(0x0180)
#define BMI2_FLAT_HYST_MASK UINT16_C(0x003F)
#define BMI2_FLAT_HOLD_TIME_MASK UINT16_C(0x3FC0)


#define BMI2_FLAT_THETA_POS UINT8_C(0x01)
#define BMI2_FLAT_BLOCK_POS UINT8_C(0x07)
#define BMI2_FLAT_HOLD_TIME_POS UINT8_C(0x06)


#define BMI2_WRIST_GEST_WEAR_ARM_MASK UINT16_C(0x0010)


#define BMI2_WRIST_GEST_WEAR_ARM_POS UINT8_C(0x04)


#define BMI2_WRIST_GEST_WH_DEVICE_POS_MASK UINT16_C(0x0001)
#define BMI2_WRIST_GEST_WH_INT UINT8_C(0x10)
#define BMI2_WRIST_GEST_WH_START_ADD UINT8_C(0x08)


#define BMI2_WRIST_WAKE_UP_WH_INT_MASK UINT8_C(0x08)


#define BMI2_WRIST_WAKE_UP_ANGLE_LR_MASK UINT16_C(0x00FF)
#define BMI2_WRIST_WAKE_UP_ANGLE_LL_MASK UINT16_C(0xFF00)
#define BMI2_WRIST_WAKE_UP_ANGLE_PD_MASK UINT16_C(0x00FF)
#define BMI2_WRIST_WAKE_UP_ANGLE_PU_MASK UINT16_C(0xFF00)
#define BMI2_WRIST_WAKE_UP_MIN_DUR_MOVED_MASK UINT16_C(0x00FF)
#define BMI2_WRIST_WAKE_UP_MIN_DUR_QUITE_MASK UINT16_C(0xFF00)


#define BMI2_WRIST_WAKE_UP_ANGLE_LL_POS UINT16_C(0x0008)
#define BMI2_WRIST_WAKE_UP_ANGLE_PU_POS UINT16_C(0x0008)
#define BMI2_WRIST_WAKE_UP_MIN_DUR_QUITE_POS UINT16_C(0x0008)


#define BMI2_EXT_TCO_MASK UINT8_C(0x01)




#define BMI2_MAP_X_AXIS UINT8_C(0x00)
#define BMI2_MAP_Y_AXIS UINT8_C(0x01)
#define BMI2_MAP_Z_AXIS UINT8_C(0x02)
#define BMI2_MAP_POSITIVE UINT8_C(0x00)
#define BMI2_MAP_NEGATIVE UINT8_C(0x01)


#define BMI2_X_AXIS_MASK UINT8_C(0x03)
#define BMI2_X_AXIS_SIGN_MASK UINT8_C(0x04)
#define BMI2_Y_AXIS_MASK UINT8_C(0x18)
#define BMI2_Y_AXIS_SIGN_MASK UINT8_C(0x20)
#define BMI2_Z_AXIS_MASK UINT8_C(0xC0)
#define BMI2_Z_AXIS_SIGN_MASK UINT8_C(0x01)


#define BMI2_X_AXIS_SIGN_POS UINT8_C(0x02)
#define BMI2_Y_AXIS_POS UINT8_C(0x03)
#define BMI2_Y_AXIS_SIGN_POS UINT8_C(0x05)
#define BMI2_Z_AXIS_POS UINT8_C(0x06)


#define BMI2_NEG_SIGN UINT8_C(1)
#define BMI2_POS_SIGN UINT8_C(0)


#define BMI2_CRT_READY_FOR_DOWNLOAD_US UINT16_C(2000)
#define BMI2_CRT_READY_FOR_DOWNLOAD_RETRY UINT8_C(100)

#define BMI2_CRT_WAIT_RUNNING_US UINT16_C(10000)
#define BMI2_CRT_WAIT_RUNNING_RETRY_EXECUTION UINT8_C(200)

#define BMI2_CRT_MIN_BURST_WORD_LENGTH UINT8_C(2)
#define BMI2_CRT_MAX_BURST_WORD_LENGTH UINT16_C(255)
# 837 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\applications/bmi270/bmi2_defs.h"
#define BMI2_GYRO_FOC_2000_DPS_REF UINT16_C(16)
#define BMI2_GYRO_FOC_1000_DPS_REF UINT16_C(33)
#define BMI2_GYRO_FOC_500_DPS_REF UINT16_C(66)
#define BMI2_GYRO_FOC_250_DPS_REF UINT16_C(131)
#define BMI2_GYRO_FOC_125_DPS_REF UINT16_C(262)
# 853 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\applications/bmi270/bmi2_defs.h"
#define BMI2_ACC_FOC_2G_REF UINT16_C(16384)
#define BMI2_ACC_FOC_4G_REF UINT16_C(8192)
#define BMI2_ACC_FOC_8G_REF UINT16_C(4096)
#define BMI2_ACC_FOC_16G_REF UINT16_C(2048)

#define BMI2_ACC_FOC_2G_OFFSET UINT16_C(328)
#define BMI2_ACC_FOC_4G_OFFSET UINT16_C(164)
#define BMI2_ACC_FOC_8G_OFFSET UINT16_C(82)
#define BMI2_ACC_FOC_16G_OFFSET UINT16_C(41)

#define BMI2_ACC_2G_MAX_NOISE_LIMIT (BMI2_ACC_FOC_2G_REF + BMI2_ACC_FOC_2G_OFFSET)
#define BMI2_ACC_2G_MIN_NOISE_LIMIT (BMI2_ACC_FOC_2G_REF - BMI2_ACC_FOC_2G_OFFSET)
#define BMI2_ACC_4G_MAX_NOISE_LIMIT (BMI2_ACC_FOC_4G_REF + BMI2_ACC_FOC_4G_OFFSET)
#define BMI2_ACC_4G_MIN_NOISE_LIMIT (BMI2_ACC_FOC_4G_REF - BMI2_ACC_FOC_4G_OFFSET)
#define BMI2_ACC_8G_MAX_NOISE_LIMIT (BMI2_ACC_FOC_8G_REF + BMI2_ACC_FOC_8G_OFFSET)
#define BMI2_ACC_8G_MIN_NOISE_LIMIT (BMI2_ACC_FOC_8G_REF - BMI2_ACC_FOC_8G_OFFSET)
#define BMI2_ACC_16G_MAX_NOISE_LIMIT (BMI2_ACC_FOC_16G_REF + BMI2_ACC_FOC_16G_OFFSET)
#define BMI2_ACC_16G_MIN_NOISE_LIMIT (BMI2_ACC_FOC_16G_REF - BMI2_ACC_FOC_16G_OFFSET)

#define BMI2_FOC_SAMPLE_LIMIT UINT8_C(128)


#define BMI2_MAIN_SENSORS (BMI2_ACCEL_SENS_SEL | BMI2_GYRO_SENS_SEL | BMI2_AUX_SENS_SEL | BMI2_TEMP_SENS_SEL)




#define BMI2_MAIN_SENS_MAX_NUM UINT8_C(4)


#define BMI2_STEP_CNT_N_PARAMS UINT8_C(25)


#define BMI2_FREE_FALL_ACCEL_SET_PARAMS UINT8_C(7)

#define BMI2_SELECT_GYRO_SELF_TEST UINT8_C(0)
#define BMI2_SELECT_CRT UINT8_C(1)


#define BMI2_NVM_UNLOCK_ENABLE UINT8_C(0x02)
#define BMI2_NVM_UNLOCK_DISABLE UINT8_C(0x00)


#define BMI2_GYRO_SELF_TEST_SEL UINT8_C(0)
#define BMI2_CRT_SEL UINT8_C(1)





#define BMI2_ACC_OSR4_AVG1 UINT8_C(0x00)
#define BMI2_ACC_OSR2_AVG2 UINT8_C(0x01)
#define BMI2_ACC_NORMAL_AVG4 UINT8_C(0x02)
#define BMI2_ACC_CIC_AVG8 UINT8_C(0x03)
#define BMI2_ACC_RES_AVG16 UINT8_C(0x04)
#define BMI2_ACC_RES_AVG32 UINT8_C(0x05)
#define BMI2_ACC_RES_AVG64 UINT8_C(0x06)
#define BMI2_ACC_RES_AVG128 UINT8_C(0x07)


#define BMI2_ACC_ODR_0_78HZ UINT8_C(0x01)
#define BMI2_ACC_ODR_1_56HZ UINT8_C(0x02)
#define BMI2_ACC_ODR_3_12HZ UINT8_C(0x03)
#define BMI2_ACC_ODR_6_25HZ UINT8_C(0x04)
#define BMI2_ACC_ODR_12_5HZ UINT8_C(0x05)
#define BMI2_ACC_ODR_25HZ UINT8_C(0x06)
#define BMI2_ACC_ODR_50HZ UINT8_C(0x07)
#define BMI2_ACC_ODR_100HZ UINT8_C(0x08)
#define BMI2_ACC_ODR_200HZ UINT8_C(0x09)
#define BMI2_ACC_ODR_400HZ UINT8_C(0x0A)
#define BMI2_ACC_ODR_800HZ UINT8_C(0x0B)
#define BMI2_ACC_ODR_1600HZ UINT8_C(0x0C)


#define BMI2_ACC_RANGE_2G UINT8_C(0x00)
#define BMI2_ACC_RANGE_4G UINT8_C(0x01)
#define BMI2_ACC_RANGE_8G UINT8_C(0x02)
#define BMI2_ACC_RANGE_16G UINT8_C(0x03)


#define BMI2_ACC_RANGE_MASK UINT8_C(0x03)
#define BMI2_ACC_ODR_MASK UINT8_C(0x0F)
#define BMI2_ACC_BW_PARAM_MASK UINT8_C(0x70)
#define BMI2_ACC_FILTER_PERF_MODE_MASK UINT8_C(0x80)


#define BMI2_ACC_BW_PARAM_POS UINT8_C(0x04)
#define BMI2_ACC_FILTER_PERF_MODE_POS UINT8_C(0x07)


#define BMI2_ACC_SELF_TEST_RANGE UINT8_C(16)




#define BMI2_ST_ACC_X_SIG_MIN_DIFF INT16_C(16000)
#define BMI2_ST_ACC_Y_SIG_MIN_DIFF INT16_C(-15000)
#define BMI2_ST_ACC_Z_SIG_MIN_DIFF INT16_C(10000)


#define BMI2_ACC_SELF_TEST_EN_MASK UINT8_C(0x01)
#define BMI2_ACC_SELF_TEST_SIGN_MASK UINT8_C(0x04)
#define BMI2_ACC_SELF_TEST_AMP_MASK UINT8_C(0x08)


#define BMI2_ACC_SELF_TEST_SIGN_POS UINT8_C(0x02)
#define BMI2_ACC_SELF_TEST_AMP_POS UINT8_C(0x03)


#define BMI2_GYR_ST_AXES_DONE_MASK UINT8_C(0x01)
#define BMI2_GYR_AXIS_X_OK_MASK UINT8_C(0x02)
#define BMI2_GYR_AXIS_Y_OK_MASK UINT8_C(0x04)
#define BMI2_GYR_AXIS_Z_OK_MASK UINT8_C(0x08)


#define BMI2_GYR_AXIS_X_OK_POS UINT8_C(0x01)
#define BMI2_GYR_AXIS_Y_OK_POS UINT8_C(0x02)
#define BMI2_GYR_AXIS_Z_OK_POS UINT8_C(0x03)





#define BMI2_GYR_OSR4_MODE UINT8_C(0x00)
#define BMI2_GYR_OSR2_MODE UINT8_C(0x01)
#define BMI2_GYR_NORMAL_MODE UINT8_C(0x02)
#define BMI2_GYR_CIC_MODE UINT8_C(0x03)


#define BMI2_GYR_ODR_25HZ UINT8_C(0x06)
#define BMI2_GYR_ODR_50HZ UINT8_C(0x07)
#define BMI2_GYR_ODR_100HZ UINT8_C(0x08)
#define BMI2_GYR_ODR_200HZ UINT8_C(0x09)
#define BMI2_GYR_ODR_400HZ UINT8_C(0x0A)
#define BMI2_GYR_ODR_800HZ UINT8_C(0x0B)
#define BMI2_GYR_ODR_1600HZ UINT8_C(0x0C)
#define BMI2_GYR_ODR_3200HZ UINT8_C(0x0D)


#define BMI2_GYR_OIS_250 UINT8_C(0x00)
#define BMI2_GYR_OIS_2000 UINT8_C(0x01)


#define BMI2_GYR_RANGE_2000 UINT8_C(0x00)
#define BMI2_GYR_RANGE_1000 UINT8_C(0x01)
#define BMI2_GYR_RANGE_500 UINT8_C(0x02)
#define BMI2_GYR_RANGE_250 UINT8_C(0x03)
#define BMI2_GYR_RANGE_125 UINT8_C(0x04)


#define BMI2_GYR_RANGE_MASK UINT8_C(0x07)
#define BMI2_GYR_OIS_RANGE_MASK UINT8_C(0x08)
#define BMI2_GYR_ODR_MASK UINT8_C(0x0F)
#define BMI2_GYR_BW_PARAM_MASK UINT8_C(0x30)
#define BMI2_GYR_NOISE_PERF_MODE_MASK UINT8_C(0x40)
#define BMI2_GYR_FILTER_PERF_MODE_MASK UINT8_C(0x80)


#define BMI2_GYR_OIS_RANGE_POS UINT8_C(0x03)
#define BMI2_GYR_BW_PARAM_POS UINT8_C(0x04)
#define BMI2_GYR_NOISE_PERF_MODE_POS UINT8_C(0x06)
#define BMI2_GYR_FILTER_PERF_MODE_POS UINT8_C(0x07)





#define BMI2_AUX_ODR_RESERVED UINT8_C(0x00)
#define BMI2_AUX_ODR_0_78HZ UINT8_C(0x01)
#define BMI2_AUX_ODR_1_56HZ UINT8_C(0x02)
#define BMI2_AUX_ODR_3_12HZ UINT8_C(0x03)
#define BMI2_AUX_ODR_6_25HZ UINT8_C(0x04)
#define BMI2_AUX_ODR_12_5HZ UINT8_C(0x05)
#define BMI2_AUX_ODR_25HZ UINT8_C(0x06)
#define BMI2_AUX_ODR_50HZ UINT8_C(0x07)
#define BMI2_AUX_ODR_100HZ UINT8_C(0x08)
#define BMI2_AUX_ODR_200HZ UINT8_C(0x09)
#define BMI2_AUX_ODR_400HZ UINT8_C(0x0A)
#define BMI2_AUX_ODR_800HZ UINT8_C(0x0B)


#define BMI2_AUX_READ_LEN_0 UINT8_C(0x00)
#define BMI2_AUX_READ_LEN_1 UINT8_C(0x01)
#define BMI2_AUX_READ_LEN_2 UINT8_C(0x02)
#define BMI2_AUX_READ_LEN_3 UINT8_C(0x03)


#define BMI2_AUX_SET_I2C_ADDR_MASK UINT8_C(0xFE)
#define BMI2_AUX_MAN_MODE_EN_MASK UINT8_C(0x80)
#define BMI2_AUX_FCU_WR_EN_MASK UINT8_C(0x40)
#define BMI2_AUX_MAN_READ_BURST_MASK UINT8_C(0x0C)
#define BMI2_AUX_READ_BURST_MASK UINT8_C(0x03)
#define BMI2_AUX_ODR_EN_MASK UINT8_C(0x0F)
#define BMI2_AUX_OFFSET_READ_OUT_MASK UINT8_C(0xF0)


#define BMI2_AUX_SET_I2C_ADDR_POS UINT8_C(0x01)
#define BMI2_AUX_MAN_MODE_EN_POS UINT8_C(0x07)
#define BMI2_AUX_FCU_WR_EN_POS UINT8_C(0x06)
#define BMI2_AUX_MAN_READ_BURST_POS UINT8_C(0x02)
#define BMI2_AUX_OFFSET_READ_OUT_POS UINT8_C(0x04)





#define BMI2_FIFO_VIRT_FRM_MODE UINT8_C(0x03)


#define BMI2_FIFO_HEADER_ACC_FRM UINT8_C(0x84)
#define BMI2_FIFO_HEADER_AUX_FRM UINT8_C(0x90)
#define BMI2_FIFO_HEADER_GYR_FRM UINT8_C(0x88)
#define BMI2_FIFO_HEADER_GYR_ACC_FRM UINT8_C(0x8C)
#define BMI2_FIFO_HEADER_AUX_ACC_FRM UINT8_C(0x94)
#define BMI2_FIFO_HEADER_AUX_GYR_FRM UINT8_C(0x98)
#define BMI2_FIFO_HEADER_ALL_FRM UINT8_C(0x9C)
#define BMI2_FIFO_HEADER_SENS_TIME_FRM UINT8_C(0x44)
#define BMI2_FIFO_HEADER_SKIP_FRM UINT8_C(0x40)
#define BMI2_FIFO_HEADER_INPUT_CFG_FRM UINT8_C(0x48)
#define BMI2_FIFO_HEAD_OVER_READ_MSB UINT8_C(0x80)
#define BMI2_FIFO_VIRT_ACT_RECOG_FRM UINT8_C(0xC8)


#define BMI2_FIFO_HEAD_LESS_ACC_FRM UINT8_C(0x40)
#define BMI2_FIFO_HEAD_LESS_AUX_FRM UINT8_C(0x20)
#define BMI2_FIFO_HEAD_LESS_GYR_FRM UINT8_C(0x80)
#define BMI2_FIFO_HEAD_LESS_GYR_AUX_FRM UINT8_C(0xA0)
#define BMI2_FIFO_HEAD_LESS_GYR_ACC_FRM UINT8_C(0xC0)
#define BMI2_FIFO_HEAD_LESS_AUX_ACC_FRM UINT8_C(0x60)
#define BMI2_FIFO_HEAD_LESS_ALL_FRM UINT8_C(0xE0)


#define BMI2_FIFO_STOP_ON_FULL UINT16_C(0x0001)
#define BMI2_FIFO_TIME_EN UINT16_C(0x0002)
#define BMI2_FIFO_TAG_INT1 UINT16_C(0x0300)
#define BMI2_FIFO_TAG_INT2 UINT16_C(0x0C00)
#define BMI2_FIFO_HEADER_EN UINT16_C(0x1000)
#define BMI2_FIFO_AUX_EN UINT16_C(0x2000)
#define BMI2_FIFO_ACC_EN UINT16_C(0x4000)
#define BMI2_FIFO_GYR_EN UINT16_C(0x8000)
#define BMI2_FIFO_ALL_EN UINT16_C(0xE000)


#define BMI2_SENSORTIME_RESOLUTION 0.0000390625f


#define BMI2_FIFO_ACC_LENGTH UINT8_C(6)
#define BMI2_FIFO_GYR_LENGTH UINT8_C(6)
#define BMI2_FIFO_AUX_LENGTH UINT8_C(8)
#define BMI2_FIFO_ACC_AUX_LENGTH UINT8_C(14)
#define BMI2_FIFO_GYR_AUX_LENGTH UINT8_C(14)
#define BMI2_FIFO_ACC_GYR_LENGTH UINT8_C(12)
#define BMI2_FIFO_ALL_LENGTH UINT8_C(20)
#define BMI2_SENSOR_TIME_LENGTH UINT8_C(3)
#define BMI2_FIFO_CONFIG_LENGTH UINT8_C(2)
#define BMI2_FIFO_WM_LENGTH UINT8_C(2)
#define BMI2_MAX_VALUE_FIFO_FILTER UINT8_C(1)
#define BMI2_FIFO_DATA_LENGTH UINT8_C(2)
#define BMI2_FIFO_LENGTH_MSB_BYTE UINT8_C(1)
#define BMI2_FIFO_INPUT_CFG_LENGTH UINT8_C(4)
#define BMI2_FIFO_SKIP_FRM_LENGTH UINT8_C(1)


#define BMI2_FIFO_VIRT_ACC_LENGTH UINT8_C(9)
#define BMI2_FIFO_VIRT_GYR_LENGTH UINT8_C(9)
#define BMI2_FIFO_VIRT_AUX_LENGTH UINT8_C(11)
#define BMI2_FIFO_VIRT_ACC_AUX_LENGTH UINT8_C(17)
#define BMI2_FIFO_VIRT_GYR_AUX_LENGTH UINT8_C(17)
#define BMI2_FIFO_VIRT_ACC_GYR_LENGTH UINT8_C(15)
#define BMI2_FIFO_VIRT_ALL_LENGTH UINT8_C(23)


#define BMI2_FIFO_VIRT_ACT_DATA_LENGTH UINT8_C(6)
#define BMI2_FIFO_VIRT_ACT_TIME_LENGTH UINT8_C(4)
#define BMI2_FIFO_VIRT_ACT_TYPE_LENGTH UINT8_C(1)
#define BMI2_FIFO_VIRT_ACT_STAT_LENGTH UINT8_C(1)


#define BMI2_FIFO_UNFILTERED_DATA UINT8_C(0)
#define BMI2_FIFO_FILTERED_DATA UINT8_C(1)


#define BMI2_FIFO_LSB_CONFIG_CHECK UINT8_C(0x00)
#define BMI2_FIFO_MSB_CONFIG_CHECK UINT8_C(0x80)
#define BMI2_FIFO_TAG_INTR_MASK UINT8_C(0xFF)


#define BMI2_FIFO_CONFIG_0_MASK UINT16_C(0x0003)
#define BMI2_FIFO_CONFIG_1_MASK UINT16_C(0xFF00)


#define BMI2_FIFO_SELF_WAKE_UP_MASK UINT8_C(0x02)


#define BMI2_ACC_FIFO_DOWNS_MASK UINT8_C(0x70)
#define BMI2_GYR_FIFO_DOWNS_MASK UINT8_C(0x07)


#define BMI2_ACC_FIFO_DOWNS_POS UINT8_C(0x04)


#define BMI2_ACC_FIFO_FILT_DATA_MASK UINT8_C(0x80)
#define BMI2_GYR_FIFO_FILT_DATA_MASK UINT8_C(0x08)


#define BMI2_ACC_FIFO_FILT_DATA_POS UINT8_C(0x07)
#define BMI2_GYR_FIFO_FILT_DATA_POS UINT8_C(0x03)


#define BMI2_FIFO_BYTE_COUNTER_MSB_MASK UINT8_C(0x3F)


#define BMI2_FIFO_SELF_WAKE_UP_POS UINT8_C(0x01)


#define BMI2_FIFO_VIRT_FRM_MODE_MASK UINT8_C(0xC0)
#define BMI2_FIFO_VIRT_PAYLOAD_MASK UINT8_C(0x3C)


#define BMI2_FIFO_VIRT_FRM_MODE_POS UINT8_C(0x06)
#define BMI2_FIFO_VIRT_PAYLOAD_POS UINT8_C(0x02)






#define BMI2_INT_NON_LATCH UINT8_C(0)


#define BMI2_INT_LATCH UINT8_C(1)


#define BMI2_INT_PUSH_PULL UINT8_C(0)
#define BMI2_INT_OPEN_DRAIN UINT8_C(1)


#define BMI2_INT_ACTIVE_LOW UINT8_C(0)
#define BMI2_INT_ACTIVE_HIGH UINT8_C(1)


#define BMI2_INT_OUTPUT_DISABLE UINT8_C(0)
#define BMI2_INT_OUTPUT_ENABLE UINT8_C(1)


#define BMI2_INT_INPUT_DISABLE UINT8_C(0)
#define BMI2_INT_INPUT_ENABLE UINT8_C(1)


#define BMI2_INT_LATCH_MASK UINT8_C(0x01)
#define BMI2_INT_LEVEL_MASK UINT8_C(0x02)
#define BMI2_INT_OPEN_DRAIN_MASK UINT8_C(0x04)
#define BMI2_INT_OUTPUT_EN_MASK UINT8_C(0x08)
#define BMI2_INT_INPUT_EN_MASK UINT8_C(0x10)


#define BMI2_INT_LEVEL_POS UINT8_C(0x01)
#define BMI2_INT_OPEN_DRAIN_POS UINT8_C(0x02)
#define BMI2_INT_OUTPUT_EN_POS UINT8_C(0x03)
#define BMI2_INT_INPUT_EN_POS UINT8_C(0x04)


#define BMI2_FFULL_INT UINT8_C(0x01)
#define BMI2_FWM_INT UINT8_C(0x02)
#define BMI2_DRDY_INT UINT8_C(0x04)
#define BMI2_ERR_INT UINT8_C(0x08)


#define BMI2_FFULL_INT_STATUS_MASK UINT16_C(0x0100)
#define BMI2_FWM_INT_STATUS_MASK UINT16_C(0x0200)
#define BMI2_ERR_INT_STATUS_MASK UINT16_C(0x0400)
#define BMI2_AUX_DRDY_INT_MASK UINT16_C(0x2000)
#define BMI2_GYR_DRDY_INT_MASK UINT16_C(0x4000)
#define BMI2_ACC_DRDY_INT_MASK UINT16_C(0x8000)


#define BMI2_INT_PIN_MAX_NUM UINT8_C(2)


#define BMI2_FEAT_BIT_DISABLE UINT8_C(0)
#define BMI2_FEAT_BIT0 UINT8_C(1)
#define BMI2_FEAT_BIT1 UINT8_C(2)
#define BMI2_FEAT_BIT2 UINT8_C(3)
#define BMI2_FEAT_BIT3 UINT8_C(4)
#define BMI2_FEAT_BIT4 UINT8_C(5)
#define BMI2_FEAT_BIT5 UINT8_C(6)
#define BMI2_FEAT_BIT6 UINT8_C(7)
#define BMI2_FEAT_BIT7 UINT8_C(8)
#define BMI2_FEAT_BIT_MAX UINT8_C(9)





#define BMI2_OIS_IF_EN_MASK UINT8_C(0x10)
#define BMI2_AUX_IF_EN_MASK UINT8_C(0x20)


#define BMI2_OIS_IF_EN_POS UINT8_C(0x04)
#define BMI2_AUX_IF_EN_POS UINT8_C(0x05)





#define BMI2_X UINT8_C(0x01)
#define BMI2_NEG_X UINT8_C(0x09)
#define BMI2_Y UINT8_C(0x02)
#define BMI2_NEG_Y UINT8_C(0x0A)
#define BMI2_Z UINT8_C(0x04)
#define BMI2_NEG_Z UINT8_C(0x0C)
#define BMI2_AXIS_MASK UINT8_C(0x07)
#define BMI2_AXIS_SIGN UINT8_C(0x08)





#define BMI2_GYR_GAIN_EN_MASK UINT8_C(0x80)
#define BMI2_GYR_OFF_COMP_EN_MASK UINT8_C(0x40)


#define BMI2_GYR_OFF_COMP_EN_POS UINT8_C(0x06)


#define BMI2_GYR_USR_GAIN_X_MASK UINT8_C(0x7F)
#define BMI2_GYR_USR_GAIN_Y_MASK UINT8_C(0x7F)
#define BMI2_GYR_USR_GAIN_Z_MASK UINT8_C(0x7F)


#define BMI2_GYR_GAIN_EN_POS UINT8_C(0x07)




#define BMI2_NOT_INIT UINT8_C(0x00)
#define BMI2_INIT_OK UINT8_C(0x01)
#define BMI2_INIT_ERR UINT8_C(0x02)
#define BMI2_DRV_ERR UINT8_C(0x03)
#define BMI2_SNS_STOP UINT8_C(0x04)
#define BMI2_NVM_ERROR UINT8_C(0x05)
#define BMI2_START_UP_ERROR UINT8_C(0x06)
#define BMI2_COMPAT_ERROR UINT8_C(0x07)
#define BMI2_VFM_SKIPPED UINT8_C(0x10)
#define BMI2_AXES_MAP_ERROR UINT8_C(0x20)
#define BMI2_ODR_50_HZ_ERROR UINT8_C(0x40)
#define BMI2_ODR_HIGH_ERROR UINT8_C(0x80)




#define BMI2_G_TRIGGER_NO_ERROR UINT8_C(0x00)

#define BMI2_G_TRIGGER_PRECON_ERROR UINT8_C(0x01)
#define BMI2_G_TRIGGER_DL_ERROR UINT8_C(0x02)
#define BMI2_G_TRIGGER_ABORT_ERROR UINT8_C(0x03)




#define BMI2_CRT_RTOSK_ENABLE UINT8_C(0x01)
#define BMI2_GYRO_CROSS_SENS_ENABLE UINT8_C(0x02)
#define BMI2_GYRO_USER_GAIN_ENABLE UINT8_C(0x08)
#define BMI2_NO_FEATURE_ENABLE UINT8_C(0x00)
#define BMI2_CRT_IN_FIFO_NOT_REQ UINT8_C(0x10)
#define BMI2_MAXIMUM_FIFO_VARIANT UINT8_C(0x20)


#define BMI2_ASDA_PUPSEL_OFF UINT8_C(0x00)
#define BMI2_ASDA_PUPSEL_40K UINT8_C(0x01)
#define BMI2_ASDA_PUPSEL_10K UINT8_C(0x02)
#define BMI2_ASDA_PUPSEL_2K UINT8_C(0x03)
# 1344 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\applications/bmi270/bmi2_defs.h"

# 1344 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\applications/bmi270/bmi2_defs.h"
typedef int8_t (*bmi2_read_fptr_t)(uint8_t reg_addr, uint8_t *reg_data, uint32_t len, void *intf_ptr);
# 1361 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\applications/bmi270/bmi2_defs.h"
typedef int8_t (*bmi2_write_fptr_t)(uint8_t reg_addr, const uint8_t *reg_data, uint32_t len,
                                                   void *intf_ptr);
# 1373 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\applications/bmi270/bmi2_defs.h"
typedef void (*bmi2_delay_fptr_t)(uint32_t period, void *intf_ptr);
# 1389 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\applications/bmi270/bmi2_defs.h"
typedef int8_t (*bmi2_wake_up_fptr_t)(void *wake_up, void *bmi2_dev);
# 1405 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\applications/bmi270/bmi2_defs.h"
typedef int8_t (*bmi2_tap_fptr_t)(void *tap, void *bmi2_dev);





enum bmi2_intf {
    BMI2_SPI_INTF = 0,
    BMI2_I2C_INTF,
    BMI2_I3C_INTF
};




enum bmi2_sensor_config_error {
    BMI2_NO_ERROR,
    BMI2_ACC_ERROR,
    BMI2_GYR_ERROR,
    BMI2_ACC_GYR_ERROR
};


enum bmi2_hw_int_pin {
    BMI2_INT_NONE,
    BMI2_INT1,
    BMI2_INT2,
    BMI2_INT_BOTH,
    BMI2_INT_PIN_MAX
};


enum bmi2_wear_arm_pos {
    BMI2_ARM_LEFT,
    BMI2_ARM_RIGHT
};


enum bmi2_act_recog_type {
    BMI2_ACT_UNKNOWN,
    BMI2_ACT_STILL,
    BMI2_ACT_WALK,
    BMI2_ACT_RUN,
    BMI2_ACT_BIKE,
    BMI2_ACT_VEHICLE,
    BMI2_ACT_TILTED
};


enum bmi2_act_recog_stat {
    BMI2_ACT_START = 1,
    BMI2_ACT_END
};





struct bmi2_gyro_user_gain_data
{

    int8_t x;


    int8_t y;


    int8_t z;
};


struct bmi2_remap
{

    uint8_t x;


    uint8_t y;


    uint8_t z;
};


struct bmi2_axes_remap
{

    uint8_t x_axis;


    uint8_t y_axis;


    uint8_t z_axis;


    uint8_t x_axis_sign;


    uint8_t y_axis_sign;


    uint8_t z_axis_sign;
};


struct bmi2_sens_int_config
{

    uint8_t type;


    enum bmi2_hw_int_pin hw_int_pin;
};


struct bmi2_act_recog_output
{

    uint32_t time_stamp;


    uint8_t curr_act;


    uint8_t prev_act;
};


struct bmi2_fifo_frame
{

    uint8_t *data;


    uint16_t length;


    uint8_t header_enable;




    uint16_t data_enable;


    uint16_t acc_byte_start_idx;


    uint16_t act_recog_byte_start_idx;


    uint16_t aux_byte_start_idx;


    uint16_t gyr_byte_start_idx;


    uint32_t sensor_time;


    uint8_t skipped_frame_count;


    uint8_t data_int_map;


    uint16_t wm_lvl;


    uint8_t acc_frm_len;


    uint8_t gyr_frm_len;


    uint8_t aux_frm_len;


    uint8_t acc_gyr_frm_len;


    uint8_t acc_aux_frm_len;


    uint8_t aux_gyr_frm_len;


    uint8_t all_frm_len;
};


struct bmi2_int_pin_cfg
{

    uint8_t lvl;


    uint8_t od;


    uint8_t output_en;


    uint8_t input_en;
};


struct bmi2_int_pin_config
{

    uint8_t pin_type;


    uint8_t int_latch;


    struct bmi2_int_pin_cfg pin_cfg[2];
};


struct bmi2_aux_fifo_data
{

    uint8_t data[8];


    uint32_t virt_sens_time;
};




struct bmi2_sens_axes_data
{

    int16_t x;


    int16_t y;


    int16_t z;


    uint32_t virt_sens_time;
};


struct bmi2_gyr_user_gain_status
{

    uint8_t sat_x;


    uint8_t sat_y;


    uint8_t sat_z;


    uint8_t g_trigger_status;
};


struct bmi2_gyro_self_test_status
{

    uint8_t gyr_st_axes_done : 1;


    uint8_t gyr_axis_x_ok : 1;


    uint8_t gyr_axis_y_ok : 1;


    uint8_t gyr_axis_z_ok : 1;
};


struct bmi2_nvm_err_status
{

    uint8_t load_error;


    uint8_t prog_error;


    uint8_t erase_error;


    uint8_t exceed_error;


    uint8_t privil_error;
};


struct bmi2_vfrm_err_status
{

    uint8_t lock_error;


    uint8_t write_error;


    uint8_t fatal_error;
};


struct bmi2_acc_self_test_status
{

    uint8_t acc_self_test_done;


    uint8_t acc_x_ok;


    uint8_t acc_y_ok;


    uint8_t acc_z_ok;
};


struct bmi2_orientation_output
{

    uint8_t portrait_landscape;


    uint8_t faceup_down;
};


struct bmi2_ois_output
{

    int16_t ois_acc_x;


    int16_t ois_acc_y;


    int16_t ois_acc_z;


    int16_t ois_gyro_x;


    int16_t ois_gyro_y;


    int16_t ois_gyro_z;
};


struct bmi2_sens_data
{

    struct bmi2_sens_axes_data acc;


    struct bmi2_sens_axes_data gyr;


    uint8_t aux_data[8];


    uint32_t sens_time;
};


union bmi2_feature_data
{

    uint32_t step_counter_output;


    uint8_t activity_output;


    struct bmi2_orientation_output orient_output;


    uint8_t high_g_output;


    struct bmi2_gyr_user_gain_status gyro_user_gain_status;


    struct bmi2_nvm_err_status nvm_status;


    struct bmi2_vfrm_err_status vfrm_status;


    uint8_t wrist_gesture_output;


    int16_t correction_factor_zx;


    struct bmi2_acc_self_test_status accel_self_test_output;


    struct bmi2_ois_output ois_output;
};


struct bmi2_feat_sensor_data
{

    uint8_t type;


    union bmi2_feature_data sens_data;
};


struct bmi2_accel_config
{

    uint8_t odr;


    uint8_t bwp;


    uint8_t filter_perf;


    uint8_t range;
};


struct bmi2_gyro_config
{

    uint8_t odr;


    uint8_t bwp;


    uint8_t filter_perf;


    uint8_t ois_range;


    uint8_t range;


    uint8_t noise_perf;
};


struct bmi2_aux_config
{

    uint8_t aux_en;


    uint8_t manual_en;


    uint8_t fcu_write_en;


    uint8_t man_rd_burst;


    uint8_t aux_rd_burst;


    uint8_t odr;


    uint8_t offset;


    uint8_t i2c_device_addr;


    uint8_t read_addr;
};


struct bmi2_any_motion_config
{

    uint16_t duration;


    uint16_t threshold;


    uint16_t select_x;


    uint16_t select_y;


    uint16_t select_z;
};


struct bmi2_no_motion_config
{

    uint16_t duration;


    uint16_t threshold;


    uint16_t select_x;


    uint16_t select_y;


    uint16_t select_z;
};


struct bmi2_sig_motion_config
{

    uint16_t block_size;


    uint16_t param_2;


    uint16_t param_3;


    uint16_t param_4;


    uint16_t param_5;
};


struct bmi2_ext_tco
{

    uint8_t hw_comp_enable;
};


struct bmi2_step_config
{

    uint16_t watermark_level;


    uint16_t reset_counter;


    uint8_t step_buffer_size;
};


struct bmi2_gyro_user_gain_config
{

    uint16_t ratio_x;


    uint16_t ratio_y;


    uint16_t ratio_z;
};


struct bmi2_wake_up_config
{

    uint16_t sensitivity;





    uint16_t single_tap_en;
};


struct bmi2_tap_config
{

    uint16_t data_reg_en;


    uint16_t tap_sens_thres;


    uint16_t max_gest_dur;


    uint16_t quite_time_after_gest;


    uint16_t wait_for_timeout;


    uint16_t axis_sel;
};


struct bmi2_orient_config
{

    uint16_t ud_en;


    uint16_t mode;


    uint16_t blocking;


    uint16_t theta;


    uint16_t hysteresis;
};


struct bmi2_high_g_config
{

    uint16_t threshold;


    uint16_t hysteresis;


    uint16_t select_x;


    uint16_t select_y;


    uint16_t select_z;


    uint16_t duration;
};


struct bmi2_low_g_config
{

    uint16_t threshold;


    uint16_t hysteresis;


    uint16_t duration;
};


struct bmi2_flat_config
{

    uint16_t theta;


    uint16_t blocking;


    uint16_t hysteresis;


    uint16_t hold_time;
};


struct bmi2_wrist_gest_config
{

    uint16_t wearable_arm;




    uint16_t min_flick_peak;



    uint16_t min_flick_samples;



    uint16_t max_duration;
};


struct bmi2_wrist_wear_wake_up_config
{





    uint16_t min_angle_focus;






    uint16_t min_angle_nonfocus;







    uint16_t max_tilt_lr;







    uint16_t max_tilt_ll;







    uint16_t max_tilt_pd;







    uint16_t max_tilt_pu;
};


struct bmi2_wrist_wear_wake_up_wh_config
{





    uint16_t min_angle_focus;






    uint16_t min_angle_nonfocus;







    uint8_t angle_landscape_right;







    uint8_t angle_landscape_left;







    uint8_t angle_portrait_down;







    uint8_t angle_portrait_up;





    uint8_t min_dur_moved;





    uint8_t min_dur_quite;
};


struct bmi2_primary_ois_config
{

    uint8_t lp_filter_enabled;


    uint8_t lp_filter_config;




    uint8_t gyr_en;




    uint8_t acc_en;
};


struct bmi2_free_fall_det_config
{

    uint16_t freefall_accel_settings[7];
};


struct bmi2_wrist_gest_w_config
{




    uint8_t device_position;


    uint16_t min_flick_peak_y_threshold;


    uint16_t min_flick_peak_z_threshold;



    uint16_t gravity_bounds_x_pos;



    uint16_t gravity_bounds_x_neg;



    uint16_t gravity_bounds_y_neg;



    uint16_t gravity_bounds_z_neg;


    uint16_t flick_peak_decay_coeff;


    uint16_t lp_mean_filter_coeff;


    uint16_t max_duration_jiggle_peaks;
};


struct bmi2_lpd_config
{

    uint8_t flit_data_enable;


    uint8_t lpd_enable;


    uint8_t portrait_theta;


    uint8_t portrait_hysteresis;


    uint8_t landscape_theta;


    uint8_t landscape_hysteresis;


    uint8_t flat_posture_theta;


    uint8_t flat_posture_hysteresis;


    uint8_t blocking_mode;


    uint8_t hold_time;


    uint8_t blockingslope_thres;


    uint16_t segment_size;


    uint16_t post_processing_enable;


    uint16_t mingdithreshold_acc;


    uint16_t mingdithreshold_rej;


    uint16_t output_buffersize;


    uint16_t minseg_moderateconf;
};


struct bmi2_wrist_gesture_config
{

    uint16_t min_flick_peak_y_threshold;


    uint16_t min_flick_peak_z_threshold;


    uint16_t gravity_bounds_x_pos;


    uint16_t gravity_bounds_x_neg;


    uint16_t gravity_bounds_y_neg;


    uint16_t gravity_bounds_z_neg;


    uint16_t flick_peak_decay_coeff;


    uint16_t lp_mean_filter_coeff;


    uint16_t max_duration_jiggle_peaks;



    uint16_t device_position;
};


union bmi2_sens_config_types
{

    struct bmi2_accel_config acc;


    struct bmi2_gyro_config gyr;


    struct bmi2_aux_config aux;


    struct bmi2_any_motion_config any_motion;


    struct bmi2_no_motion_config no_motion;


    struct bmi2_sig_motion_config sig_motion;


    struct bmi2_ext_tco ext_tco;


    uint16_t step_counter_params[25];


    struct bmi2_step_config step_counter;


    struct bmi2_gyro_user_gain_config gyro_gain_update;


    struct bmi2_wake_up_config wake_up_conf;


    struct bmi2_tap_config tap_conf;


    struct bmi2_orient_config orientation;


    struct bmi2_high_g_config high_g;


    struct bmi2_low_g_config low_g;


    struct bmi2_flat_config flat;


    struct bmi2_wrist_gest_config wrist_gest;


    struct bmi2_wrist_wear_wake_up_config wrist_wear_wake_up;


    struct bmi2_wrist_gest_w_config wrist_gest_w;


    struct bmi2_wrist_wear_wake_up_wh_config wrist_wear_wake_up_wh;


    struct bmi2_primary_ois_config primary_ois;


    struct bmi2_free_fall_det_config free_fall_det;


    struct bmi2_lpd_config lap_pos_det;


    struct bmi2_wrist_gesture_config wrist_g_config;
};


struct bmi2_sens_config
{

    uint8_t type;


    union bmi2_sens_config_types cfg;
};


struct bmi2_feature_config
{

    uint8_t type;


    uint8_t page;


    uint8_t start_addr;
};


struct bmi2_map_int
{

    uint8_t type;


    uint8_t sens_map_int;
};


struct bmi2_dev
{

    uint8_t chip_id;






    void *intf_ptr;


    uint8_t info;


    enum bmi2_intf intf;


    int8_t intf_rslt;


    uint8_t dummy_byte;


    uint8_t resolution;


    uint16_t read_write_len;


    const uint8_t *config_file_ptr;


    uint8_t page_max;


    uint8_t input_sens;


    uint8_t out_sens;


    uint8_t aux_man_en;


    uint8_t aux_man_rd_burst_len;


    const struct bmi2_feature_config *feat_config;


    const struct bmi2_feature_config *feat_output;


    struct bmi2_axes_remap remap;


    uint64_t sens_en_stat;


    bmi2_read_fptr_t read;


    bmi2_write_fptr_t write;


    bmi2_delay_fptr_t delay_us;


    int16_t gyr_cross_sens_zx;


    uint8_t gyro_en : 1;


    uint8_t aps_status;


    uint16_t variant_feature;


    uint16_t config_size;


    bmi2_wake_up_fptr_t get_wakeup_config;


    bmi2_wake_up_fptr_t set_wakeup_config;


    bmi2_tap_fptr_t get_tap_config;


    bmi2_tap_fptr_t set_tap_config;


    struct bmi2_map_int *map_int;


    uint8_t sens_int_map;
};


struct bmi2_accel_foc_g_value
{

    uint8_t x;


    uint8_t y;


    uint8_t z;


    uint8_t sign;
};


struct bmi2_act_recg_sett
{

    uint8_t pp_en;




    uint16_t min_gdi_thres;




    uint16_t max_gdi_thres;


    uint8_t buf_size;




    uint8_t min_seg_conf;
};


struct bmi2_hc_act_recg_sett
{

    uint8_t segment_size;


    uint8_t pp_en;


    uint16_t min_gdi_thres;


    uint16_t max_gdi_thres;


    uint16_t buf_size;


    uint16_t min_seg_conf;
};
# 63 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\applications/bmi270/bmi2.h" 2
# 91 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\applications/bmi270/bmi2.h"
int8_t bmi2_sec_init(struct bmi2_dev *dev);
# 121 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\applications/bmi270/bmi2.h"
int8_t bmi2_get_regs(uint8_t reg_addr, uint8_t *data, uint16_t len, struct bmi2_dev *dev);
# 141 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\applications/bmi270/bmi2.h"
int8_t bmi2_set_regs(uint8_t reg_addr, const uint8_t *data, uint16_t len, struct bmi2_dev *dev);
# 167 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\applications/bmi270/bmi2.h"
int8_t bmi2_soft_reset(struct bmi2_dev *dev);
# 191 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\applications/bmi270/bmi2.h"
int8_t bmi2_get_config_file_version(uint8_t *config_major, uint8_t *config_minor, struct bmi2_dev *dev);
# 221 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\applications/bmi270/bmi2.h"
int8_t bmi2_set_adv_power_save(uint8_t enable, struct bmi2_dev *dev);
# 248 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\applications/bmi270/bmi2.h"
int8_t bmi2_get_adv_power_save(uint8_t *aps_status, struct bmi2_dev *dev);
# 264 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\applications/bmi270/bmi2.h"
int8_t bmi2_write_config_file(struct bmi2_dev *dev);
# 290 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\applications/bmi270/bmi2.h"
int8_t bmi2_set_int_pin_config(const struct bmi2_int_pin_config *int_cfg, struct bmi2_dev *dev);
# 310 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\applications/bmi270/bmi2.h"
int8_t bmi2_get_int_pin_config(struct bmi2_int_pin_config *int_cfg, struct bmi2_dev *dev);
# 341 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\applications/bmi270/bmi2.h"
int8_t bmi2_get_int_status(uint16_t *int_status, struct bmi2_dev *dev);
# 376 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\applications/bmi270/bmi2.h"
int8_t bmi2_set_sensor_config(struct bmi2_sens_config *sens_cfg, uint8_t n_sens, struct bmi2_dev *dev);
# 405 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\applications/bmi270/bmi2.h"
int8_t bmi2_get_sensor_config(struct bmi2_sens_config *sens_cfg, uint8_t n_sens, struct bmi2_dev *dev);
# 444 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\applications/bmi270/bmi2.h"
int8_t bmi2_sensor_enable(const uint8_t *sens_list, uint8_t n_sens, struct bmi2_dev *dev);
# 477 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\applications/bmi270/bmi2.h"
int8_t bmi2_sensor_disable(const uint8_t *sens_list, uint8_t n_sens, struct bmi2_dev *dev);
# 510 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\applications/bmi270/bmi2.h"
int8_t bmi2_get_feature_data(struct bmi2_feat_sensor_data *feat_sensor_data, uint8_t n_sens, struct bmi2_dev *dev);
# 527 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\applications/bmi270/bmi2.h"
int8_t bmi2_get_sensor_data(struct bmi2_sens_data *data, struct bmi2_dev *dev);
# 558 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\applications/bmi270/bmi2.h"
int8_t bmi2_set_fifo_config(uint16_t config, uint8_t enable, struct bmi2_dev *dev);
# 575 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\applications/bmi270/bmi2.h"
int8_t bmi2_get_fifo_config(uint16_t *fifo_config, struct bmi2_dev *dev);
# 596 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\applications/bmi270/bmi2.h"
int8_t bmi2_read_fifo_data(struct bmi2_fifo_frame *fifo, struct bmi2_dev *dev);
# 621 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\applications/bmi270/bmi2.h"
int8_t bmi2_extract_accel(struct bmi2_sens_axes_data *accel_data,
                          uint16_t *accel_length,
                          struct bmi2_fifo_frame *fifo,
                          const struct bmi2_dev *dev);
# 649 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\applications/bmi270/bmi2.h"
int8_t bmi2_extract_aux(struct bmi2_aux_fifo_data *aux,
                        uint16_t *aux_length,
                        struct bmi2_fifo_frame *fifo,
                        const struct bmi2_dev *dev);
# 677 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\applications/bmi270/bmi2.h"
int8_t bmi2_extract_gyro(struct bmi2_sens_axes_data *gyro_data,
                         uint16_t *gyro_length,
                         struct bmi2_fifo_frame *fifo,
                         const struct bmi2_dev *dev);
# 711 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\applications/bmi270/bmi2.h"
int8_t bmi2_set_command_register(uint8_t command, struct bmi2_dev *dev);
# 735 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\applications/bmi270/bmi2.h"
int8_t bmi2_set_fifo_self_wake_up(uint8_t fifo_self_wake_up, struct bmi2_dev *dev);
# 760 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\applications/bmi270/bmi2.h"
int8_t bmi2_get_fifo_self_wake_up(uint8_t *fifo_self_wake_up, struct bmi2_dev *dev);
# 777 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\applications/bmi270/bmi2.h"
int8_t bmi2_set_fifo_wm(uint16_t fifo_wm, struct bmi2_dev *dev);
# 794 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\applications/bmi270/bmi2.h"
int8_t bmi2_get_fifo_wm(uint16_t *fifo_wm, struct bmi2_dev *dev);
# 828 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\applications/bmi270/bmi2.h"
int8_t bmi2_set_fifo_filter_data(uint8_t sens_sel, uint8_t fifo_filter_data, struct bmi2_dev *dev);
# 861 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\applications/bmi270/bmi2.h"
int8_t bmi2_get_fifo_filter_data(uint8_t sens_sel, uint8_t *fifo_filter_data, struct bmi2_dev *dev);
# 888 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\applications/bmi270/bmi2.h"
int8_t bmi2_set_fifo_down_sample(uint8_t sens_sel, uint8_t fifo_down_samp, struct bmi2_dev *dev);
# 915 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\applications/bmi270/bmi2.h"
int8_t bmi2_get_fifo_down_sample(uint8_t sens_sel, uint8_t *fifo_down_samp, struct bmi2_dev *dev);
# 937 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\applications/bmi270/bmi2.h"
int8_t bmi2_get_fifo_length(uint16_t *fifo_length, struct bmi2_dev *dev);
# 967 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\applications/bmi270/bmi2.h"
int8_t bmi2_set_ois_interface(uint8_t enable, struct bmi2_dev *dev);
# 995 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\applications/bmi270/bmi2.h"
int8_t bmi2_read_aux_man_mode(uint8_t reg_addr, uint8_t *aux_data, uint16_t len, struct bmi2_dev *dev);
# 1017 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\applications/bmi270/bmi2.h"
int8_t bmi2_write_aux_man_mode(uint8_t reg_addr, const uint8_t *aux_data, uint16_t len, struct bmi2_dev *dev);
# 1051 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\applications/bmi270/bmi2.h"
int8_t bmi2_get_status(uint8_t *status, struct bmi2_dev *dev);
# 1076 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\applications/bmi270/bmi2.h"
int8_t bmi2_write_sync_commands(const uint8_t *command, uint8_t n_comm, struct bmi2_dev *dev);
# 1099 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\applications/bmi270/bmi2.h"
int8_t bmi2_perform_accel_self_test(struct bmi2_dev *dev);
# 1116 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\applications/bmi270/bmi2.h"
int8_t bmi2_map_feat_int(uint8_t type, enum bmi2_hw_int_pin hw_int_pin, struct bmi2_dev *dev);
# 1143 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\applications/bmi270/bmi2.h"
int8_t bmi2_map_data_int(uint8_t data_int, enum bmi2_hw_int_pin int_pin, struct bmi2_dev *dev);
# 1167 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\applications/bmi270/bmi2.h"
int8_t bmi2_get_remap_axes(struct bmi2_remap *remapped_axis, struct bmi2_dev *dev);
# 1185 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\applications/bmi270/bmi2.h"
int8_t bmi2_set_remap_axes(const struct bmi2_remap *remapped_axis, struct bmi2_dev *dev);
# 1216 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\applications/bmi270/bmi2.h"
int8_t bmi2_set_gyro_offset_comp(uint8_t enable, struct bmi2_dev *dev);
# 1235 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\applications/bmi270/bmi2.h"
int8_t bmi2_read_gyro_offset_comp_axes(struct bmi2_sens_axes_data *gyr_off_comp_axes, struct bmi2_dev *dev);
# 1254 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\applications/bmi270/bmi2.h"
int8_t bmi2_write_gyro_offset_comp_axes(const struct bmi2_sens_axes_data *gyr_off_comp_axes, struct bmi2_dev *dev);
# 1277 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\applications/bmi270/bmi2.h"
int8_t bmi2_get_gyro_cross_sense(struct bmi2_dev *dev);
# 1318 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\applications/bmi270/bmi2.h"
int8_t bmi2_get_internal_status(uint8_t *int_stat, struct bmi2_dev *dev);
# 1349 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\applications/bmi270/bmi2.h"
int8_t bmi2_perform_accel_foc(const struct bmi2_accel_foc_g_value *accel_g_value, struct bmi2_dev *dev);
# 1365 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\applications/bmi270/bmi2.h"
int8_t bmi2_perform_gyro_foc(struct bmi2_dev *dev);
# 1390 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\applications/bmi270/bmi2.h"
int8_t bmi2_do_crt(struct bmi2_dev *dev);
# 1412 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\applications/bmi270/bmi2.h"
int8_t bmi2_abort_crt_gyro_st(struct bmi2_dev *dev);
# 1428 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\applications/bmi270/bmi2.h"
int8_t bmi2_do_gyro_st(struct bmi2_dev *dev);
# 1450 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\applications/bmi270/bmi2.h"
int8_t bmi2_nvm_prog(struct bmi2_dev *dev);
# 1465 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\applications/bmi270/bmi2.h"
uint8_t bmi2_extract_input_feat_config(struct bmi2_feature_config *feat_config, uint8_t type,
                                       const struct bmi2_dev *dev);
# 1480 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\applications/bmi270/bmi2.h"
int8_t bmi2_get_feat_config(uint8_t sw_page, uint8_t *feat_config, struct bmi2_dev *dev);
# 2 "../applications/bmi270/bmi2.c" 2
# 1 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rt-thread\\include/rtthread.h" 1
# 25 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rt-thread\\include/rtthread.h"
#define __RT_THREAD_H__ 

# 1 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208/rtconfig.h" 1

#define RT_CONFIG_H__ 





#define RT_NAME_MAX 8
#define RT_ALIGN_SIZE 8
#define RT_THREAD_PRIORITY_32 
#define RT_THREAD_PRIORITY_MAX 32
#define RT_TICK_PER_SECOND 1000
#define RT_USING_HOOK 
#define RT_HOOK_USING_FUNC_PTR 
#define RT_USING_IDLE_HOOK 
#define RT_IDLE_HOOK_LIST_SIZE 4
#define IDLE_THREAD_STACK_SIZE 512
#define RT_USING_TIMER_SOFT 
#define RT_TIMER_THREAD_PRIO 4
#define RT_TIMER_THREAD_STACK_SIZE 512







#define RT_USING_SEMAPHORE 
#define RT_USING_MUTEX 
#define RT_USING_EVENT 
#define RT_USING_MAILBOX 
#define RT_USING_MESSAGEQUEUE 




#define RT_USING_SMALL_MEM 
#define RT_USING_SMALL_MEM_AS_HEAP 
#define RT_USING_HEAP 




#define RT_USING_DEVICE 
#define RT_USING_CONSOLE 
#define RT_CONSOLEBUF_SIZE 128
#define RT_CONSOLE_DEVICE_NAME "uart1"

#define RT_VER_NUM 0x50001

#define RT_USING_HW_ATOMIC 
#define ARCH_RISCV 



#define RT_USING_COMPONENTS_INIT 
#define RT_USING_USER_MAIN 
#define RT_MAIN_THREAD_STACK_SIZE 2048
#define RT_MAIN_THREAD_PRIORITY 10
#define RT_USING_MSH 
#define RT_USING_FINSH 
#define FINSH_USING_MSH 
#define FINSH_THREAD_NAME "tshell"
#define FINSH_THREAD_PRIORITY 20
#define FINSH_THREAD_STACK_SIZE 2048
#define FINSH_USING_HISTORY 
#define FINSH_HISTORY_LINES 5
#define FINSH_USING_SYMTAB 
#define FINSH_CMD_SIZE 80
#define MSH_USING_BUILT_IN_COMMANDS 
#define FINSH_USING_DESCRIPTION 
#define FINSH_ARG_MAX 10







#define RT_USING_DEVICE_IPC 
#define RT_UNAMED_PIPE_NUMBER 64
#define RT_USING_SERIAL 
#define RT_USING_SERIAL_V1 
#define RT_SERIAL_RB_BUFSZ 64
#define RT_USING_HWTIMER 
#define RT_USING_I2C 
#define RT_USING_I2C_BITOPS 
#define RT_USING_PIN 
#define RT_USING_ADC 
#define RT_USING_PWM 
#define RT_USING_RTC 
# 100 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208/rtconfig.h"
#define RT_LIBC_DEFAULT_TIMEZONE 8
# 167 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208/rtconfig.h"
#define U8G2_USE_HW_I2C 
#define U8G2_I2C_DEVICE_NAME "i2c1"
#define U8G2_USING_SW_I2C_SSD1306 
#define PKG_USING_U8G2 




#define PKG_USING_U8G2_LATEST_VERSION 







#define PKG_U8G2_VER_NUM 0x99999
# 282 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208/rtconfig.h"
#define SOC_RISCV_FAMILY_CH32 
#define SOC_RISCV_SERIES_CH32V2 



#define SOC_CH32V208WBU6 







#define BSP_USING_GPIO 
#define BSP_USING_UART 
#define BSP_USING_UART1 
#define BSP_USING_SOFT_I2C 
#define BSP_USING_I2C1 



#define BSP_I2C1_SCL_PIN 26
#define BSP_I2C1_SDA_PIN 27
#define LSI_VALUE 40000
# 28 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rt-thread\\include/rtthread.h" 2
# 1 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rt-thread\\include/rtdef.h" 1
# 55 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rt-thread\\include/rtdef.h"
#define __RT_DEF_H__ 




# 1 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\lib\\gcc\\riscv-none-embed\\8.2.0\\include\\stddef.h" 1 3 4
# 61 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rt-thread\\include/rtdef.h" 2
# 1 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\lib\\gcc\\riscv-none-embed\\8.2.0\\include\\stdarg.h" 1 3 4
# 31 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\lib\\gcc\\riscv-none-embed\\8.2.0\\include\\stdarg.h" 3 4
#define _STDARG_H 
#define _ANSI_STDARG_H_ 

#undef __need___va_list




#define __GNUC_VA_LIST 

# 40 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\lib\\gcc\\riscv-none-embed\\8.2.0\\include\\stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;






#define va_start(v,l) __builtin_va_start(v,l)
#define va_end(v) __builtin_va_end(v)
#define va_arg(v,l) __builtin_va_arg(v,l)


#define va_copy(d,s) __builtin_va_copy(d,s)

#define __va_copy(d,s) __builtin_va_copy(d,s)
# 99 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\lib\\gcc\\riscv-none-embed\\8.2.0\\include\\stdarg.h" 3 4
typedef __gnuc_va_list va_list;





#define _VA_LIST_ 


#define _VA_LIST 


#define _VA_LIST_DEFINED 


#define _VA_LIST_T_H 


#define __va_list__ 
# 62 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rt-thread\\include/rtdef.h" 2
# 1 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\sys\\types.h" 1 3
# 20 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\sys\\types.h" 3
# 1 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\_ansi.h" 1 3







#define _ANSIDECL_H_ 

# 1 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\newlib.h" 1 3







#define __NEWLIB_H__ 1
# 18 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\newlib.h" 3
#define _WANT_IO_C99_FORMATS 1


#define _WANT_IO_LONG_LONG 1


#define _WANT_REGISTER_FINI 1


#define _WANT_IO_LONG_DOUBLE 1
# 40 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\newlib.h" 3
#define _MB_LEN_MAX 1
# 50 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\newlib.h" 3
#define HAVE_INITFINI_ARRAY 1






#define _HAVE_LONG_DOUBLE 1


#define _HAVE_CC_INHIBIT_LOOP_TO_LIBCALL 1





#define _FVWRITE_IN_STREAMIO 1


#define _FSEEK_OPTIMIZATION 1


#define _WIDE_ORIENT 1


#define _UNBUF_STREAM_OPT 1
# 92 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\newlib.h" 3
#define _RETARGETABLE_LOCKING 1
# 11 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\_ansi.h" 2 3
# 1 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\sys\\config.h" 1 3

#define __SYS_CONFIG_H__ 

# 1 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\machine\\ieeefp.h" 1 3
# 193 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\machine\\ieeefp.h" 3
#define __IEEE_LITTLE_ENDIAN 
# 451 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\machine\\ieeefp.h" 3
#define __OBSOLETE_MATH_DEFAULT 1


#define __OBSOLETE_MATH __OBSOLETE_MATH_DEFAULT
# 5 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\sys\\config.h" 2 3
# 79 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\sys\\config.h" 3
#define _READ_WRITE_RETURN_TYPE _ssize_t
# 220 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\sys\\config.h" 3
#define _POINTER_INT long





#undef __RAND_MAX



#define __RAND_MAX 0x7fffffff
# 246 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\sys\\config.h" 3
#define __EXPORT 



#define __IMPORT 
# 263 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\sys\\config.h" 3
#define _READ_WRITE_BUFSIZE_TYPE int
# 12 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\_ansi.h" 2 3
# 31 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\_ansi.h" 3
#define _BEGIN_STD_C 
#define _END_STD_C 
#define _NOTHROW 



#define _LONG_DOUBLE long double





#define _ATTRIBUTE(attrs) __attribute__ (attrs)
# 69 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\_ansi.h" 3
#define _ELIDABLE_INLINE static __inline__



#define _NOINLINE __attribute__ ((__noinline__))
#define _NOINLINE_STATIC _NOINLINE static
# 21 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\sys\\types.h" 2 3
# 1 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\sys\\cdefs.h" 1 3
# 41 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\sys\\cdefs.h" 3
#define _SYS_CDEFS_H_ 



# 1 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\lib\\gcc\\riscv-none-embed\\8.2.0\\include\\stddef.h" 1 3 4
# 46 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\sys\\cdefs.h" 2 3

#define __PMT(args) args
#define __DOTS , ...
#define __THROW 


#define __ASMNAME(cname) __XSTRING (__USER_LABEL_PREFIX__) cname


#define __ptr_t void *
#define __long_double_t long double

#define __attribute_malloc__ 
#define __attribute_pure__ 
#define __attribute_format_strfmon__(a,b) 
#define __flexarr [0]


#define __bounded 
#define __unbounded 
#define __ptrvalue 
# 76 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\sys\\cdefs.h" 3
#define __has_extension __has_feature


#define __has_feature(x) 0





#define __has_builtin(x) 0






#define __BEGIN_DECLS 
#define __END_DECLS 
# 105 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\sys\\cdefs.h" 3
#define __GNUCLIKE_ASM 3
#define __GNUCLIKE_MATH_BUILTIN_CONSTANTS 



#define __GNUCLIKE___TYPEOF 1
#define __GNUCLIKE___OFFSETOF 1
#define __GNUCLIKE___SECTION 1


#define __GNUCLIKE_CTOR_SECTION_HANDLING 1


#define __GNUCLIKE_BUILTIN_CONSTANT_P 1






#define __GNUCLIKE_BUILTIN_VARARGS 1
#define __GNUCLIKE_BUILTIN_STDARG 1
#define __GNUCLIKE_BUILTIN_VAALIST 1



#define __GNUC_VA_LIST_COMPATIBILITY 1






#define __compiler_membar() __asm __volatile(" " : : : "memory")



#define __GNUCLIKE_BUILTIN_NEXT_ARG 1
#define __GNUCLIKE_MATH_BUILTIN_RELOPS 


#define __GNUCLIKE_BUILTIN_MEMCPY 1


#define __CC_SUPPORTS_INLINE 1
#define __CC_SUPPORTS___INLINE 1
#define __CC_SUPPORTS___INLINE__ 1

#define __CC_SUPPORTS___FUNC__ 1
#define __CC_SUPPORTS_WARNING 1

#define __CC_SUPPORTS_VARADIC_XXX 1

#define __CC_SUPPORTS_DYNAMIC_ARRAY_INIT 1
# 175 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\sys\\cdefs.h" 3
#define __P(protos) protos
#define __CONCAT1(x,y) x ## y
#define __CONCAT(x,y) __CONCAT1(x,y)
#define __STRING(x) #x
#define __XSTRING(x) __STRING(x)

#define __const const
#define __signed signed
#define __volatile volatile
# 239 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\sys\\cdefs.h" 3
#define __weak_symbol __attribute__((__weak__))
# 252 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\sys\\cdefs.h" 3
#define __dead2 __attribute__((__noreturn__))
#define __pure2 __attribute__((__const__))
#define __unused __attribute__((__unused__))
#define __used __attribute__((__used__))
#define __packed __attribute__((__packed__))
#define __aligned(x) __attribute__((__aligned__(x)))
#define __section(x) __attribute__((__section__(x)))


#define __alloc_size(x) __attribute__((__alloc_size__ x))




#define __alloc_align(x) __attribute__((__alloc_align__ x))
# 356 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\sys\\cdefs.h" 3
#define __generic(expr,t,yes,no) _Generic(expr, t: yes, default: no)
# 374 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\sys\\cdefs.h" 3
#define __min_size(x) static (x)





#define __malloc_like __attribute__((__malloc__))
#define __pure __attribute__((__pure__))






#define __always_inline __inline__ __attribute__((__always_inline__))





#define __noinline __attribute__ ((__noinline__))





#define __nonnull(x) __attribute__((__nonnull__ x))
#define __nonnull_all __attribute__((__nonnull__))






#define __fastcall __attribute__((__fastcall__))
#define __result_use_check __attribute__((__warn_unused_result__))






#define __returns_twice __attribute__((__returns_twice__))





#define __unreachable() __builtin_unreachable()
# 442 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\sys\\cdefs.h" 3
#define __restrict restrict
# 475 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\sys\\cdefs.h" 3
#define __predict_true(exp) __builtin_expect((exp), 1)
#define __predict_false(exp) __builtin_expect((exp), 0)






#define __null_sentinel __attribute__((__sentinel__))
#define __exported __attribute__((__visibility__("default")))


#define __hidden __attribute__((__visibility__("hidden")))
# 497 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\sys\\cdefs.h" 3
#define __offsetof(type,field) offsetof(type, field)
#define __rangeof(type,start,end) (__offsetof(type, end) - __offsetof(type, start))
# 508 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\sys\\cdefs.h" 3
#define __containerof(x,s,m) ({ const volatile __typeof(((s *)0)->m) *__x = (x); __DEQUALIFY(s *, (const volatile char *)__x - __offsetof(s, m));})
# 530 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\sys\\cdefs.h" 3
#define __printflike(fmtarg,firstvararg) __attribute__((__format__ (__printf__, fmtarg, firstvararg)))

#define __scanflike(fmtarg,firstvararg) __attribute__((__format__ (__scanf__, fmtarg, firstvararg)))

#define __format_arg(fmtarg) __attribute__((__format_arg__ (fmtarg)))
#define __strfmonlike(fmtarg,firstvararg) __attribute__((__format__ (__strfmon__, fmtarg, firstvararg)))

#define __strftimelike(fmtarg,firstvararg) __attribute__((__format__ (__strftime__, fmtarg, firstvararg)))
# 547 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\sys\\cdefs.h" 3
#define __printf0like(fmtarg,firstvararg) 




#define __strong_reference(sym,aliassym) extern __typeof (sym) aliassym __attribute__ ((__alias__ (#sym)))




#define __weak_reference(sym,alias) __asm__(".weak " #alias); __asm__(".equ " #alias ", " #sym)


#define __warn_references(sym,msg) __asm__(".section .gnu.warning." #sym); __asm__(".asciz \"" msg "\""); __asm__(".previous")



#define __sym_compat(sym,impl,verid) __asm__(".symver " #impl ", " #sym "@" #verid)

#define __sym_default(sym,impl,verid) __asm__(".symver " #impl ", " #sym "@@" #verid)
# 601 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\sys\\cdefs.h" 3
#define __FBSDID(s) struct __hack



#define __RCSID(s) struct __hack



#define __RCSID_SOURCE(s) struct __hack



#define __SCCSID(s) struct __hack



#define __COPYRIGHT(s) struct __hack



#define __DECONST(type,var) ((type)(__uintptr_t)(const void *)(var))



#define __DEVOLATILE(type,var) ((type)(__uintptr_t)(volatile void *)(var))



#define __DEQUALIFY(type,var) ((type)(__uintptr_t)(const volatile void *)(var))






#define _Nonnull 
#define _Nullable 
#define _Null_unspecified 
#define __NULLABILITY_PRAGMA_PUSH 
#define __NULLABILITY_PRAGMA_POP 
# 661 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\sys\\cdefs.h" 3
#define __arg_type_tag(arg_kind,arg_idx,type_tag_idx) 
#define __datatype_type_tag(kind,type) 
# 680 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\sys\\cdefs.h" 3
#define __lock_annotate(x) 





#define __lockable __lock_annotate(lockable)


#define __locks_exclusive(...) __lock_annotate(exclusive_lock_function(__VA_ARGS__))

#define __locks_shared(...) __lock_annotate(shared_lock_function(__VA_ARGS__))



#define __trylocks_exclusive(...) __lock_annotate(exclusive_trylock_function(__VA_ARGS__))

#define __trylocks_shared(...) __lock_annotate(shared_trylock_function(__VA_ARGS__))



#define __unlocks(...) __lock_annotate(unlock_function(__VA_ARGS__))


#define __asserts_exclusive(...) __lock_annotate(assert_exclusive_lock(__VA_ARGS__))

#define __asserts_shared(...) __lock_annotate(assert_shared_lock(__VA_ARGS__))



#define __requires_exclusive(...) __lock_annotate(exclusive_locks_required(__VA_ARGS__))

#define __requires_shared(...) __lock_annotate(shared_locks_required(__VA_ARGS__))

#define __requires_unlocked(...) __lock_annotate(locks_excluded(__VA_ARGS__))



#define __no_lock_analysis __lock_annotate(no_thread_safety_analysis)


#define __guarded_by(x) __lock_annotate(guarded_by(x))
#define __pt_guarded_by(x) __lock_annotate(pt_guarded_by(x))
# 22 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\sys\\types.h" 2 3
# 1 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\machine\\_types.h" 1 3





#define _MACHINE__TYPES_H 
# 23 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\sys\\types.h" 2 3





typedef __uint8_t u_int8_t;


typedef __uint16_t u_int16_t;


typedef __uint32_t u_int32_t;


typedef __uint64_t u_int64_t;

typedef int register_t;
#define __BIT_TYPES_DEFINED__ 1
# 60 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\sys\\types.h" 3
#define _SYS_TYPES_H 

# 1 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\lib\\gcc\\riscv-none-embed\\8.2.0\\include\\stddef.h" 1 3 4
# 63 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\sys\\types.h" 2 3
# 1 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\sys\\_types.h" 1 3
# 20 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\sys\\_types.h" 3
#define _SYS__TYPES_H 




# 1 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\sys\\lock.h" 1 3

#define __SYS_LOCK_H__ 
# 33 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\sys\\lock.h" 3
struct __lock;
typedef struct __lock * _LOCK_T;
#define _LOCK_RECURSIVE_T _LOCK_T

#define __LOCK_INIT(class,lock) extern struct __lock __lock_ ## lock; class _LOCK_T lock = &__lock_ ## lock

#define __LOCK_INIT_RECURSIVE(class,lock) __LOCK_INIT(class,lock)

extern void __retarget_lock_init(_LOCK_T *lock);
#define __lock_init(lock) __retarget_lock_init(&lock)
extern void __retarget_lock_init_recursive(_LOCK_T *lock);
#define __lock_init_recursive(lock) __retarget_lock_init_recursive(&lock)
extern void __retarget_lock_close(_LOCK_T lock);
#define __lock_close(lock) __retarget_lock_close(lock)
extern void __retarget_lock_close_recursive(_LOCK_T lock);
#define __lock_close_recursive(lock) __retarget_lock_close_recursive(lock)
extern void __retarget_lock_acquire(_LOCK_T lock);
#define __lock_acquire(lock) __retarget_lock_acquire(lock)
extern void __retarget_lock_acquire_recursive(_LOCK_T lock);
#define __lock_acquire_recursive(lock) __retarget_lock_acquire_recursive(lock)
extern int __retarget_lock_try_acquire(_LOCK_T lock);
#define __lock_try_acquire(lock) __retarget_lock_try_acquire(lock)
extern int __retarget_lock_try_acquire_recursive(_LOCK_T lock);
#define __lock_try_acquire_recursive(lock) __retarget_lock_try_acquire_recursive(lock)

extern void __retarget_lock_release(_LOCK_T lock);
#define __lock_release(lock) __retarget_lock_release(lock)
extern void __retarget_lock_release_recursive(_LOCK_T lock);
#define __lock_release_recursive(lock) __retarget_lock_release_recursive(lock)
# 26 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\sys\\_types.h" 2 3


typedef long __blkcnt_t;



typedef long __blksize_t;



typedef __uint64_t __fsblkcnt_t;



typedef __uint32_t __fsfilcnt_t;



typedef long _off_t;





typedef int __pid_t;



typedef short __dev_t;



typedef unsigned short __uid_t;


typedef unsigned short __gid_t;



typedef __uint32_t __id_t;







typedef unsigned short __ino_t;
# 88 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\sys\\_types.h" 3
typedef __uint32_t __mode_t;





__extension__ typedef long long _off64_t;





typedef _off_t __off_t;


typedef _off64_t __loff_t;


typedef long __key_t;







typedef long _fpos_t;
# 125 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\sys\\_types.h" 3
#undef __size_t



typedef unsigned int __size_t;
# 144 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\sys\\_types.h" 3
#define unsigned signed
typedef signed int _ssize_t;
#undef unsigned
# 156 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\sys\\_types.h" 3
typedef _ssize_t __ssize_t;

#define __need_wint_t 
# 1 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\lib\\gcc\\riscv-none-embed\\8.2.0\\include\\stddef.h" 1 3 4
# 161 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\lib\\gcc\\riscv-none-embed\\8.2.0\\include\\stddef.h" 3 4
#undef __need_ptrdiff_t
# 238 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\lib\\gcc\\riscv-none-embed\\8.2.0\\include\\stddef.h" 3 4
#undef __need_size_t
# 347 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\lib\\gcc\\riscv-none-embed\\8.2.0\\include\\stddef.h" 3 4
#undef __need_wchar_t




#define _WINT_T 




typedef unsigned int wint_t;

#undef __need_wint_t
# 401 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\lib\\gcc\\riscv-none-embed\\8.2.0\\include\\stddef.h" 3 4
#undef NULL




#define NULL ((void *)0)





#undef __need_NULL




#define offsetof(TYPE,MEMBER) __builtin_offsetof (TYPE, MEMBER)
# 160 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\sys\\_types.h" 2 3



typedef struct
{
  int __count;
  union
  {
    wint_t __wch;
    unsigned char __wchb[4];
  } __value;
} _mbstate_t;



typedef _LOCK_T _flock_t;




typedef void *_iconv_t;



#define _CLOCK_T_ unsigned long


typedef unsigned long __clock_t;




#define _TIME_T_ __int_least64_t

typedef __int_least64_t __time_t;

#define _CLOCKID_T_ unsigned long
typedef unsigned long __clockid_t;

#define _TIMER_T_ unsigned long
typedef unsigned long __timer_t;


typedef __uint8_t __sa_family_t;



typedef __uint32_t __socklen_t;


typedef unsigned short __nlink_t;
typedef long __suseconds_t;
typedef unsigned long __useconds_t;


typedef __builtin_va_list __va_list;
# 64 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\sys\\types.h" 2 3
# 113 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\sys\\types.h" 3
typedef __blkcnt_t blkcnt_t;
#define _BLKCNT_T_DECLARED 



typedef __blksize_t blksize_t;
#define _BLKSIZE_T_DECLARED 



typedef unsigned long clock_t;
#define __clock_t_defined 
#define _CLOCK_T_DECLARED 



typedef __int_least64_t time_t;
#define __time_t_defined 
#define _TIME_T_DECLARED 



typedef long daddr_t;
#define __daddr_t_defined 


typedef char * caddr_t;
#define __caddr_t_defined 



typedef __fsblkcnt_t fsblkcnt_t;
typedef __fsfilcnt_t fsfilcnt_t;
#define _FSBLKCNT_T_DECLARED 



typedef __id_t id_t;
#define _ID_T_DECLARED 



typedef __ino_t ino_t;
#define _INO_T_DECLARED 
# 173 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\sys\\types.h" 3
typedef __off_t off_t;
#define _OFF_T_DECLARED 


typedef __dev_t dev_t;
#define _DEV_T_DECLARED 


typedef __uid_t uid_t;
#define _UID_T_DECLARED 


typedef __gid_t gid_t;
#define _GID_T_DECLARED 



typedef __pid_t pid_t;
#define _PID_T_DECLARED 



typedef __key_t key_t;
#define _KEY_T_DECLARED 



typedef _ssize_t ssize_t;
#define _SSIZE_T_DECLARED 



typedef __mode_t mode_t;
#define _MODE_T_DECLARED 



typedef __nlink_t nlink_t;
#define _NLINK_T_DECLARED 



typedef __clockid_t clockid_t;
#define __clockid_t_defined 
#define _CLOCKID_T_DECLARED 



typedef __timer_t timer_t;
#define __timer_t_defined 
#define _TIMER_T_DECLARED 



typedef __useconds_t useconds_t;
#define _USECONDS_T_DECLARED 



typedef __suseconds_t suseconds_t;
#define _SUSECONDS_T_DECLARED 


typedef __int64_t sbintime_t;


# 1 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\sys\\_pthreadtypes.h" 1 3
# 19 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\sys\\_pthreadtypes.h" 3
#define _SYS__PTHREADTYPES_H_ 
# 240 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\sys\\types.h" 2 3
# 1 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\machine\\types.h" 1 3
# 241 "c:\\rt-threadstudio\\repo\\extract\\toolchain_support_packages\\wch\\risc-v-gcc-wch\\8.2.0\\riscv-none-embed\\include\\sys\\types.h" 2 3



#undef __need_inttypes
# 63 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rt-thread\\include/rtdef.h" 2
# 76 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rt-thread\\include/rtdef.h"
#define RT_VERSION_MAJOR 5
#define RT_VERSION_MINOR 0
#define RT_VERSION_PATCH 1


#define RT_VERSION_CHECK(major,minor,revise) ((major * 10000) + (minor * 100) + revise)


#define RTTHREAD_VERSION RT_VERSION_CHECK(RT_VERSION_MAJOR, RT_VERSION_MINOR, RT_VERSION_PATCH)




# 88 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rt-thread\\include/rtdef.h"
typedef int rt_bool_t;
typedef signed long rt_base_t;
typedef unsigned long rt_ubase_t;



typedef int8_t rt_int8_t;
typedef int16_t rt_int16_t;
typedef int32_t rt_int32_t;
typedef uint8_t rt_uint8_t;
typedef uint16_t rt_uint16_t;
typedef uint32_t rt_uint32_t;
typedef int64_t rt_int64_t;
typedef uint64_t rt_uint64_t;
typedef size_t rt_size_t;
typedef ssize_t rt_ssize_t;
# 123 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rt-thread\\include/rtdef.h"
typedef rt_base_t rt_err_t;
typedef rt_uint32_t rt_time_t;
typedef rt_uint32_t rt_tick_t;
typedef rt_base_t rt_flag_t;
typedef rt_ubase_t rt_dev_t;
typedef rt_base_t rt_off_t;






    typedef rt_base_t rt_atomic_t;
# 150 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rt-thread\\include/rtdef.h"
#define RT_TRUE 1
#define RT_FALSE 0


#define RT_NULL 0





#define RT_UINT8_MAX UINT8_MAX
#define RT_UINT16_MAX UINT16_MAX
#define RT_UINT32_MAX UINT32_MAX






#define RT_TICK_MAX RT_UINT32_MAX


#define RT_SEM_VALUE_MAX RT_UINT16_MAX
#define RT_MUTEX_VALUE_MAX RT_UINT16_MAX
#define RT_MUTEX_HOLD_MAX RT_UINT8_MAX
#define RT_MB_ENTRY_MAX RT_UINT16_MAX
#define RT_MQ_ENTRY_MAX RT_UINT16_MAX



#define RT_UNUSED(x) ((void)x)


#define RT_CTASSERT(name,expn) typedef char _ct_assert_ ##name[(expn)?1:-1]
# 215 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rt-thread\\include/rtdef.h"
#define __RT_STRINGIFY(x...) #x
#define RT_STRINGIFY(x...) __RT_STRINGIFY(x)
#define rt_section(x) __attribute__((section(x)))
#define rt_used __attribute__((used))
#define rt_align(n) __attribute__((aligned(n)))
#define rt_weak __attribute__((weak))
#define rt_inline static __inline
#define RTT_API 
# 270 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rt-thread\\include/rtdef.h"
typedef int (*init_fn_t)(void);
# 310 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rt-thread\\include/rtdef.h"
#define INIT_EXPORT(fn,level) rt_used const init_fn_t __rt_init_ ##fn rt_section(".rti_fn." level) = fn
# 319 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rt-thread\\include/rtdef.h"
#define INIT_BOARD_EXPORT(fn) INIT_EXPORT(fn, "1")



#define INIT_PREV_EXPORT(fn) INIT_EXPORT(fn, "2")

#define INIT_DEVICE_EXPORT(fn) INIT_EXPORT(fn, "3")

#define INIT_COMPONENT_EXPORT(fn) INIT_EXPORT(fn, "4")

#define INIT_ENV_EXPORT(fn) INIT_EXPORT(fn, "5")

#define INIT_APP_EXPORT(fn) INIT_EXPORT(fn, "6")
# 345 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rt-thread\\include/rtdef.h"
#define RT_EVENT_LENGTH 32


#define RT_MM_PAGE_SIZE 4096
#define RT_MM_PAGE_MASK (RT_MM_PAGE_SIZE - 1)
#define RT_MM_PAGE_BITS 12



#define RT_KERNEL_MALLOC(sz) rt_malloc(sz)



#define RT_KERNEL_FREE(ptr) rt_free(ptr)



#define RT_KERNEL_REALLOC(ptr,size) rt_realloc(ptr, size)
# 372 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rt-thread\\include/rtdef.h"
#define RT_EOK 0
#define RT_ERROR 1
#define RT_ETIMEOUT 2
#define RT_EFULL 3
#define RT_EEMPTY 4
#define RT_ENOMEM 5
#define RT_ENOSYS 6
#define RT_EBUSY 7
#define RT_EIO 8
#define RT_EINTR 9
#define RT_EINVAL 10
#define RT_ETRAP 11
#define RT_ENOENT 12
#define RT_ENOSPC 13
# 398 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rt-thread\\include/rtdef.h"
#define RT_IS_ALIGN(addr,align) ((!(addr & (align - 1))) && (addr != RT_NULL))
# 407 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rt-thread\\include/rtdef.h"
#define RT_ALIGN(size,align) (((size) + (align) - 1) & ~((align) - 1))
# 416 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rt-thread\\include/rtdef.h"
#define RT_ALIGN_DOWN(size,align) ((size) & ~((align) - 1))




struct rt_list_node
{
    struct rt_list_node *next;
    struct rt_list_node *prev;
};
typedef struct rt_list_node rt_list_t;




struct rt_slist_node
{
    struct rt_slist_node *next;
};
typedef struct rt_slist_node rt_slist_t;
# 446 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rt-thread\\include/rtdef.h"
#define RT_OBJECT_FLAG_MODULE 0x80




struct rt_object
{

    char name[8];



    rt_uint8_t type;
    rt_uint8_t flag;
# 469 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rt-thread\\include/rtdef.h"
    rt_list_t list;
};
typedef struct rt_object *rt_object_t;
# 490 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rt-thread\\include/rtdef.h"
enum rt_object_class_type
{
    RT_Object_Class_Null = 0x00,
    RT_Object_Class_Thread = 0x01,
    RT_Object_Class_Semaphore = 0x02,
    RT_Object_Class_Mutex = 0x03,
    RT_Object_Class_Event = 0x04,
    RT_Object_Class_MailBox = 0x05,
    RT_Object_Class_MessageQueue = 0x06,
    RT_Object_Class_MemHeap = 0x07,
    RT_Object_Class_MemPool = 0x08,
    RT_Object_Class_Device = 0x09,
    RT_Object_Class_Timer = 0x0a,
    RT_Object_Class_Module = 0x0b,
    RT_Object_Class_Memory = 0x0c,
    RT_Object_Class_Channel = 0x0d,
    RT_Object_Class_Custom = 0x0e,
    RT_Object_Class_Unknown = 0x0f,
    RT_Object_Class_Static = 0x80
};




struct rt_object_information
{
    enum rt_object_class_type type;
    rt_list_t object_list;
    rt_size_t object_size;
};
# 528 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rt-thread\\include/rtdef.h"
#define RT_OBJECT_HOOK_CALL(func,argv) __on_ ##func argv

#define __ON_HOOK_ARGS(__hook,argv) do {if ((__hook) != RT_NULL) __hook argv; } while (0)






#define __on_rt_interrupt_switch_hook() __ON_HOOK_ARGS(rt_interrupt_switch_hook, ())


#define __on_rt_malloc_hook(addr,size) __ON_HOOK_ARGS(rt_malloc_hook, (addr, size))


#define __on_rt_free_hook(rmem) __ON_HOOK_ARGS(rt_free_hook, (rmem))
# 558 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rt-thread\\include/rtdef.h"
#define RT_TIMER_FLAG_DEACTIVATED 0x0
#define RT_TIMER_FLAG_ACTIVATED 0x1
#define RT_TIMER_FLAG_ONE_SHOT 0x0
#define RT_TIMER_FLAG_PERIODIC 0x2

#define RT_TIMER_FLAG_HARD_TIMER 0x0
#define RT_TIMER_FLAG_SOFT_TIMER 0x4

#define RT_TIMER_CTRL_SET_TIME 0x0
#define RT_TIMER_CTRL_GET_TIME 0x1
#define RT_TIMER_CTRL_SET_ONESHOT 0x2
#define RT_TIMER_CTRL_SET_PERIODIC 0x3
#define RT_TIMER_CTRL_GET_STATE 0x4
#define RT_TIMER_CTRL_GET_REMAIN_TIME 0x5
#define RT_TIMER_CTRL_GET_FUNC 0x6
#define RT_TIMER_CTRL_SET_FUNC 0x7
#define RT_TIMER_CTRL_GET_PARM 0x8
#define RT_TIMER_CTRL_SET_PARM 0x9


#define RT_TIMER_SKIP_LIST_LEVEL 1




#define RT_TIMER_SKIP_LIST_MASK 0x3





struct rt_timer
{
    struct rt_object parent;

    rt_list_t row[1];

    void (*timeout_func)(void *parameter);
    void *parameter;

    rt_tick_t init_tick;
    rt_tick_t timeout_tick;
};
typedef struct rt_timer *rt_timer_t;
# 640 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rt-thread\\include/rtdef.h"
#define RT_THREAD_INIT 0x00
#define RT_THREAD_CLOSE 0x01
#define RT_THREAD_READY 0x02
#define RT_THREAD_RUNNING 0x03




enum
{
    RT_INTERRUPTIBLE = 0,
    RT_KILLABLE,
    RT_UNINTERRUPTIBLE,
};

#define RT_THREAD_SUSPEND_MASK 0x04
#define RT_SIGNAL_COMMON_WAKEUP_MASK 0x02
#define RT_SIGNAL_KILL_WAKEUP_MASK 0x01

#define RT_THREAD_SUSPEND_INTERRUPTIBLE (RT_THREAD_SUSPEND_MASK)
#define RT_THREAD_SUSPEND RT_THREAD_SUSPEND_INTERRUPTIBLE
#define RT_THREAD_SUSPEND_KILLABLE (RT_THREAD_SUSPEND_MASK | RT_SIGNAL_COMMON_WAKEUP_MASK)
#define RT_THREAD_SUSPEND_UNINTERRUPTIBLE (RT_THREAD_SUSPEND_MASK | RT_SIGNAL_COMMON_WAKEUP_MASK | RT_SIGNAL_KILL_WAKEUP_MASK)
#define RT_THREAD_STAT_MASK 0x07

#define RT_THREAD_STAT_YIELD 0x08
#define RT_THREAD_STAT_YIELD_MASK RT_THREAD_STAT_YIELD

#define RT_THREAD_STAT_SIGNAL 0x10
#define RT_THREAD_STAT_SIGNAL_READY (RT_THREAD_STAT_SIGNAL | RT_THREAD_READY)
#define RT_THREAD_STAT_SIGNAL_WAIT 0x20
#define RT_THREAD_STAT_SIGNAL_PENDING 0x40
#define RT_THREAD_STAT_SIGNAL_MASK 0xf0




#define RT_THREAD_CTRL_STARTUP 0x00
#define RT_THREAD_CTRL_CLOSE 0x01
#define RT_THREAD_CTRL_CHANGE_PRIORITY 0x02
#define RT_THREAD_CTRL_INFO 0x03
#define RT_THREAD_CTRL_BIND_CPU 0x04
# 721 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rt-thread\\include/rtdef.h"
struct rt_thread;
# 769 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rt-thread\\include/rtdef.h"
struct rt_thread
{
    struct rt_object parent;
    rt_list_t tlist;


    void *sp;
    void *entry;
    void *parameter;
    void *stack_addr;
    rt_uint32_t stack_size;


    rt_err_t error;

    rt_uint8_t stat;
# 796 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rt-thread\\include/rtdef.h"
    rt_uint8_t current_priority;
    rt_uint8_t init_priority;




    rt_uint32_t number_mask;



    rt_list_t taken_object_list;
    rt_object_t pending_object;




    rt_uint32_t event_set;
    rt_uint8_t event_info;
# 831 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rt-thread\\include/rtdef.h"
    rt_ubase_t init_tick;
    rt_ubase_t remaining_tick;
# 842 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rt-thread\\include/rtdef.h"
    struct rt_timer thread_timer;

    void (*cleanup)(struct rt_thread *tid);
# 879 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rt-thread\\include/rtdef.h"
    rt_ubase_t user_data;
};
typedef struct rt_thread *rt_thread_t;
# 894 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rt-thread\\include/rtdef.h"
#define RT_IPC_FLAG_FIFO 0x00
#define RT_IPC_FLAG_PRIO 0x01

#define RT_IPC_CMD_UNKNOWN 0x00
#define RT_IPC_CMD_RESET 0x01
#define RT_IPC_CMD_GET_STATE 0x02

#define RT_WAITING_FOREVER -1
#define RT_WAITING_NO 0




struct rt_ipc_object
{
    struct rt_object parent;

    rt_list_t suspend_thread;
};





struct rt_semaphore
{
    struct rt_ipc_object parent;

    rt_uint16_t value;
    rt_uint16_t reserved;
};
typedef struct rt_semaphore *rt_sem_t;






struct rt_mutex
{
    struct rt_ipc_object parent;

    rt_uint8_t ceiling_priority;
    rt_uint8_t priority;
    rt_uint8_t hold;
    rt_uint8_t reserved;

    struct rt_thread *owner;
    rt_list_t taken_list;
};
typedef struct rt_mutex *rt_mutex_t;






#define RT_EVENT_FLAG_AND 0x01
#define RT_EVENT_FLAG_OR 0x02
#define RT_EVENT_FLAG_CLEAR 0x04




struct rt_event
{
    struct rt_ipc_object parent;

    rt_uint32_t set;
};
typedef struct rt_event *rt_event_t;






struct rt_mailbox
{
    struct rt_ipc_object parent;

    rt_ubase_t *msg_pool;

    rt_uint16_t size;

    rt_uint16_t entry;
    rt_uint16_t in_offset;
    rt_uint16_t out_offset;

    rt_list_t suspend_sender_thread;
};
typedef struct rt_mailbox *rt_mailbox_t;






struct rt_messagequeue
{
    struct rt_ipc_object parent;

    void *msg_pool;

    rt_uint16_t msg_size;
    rt_uint16_t max_msgs;

    rt_uint16_t entry;

    void *msg_queue_head;
    void *msg_queue_tail;
    void *msg_queue_free;

    rt_list_t suspend_sender_thread;
};
typedef struct rt_messagequeue *rt_mq_t;
# 1024 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rt-thread\\include/rtdef.h"
struct rt_memory
{
    struct rt_object parent;
    const char * algorithm;
    rt_ubase_t address;
    rt_size_t total;
    rt_size_t used;
    rt_size_t max;
};
typedef struct rt_memory *rt_mem_t;
# 1042 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rt-thread\\include/rtdef.h"
typedef rt_mem_t rt_smem_t;
# 1125 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rt-thread\\include/rtdef.h"
enum rt_device_class_type
{
    RT_Device_Class_Char = 0,
    RT_Device_Class_Block,
    RT_Device_Class_NetIf,
    RT_Device_Class_MTD,
    RT_Device_Class_CAN,
    RT_Device_Class_RTC,
    RT_Device_Class_Sound,
    RT_Device_Class_Graphic,
    RT_Device_Class_I2CBUS,
    RT_Device_Class_USBDevice,
    RT_Device_Class_USBHost,
    RT_Device_Class_USBOTG,
    RT_Device_Class_SPIBUS,
    RT_Device_Class_SPIDevice,
    RT_Device_Class_SDIO,
    RT_Device_Class_PM,
    RT_Device_Class_Pipe,
    RT_Device_Class_Portal,
    RT_Device_Class_Timer,
    RT_Device_Class_Miscellaneous,
    RT_Device_Class_Sensor,
    RT_Device_Class_Touch,
    RT_Device_Class_PHY,
    RT_Device_Class_Security,
    RT_Device_Class_WLAN,
    RT_Device_Class_Pin,
    RT_Device_Class_ADC,
    RT_Device_Class_DAC,
    RT_Device_Class_WDT,
    RT_Device_Class_PWM,
    RT_Device_Class_Bus,
    RT_Device_Class_Unknown
};




#define RT_DEVICE_FLAG_DEACTIVATE 0x000

#define RT_DEVICE_FLAG_RDONLY 0x001
#define RT_DEVICE_FLAG_WRONLY 0x002
#define RT_DEVICE_FLAG_RDWR 0x003

#define RT_DEVICE_FLAG_REMOVABLE 0x004
#define RT_DEVICE_FLAG_STANDALONE 0x008
#define RT_DEVICE_FLAG_ACTIVATED 0x010
#define RT_DEVICE_FLAG_SUSPENDED 0x020
#define RT_DEVICE_FLAG_STREAM 0x040

#define RT_DEVICE_FLAG_INT_RX 0x100
#define RT_DEVICE_FLAG_DMA_RX 0x200
#define RT_DEVICE_FLAG_INT_TX 0x400
#define RT_DEVICE_FLAG_DMA_TX 0x800

#define RT_DEVICE_OFLAG_CLOSE 0x000
#define RT_DEVICE_OFLAG_RDONLY 0x001
#define RT_DEVICE_OFLAG_WRONLY 0x002
#define RT_DEVICE_OFLAG_RDWR 0x003
#define RT_DEVICE_OFLAG_OPEN 0x008
#define RT_DEVICE_OFLAG_MASK 0xf0f







#define RT_DEVICE_CTRL_RESUME 0x01
#define RT_DEVICE_CTRL_SUSPEND 0x02
#define RT_DEVICE_CTRL_CONFIG 0x03
#define RT_DEVICE_CTRL_CLOSE 0x04
#define RT_DEVICE_CTRL_NOTIFY_SET 0x05
#define RT_DEVICE_CTRL_SET_INT 0x06
#define RT_DEVICE_CTRL_CLR_INT 0x07
#define RT_DEVICE_CTRL_GET_INT 0x08
#define RT_DEVICE_CTRL_CONSOLE_OFLAG 0x09
#define RT_DEVICE_CTRL_MASK 0x1f




#define RT_DEVICE_CTRL_BASE(Type) ((RT_Device_Class_ ##Type + 1) * 0x100)





#define RT_DEVICE_CTRL_CHAR_STREAM (RT_DEVICE_CTRL_BASE(Char) + 1)

#define RT_DEVICE_CTRL_BLK_GETGEOME (RT_DEVICE_CTRL_BASE(Block) + 1)
#define RT_DEVICE_CTRL_BLK_SYNC (RT_DEVICE_CTRL_BASE(Block) + 2)
#define RT_DEVICE_CTRL_BLK_ERASE (RT_DEVICE_CTRL_BASE(Block) + 3)
#define RT_DEVICE_CTRL_BLK_AUTOREFRESH (RT_DEVICE_CTRL_BASE(Block) + 4)
#define RT_DEVICE_CTRL_BLK_PARTITION (RT_DEVICE_CTRL_BASE(Block) + 5)

#define RT_DEVICE_CTRL_NETIF_GETMAC (RT_DEVICE_CTRL_BASE(NetIf) + 1)

#define RT_DEVICE_CTRL_MTD_FORMAT (RT_DEVICE_CTRL_BASE(MTD) + 1)

typedef struct rt_device *rt_device_t;
# 1247 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rt-thread\\include/rtdef.h"
struct rt_wqueue
{
    rt_uint32_t flag;
    rt_list_t waiting_list;
};
typedef struct rt_wqueue rt_wqueue_t;




struct rt_device
{
    struct rt_object parent;




    enum rt_device_class_type type;
    rt_uint16_t flag;
    rt_uint16_t open_flag;

    rt_uint8_t ref_count;
    rt_uint8_t device_id;


    rt_err_t (*rx_indicate)(rt_device_t dev, rt_size_t size);
    rt_err_t (*tx_complete)(rt_device_t dev, void *buffer);





    rt_err_t (*init) (rt_device_t dev);
    rt_err_t (*open) (rt_device_t dev, rt_uint16_t oflag);
    rt_err_t (*close) (rt_device_t dev);
    rt_ssize_t (*read) (rt_device_t dev, rt_off_t pos, void *buffer, rt_size_t size);
    rt_ssize_t (*write) (rt_device_t dev, rt_off_t pos, const void *buffer, rt_size_t size);
    rt_err_t (*control)(rt_device_t dev, int cmd, void *args);







    void *user_data;
};

#define RT_DRIVER_MATCH_DTS (1<<0)
struct rt_device_id
{
    const char *compatible;
    void *data;
};

struct rt_driver
{




    rt_err_t (*init) (rt_device_t dev);
    rt_err_t (*open) (rt_device_t dev, rt_uint16_t oflag);
    rt_err_t (*close) (rt_device_t dev);
    rt_ssize_t (*read) (rt_device_t dev, rt_off_t pos, void *buffer, rt_size_t size);
    rt_ssize_t (*write) (rt_device_t dev, rt_off_t pos, const void *buffer, rt_size_t size);
    rt_err_t (*control)(rt_device_t dev, int cmd, void *args);

    const struct filesystem_ops *fops;
    const char *name;
    enum rt_device_class_type dev_type;
    int device_size;
    int flag;
    const struct rt_device_id *dev_match;
    int (*probe)(struct rt_device *dev);
    int (*probe_init)(struct rt_device *dev);
    int (*remove)(struct rt_device *dev);
    const void *ops;
    void *drv_priv_data;
};
typedef struct rt_driver *rt_driver_t;




struct rt_device_notify
{
    void (*notify)(rt_device_t dev);
    struct rt_device *dev;
};
# 1355 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rt-thread\\include/rtdef.h"
struct rt_device_blk_geometry
{
    rt_uint64_t sector_count;
    rt_uint32_t bytes_per_sector;
    rt_uint32_t block_size;
};




struct rt_device_blk_sectors
{
    rt_uint64_t sector_begin;
    rt_uint64_t sector_end;
};




#define RT_DEVICE_CTRL_CURSOR_SET_POSITION 0x10
#define RT_DEVICE_CTRL_CURSOR_SET_TYPE 0x11




#define RTGRAPHIC_CTRL_RECT_UPDATE (RT_DEVICE_CTRL_BASE(Graphic) + 0)
#define RTGRAPHIC_CTRL_POWERON (RT_DEVICE_CTRL_BASE(Graphic) + 1)
#define RTGRAPHIC_CTRL_POWEROFF (RT_DEVICE_CTRL_BASE(Graphic) + 2)
#define RTGRAPHIC_CTRL_GET_INFO (RT_DEVICE_CTRL_BASE(Graphic) + 3)
#define RTGRAPHIC_CTRL_SET_MODE (RT_DEVICE_CTRL_BASE(Graphic) + 4)
#define RTGRAPHIC_CTRL_GET_EXT (RT_DEVICE_CTRL_BASE(Graphic) + 5)
#define RTGRAPHIC_CTRL_SET_BRIGHTNESS (RT_DEVICE_CTRL_BASE(Graphic) + 6)
#define RTGRAPHIC_CTRL_GET_BRIGHTNESS (RT_DEVICE_CTRL_BASE(Graphic) + 7)
#define RTGRAPHIC_CTRL_GET_MODE (RT_DEVICE_CTRL_BASE(Graphic) + 8)
#define RTGRAPHIC_CTRL_GET_STATUS (RT_DEVICE_CTRL_BASE(Graphic) + 9)
#define RTGRAPHIC_CTRL_PAN_DISPLAY (RT_DEVICE_CTRL_BASE(Graphic) + 10)
#define RTGRAPHIC_CTRL_WAIT_VSYNC (RT_DEVICE_CTRL_BASE(Graphic) + 11)


enum
{
    RTGRAPHIC_PIXEL_FORMAT_MONO = 0,
    RTGRAPHIC_PIXEL_FORMAT_GRAY4,
    RTGRAPHIC_PIXEL_FORMAT_GRAY16,
    RTGRAPHIC_PIXEL_FORMAT_RGB332,
    RTGRAPHIC_PIXEL_FORMAT_RGB444,
    RTGRAPHIC_PIXEL_FORMAT_RGB565,
    RTGRAPHIC_PIXEL_FORMAT_RGB565P,
    RTGRAPHIC_PIXEL_FORMAT_BGR565 = RTGRAPHIC_PIXEL_FORMAT_RGB565P,
    RTGRAPHIC_PIXEL_FORMAT_RGB666,
    RTGRAPHIC_PIXEL_FORMAT_RGB888,
    RTGRAPHIC_PIXEL_FORMAT_BGR888,
    RTGRAPHIC_PIXEL_FORMAT_ARGB888,
    RTGRAPHIC_PIXEL_FORMAT_ABGR888,
    RTGRAPHIC_PIXEL_FORMAT_RESERVED,
};




#define RTGRAPHIC_PIXEL_POSITION(x,y) ((x << 16) | y)




struct rt_device_graphic_info
{
    rt_uint8_t pixel_format;
    rt_uint8_t bits_per_pixel;
    rt_uint16_t pitch;

    rt_uint16_t width;
    rt_uint16_t height;

    rt_uint8_t *framebuffer;
    rt_uint32_t smem_len;
};




struct rt_device_rect_info
{
    rt_uint16_t x;
    rt_uint16_t y;
    rt_uint16_t width;
    rt_uint16_t height;
};




struct rt_device_graphic_ops
{
    void (*set_pixel) (const char *pixel, int x, int y);
    void (*get_pixel) (char *pixel, int x, int y);

    void (*draw_hline)(const char *pixel, int x1, int x2, int y);
    void (*draw_vline)(const char *pixel, int x, int y1, int y2);

    void (*blit_line) (const char *pixel, int x, int y, rt_size_t size);
};
#define rt_graphix_ops(device) ((struct rt_device_graphic_ops *)(device->user_data))
# 29 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rt-thread\\include/rtthread.h" 2
# 1 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rt-thread\\include/rtservice.h" 1
# 17 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rt-thread\\include/rtservice.h"
#define __RT_SERVICE_H__ 
# 33 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rt-thread\\include/rtservice.h"
#define rt_container_of(ptr,type,member) ((type *)((char *)(ptr) - (unsigned long)(&((type *)0)->member)))






#define RT_LIST_OBJECT_INIT(object) { &(object), &(object) }






static __inline void rt_list_init(rt_list_t *l)
{
    l->next = l->prev = l;
}







static __inline void rt_list_insert_after(rt_list_t *l, rt_list_t *n)
{
    l->next->prev = n;
    n->next = l->next;

    l->next = n;
    n->prev = l;
}







static __inline void rt_list_insert_before(rt_list_t *l, rt_list_t *n)
{
    l->prev->next = n;
    n->prev = l->prev;

    l->prev = n;
    n->next = l;
}





static __inline void rt_list_remove(rt_list_t *n)
{
    n->next->prev = n->prev;
    n->prev->next = n->next;

    n->next = n->prev = n;
}





static __inline int rt_list_isempty(const rt_list_t *l)
{
    return l->next == l;
}





static __inline unsigned int rt_list_len(const rt_list_t *l)
{
    unsigned int len = 0;
    const rt_list_t *p = l;
    while (p->next != l)
    {
        p = p->next;
        len ++;
    }

    return len;
}







#define rt_list_entry(node,type,member) rt_container_of(node, type, member)







#define rt_list_for_each(pos,head) for (pos = (head)->next; pos != (head); pos = pos->next)
# 143 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rt-thread\\include/rtservice.h"
#define rt_list_for_each_safe(pos,n,head) for (pos = (head)->next, n = pos->next; pos != (head); pos = n, n = pos->next)
# 153 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rt-thread\\include/rtservice.h"
#define rt_list_for_each_entry(pos,head,member) for (pos = rt_list_entry((head)->next, typeof(*pos), member); &pos->member != (head); pos = rt_list_entry(pos->member.next, typeof(*pos), member))
# 165 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rt-thread\\include/rtservice.h"
#define rt_list_for_each_entry_safe(pos,n,head,member) for (pos = rt_list_entry((head)->next, typeof(*pos), member), n = rt_list_entry(pos->member.next, typeof(*pos), member); &pos->member != (head); pos = n, n = rt_list_entry(n->member.next, typeof(*n), member))
# 179 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rt-thread\\include/rtservice.h"
#define rt_list_first_entry(ptr,type,member) rt_list_entry((ptr)->next, type, member)


#define RT_SLIST_OBJECT_INIT(object) { RT_NULL }






static __inline void rt_slist_init(rt_slist_t *l)
{
    l->next = 0;
}

static __inline void rt_slist_append(rt_slist_t *l, rt_slist_t *n)
{
    struct rt_slist_node *node;

    node = l;
    while (node->next) node = node->next;


    node->next = n;
    n->next = 0;
}

static __inline void rt_slist_insert(rt_slist_t *l, rt_slist_t *n)
{
    n->next = l->next;
    l->next = n;
}

static __inline unsigned int rt_slist_len(const rt_slist_t *l)
{
    unsigned int len = 0;
    const rt_slist_t *list = l->next;
    while (list != 0)
    {
        list = list->next;
        len ++;
    }

    return len;
}

static __inline rt_slist_t *rt_slist_remove(rt_slist_t *l, rt_slist_t *n)
{

    struct rt_slist_node *node = l;
    while (node->next && node->next != n) node = node->next;


    if (node->next != (rt_slist_t *)0) node->next = node->next->next;

    return l;
}

static __inline rt_slist_t *rt_slist_first(rt_slist_t *l)
{
    return l->next;
}

static __inline rt_slist_t *rt_slist_tail(rt_slist_t *l)
{
    while (l->next) l = l->next;

    return l;
}

static __inline rt_slist_t *rt_slist_next(rt_slist_t *n)
{
    return n->next;
}

static __inline int rt_slist_isempty(rt_slist_t *l)
{
    return l->next == 0;
}







#define rt_slist_entry(node,type,member) rt_container_of(node, type, member)







#define rt_slist_for_each(pos,head) for (pos = (head)->next; pos != RT_NULL; pos = pos->next)
# 282 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rt-thread\\include/rtservice.h"
#define rt_slist_for_each_entry(pos,head,member) for (pos = rt_slist_entry((head)->next, typeof(*pos), member); &pos->member != (RT_NULL); pos = rt_slist_entry(pos->member.next, typeof(*pos), member))
# 295 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rt-thread\\include/rtservice.h"
#define rt_slist_first_entry(ptr,type,member) rt_slist_entry((ptr)->next, type, member)
# 306 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rt-thread\\include/rtservice.h"
#define rt_slist_tail_entry(ptr,type,member) rt_slist_entry(rt_slist_tail(ptr), type, member)
# 30 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rt-thread\\include/rtthread.h" 2
# 1 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rt-thread\\include/rtm.h" 1
# 11 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rt-thread\\include/rtm.h"
#define __RTM_H__ 


# 1 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rt-thread\\include/rtthread.h" 1
# 15 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rt-thread\\include/rtm.h" 2
# 43 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rt-thread\\include/rtm.h"
#define RTM_EXPORT(symbol) 
# 31 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rt-thread\\include/rtthread.h" 2
# 1 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rt-thread\\include/rtatomic.h" 1
# 12 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rt-thread\\include/rtatomic.h"
#define __RT_ATOMIC_H__ 

# 1 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rt-thread\\include/rthw.h" 1
# 19 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rt-thread\\include/rthw.h"
#define __RT_HW_H__ 
# 31 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rt-thread\\include/rthw.h"
#define HWREG64(x) (*((volatile rt_uint64_t *)(x)))


#define HWREG32(x) (*((volatile rt_uint32_t *)(x)))


#define HWREG16(x) (*((volatile rt_uint16_t *)(x)))


#define HWREG8(x) (*((volatile rt_uint8_t *)(x)))



#define RT_CPU_CACHE_LINE_SZ 32


enum RT_HW_CACHE_OPS
{
    RT_HW_CACHE_FLUSH = 0x01,
    RT_HW_CACHE_INVALIDATE = 0x02,
};
# 74 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rt-thread\\include/rthw.h"
#define rt_hw_cpu_icache_enable(...) 
#define rt_hw_cpu_icache_disable(...) 
#define rt_hw_cpu_icache_ops(...) 
#define rt_hw_cpu_dcache_enable(...) 
#define rt_hw_cpu_dcache_disable(...) 
#define rt_hw_cpu_dcache_ops(...) 

#define rt_hw_cpu_icache_status(...) 0
#define rt_hw_cpu_dcache_status(...) 0



void rt_hw_cpu_reset(void);
void rt_hw_cpu_shutdown(void);

const char *rt_hw_cpu_arch(void);

rt_uint8_t *rt_hw_stack_init(void *entry,
                             void *parameter,
                             rt_uint8_t *stack_addr,
                             void *exit);




typedef void (*rt_isr_handler_t)(int vector, void *param);

struct rt_irq_desc
{
    rt_isr_handler_t handler;
    void *param;





};




void rt_hw_interrupt_init(void);
void rt_hw_interrupt_mask(int vector);
void rt_hw_interrupt_umask(int vector);
rt_isr_handler_t rt_hw_interrupt_install(int vector,
                                         rt_isr_handler_t handler,
                                         void *param,
                                         const char *name);
# 130 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rt-thread\\include/rthw.h"
rt_base_t rt_hw_interrupt_disable(void);
void rt_hw_interrupt_enable(rt_base_t level);

rt_bool_t rt_hw_interrupt_is_disabled(void);
# 143 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rt-thread\\include/rthw.h"
void rt_hw_context_switch(rt_ubase_t from, rt_ubase_t to);
void rt_hw_context_switch_to(rt_ubase_t to);
void rt_hw_context_switch_interrupt(rt_ubase_t from, rt_ubase_t to, rt_thread_t from_thread, rt_thread_t to_thread);


void rt_hw_console_output(const char *str);

void rt_hw_backtrace(rt_uint32_t *fp, rt_ubase_t thread_entry);
void rt_hw_show_memory(rt_uint32_t addr, rt_size_t size);




void rt_hw_exception_install(rt_err_t (*exception_handle)(void *context));




void rt_hw_us_delay(rt_uint32_t us);

int rt_hw_cpu_id(void);
# 206 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rt-thread\\include/rthw.h"
#define RT_DEFINE_SPINLOCK(x) rt_ubase_t x
#define RT_DECLARE_SPINLOCK(x) 

#define rt_hw_spin_lock(lock) *(lock) = rt_hw_interrupt_disable()
#define rt_hw_spin_unlock(lock) rt_hw_interrupt_enable(*(lock))

typedef rt_ubase_t rt_spinlock_t;
struct rt_spinlock
{
    rt_spinlock_t lock;
};





#define rt_hw_isb() 
#define rt_hw_dmb() 
#define rt_hw_dsb() 
# 15 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rt-thread\\include/rtatomic.h" 2



rt_atomic_t rt_hw_atomic_load(volatile rt_atomic_t *ptr);
void rt_hw_atomic_store(volatile rt_atomic_t *ptr, rt_atomic_t val);
rt_atomic_t rt_hw_atomic_add(volatile rt_atomic_t *ptr, rt_atomic_t val);
rt_atomic_t rt_hw_atomic_sub(volatile rt_atomic_t *ptr, rt_atomic_t val);
rt_atomic_t rt_hw_atomic_and(volatile rt_atomic_t *ptr, rt_atomic_t val);
rt_atomic_t rt_hw_atomic_or(volatile rt_atomic_t *ptr, rt_atomic_t val);
rt_atomic_t rt_hw_atomic_xor(volatile rt_atomic_t *ptr, rt_atomic_t val);
rt_atomic_t rt_hw_atomic_exchange(volatile rt_atomic_t *ptr, rt_atomic_t val);
void rt_hw_atomic_flag_clear(volatile rt_atomic_t *ptr);
rt_atomic_t rt_hw_atomic_flag_test_and_set(volatile rt_atomic_t *ptr);
rt_atomic_t rt_hw_atomic_compare_exchange_strong(volatile rt_atomic_t *ptr, rt_atomic_t *expected, rt_atomic_t desired);
# 38 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rt-thread\\include/rtatomic.h"
#define rt_atomic_load(ptr) rt_hw_atomic_load(ptr)
#define rt_atomic_store(ptr,v) rt_hw_atomic_store(ptr, v)
#define rt_atomic_add(ptr,v) rt_hw_atomic_add(ptr, v)
#define rt_atomic_sub(ptr,v) rt_hw_atomic_sub(ptr, v)
#define rt_atomic_and(ptr,v) rt_hw_atomic_and(ptr, v)
#define rt_atomic_or(ptr,v) rt_hw_atomic_or(ptr, v)
#define rt_atomic_xor(ptr,v) rt_hw_atomic_xor(ptr, v)
#define rt_atomic_exchange(ptr,v) rt_hw_atomic_exchange(ptr, v)
#define rt_atomic_flag_clear(ptr) rt_hw_atomic_flag_clear(ptr)
#define rt_atomic_flag_test_and_set(ptr) rt_hw_atomic_flag_test_and_set(ptr)
#define rt_atomic_compare_exchange_strong(ptr,v,des) rt_hw_atomic_compare_exchange_strong(ptr, v ,des)
# 211 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rt-thread\\include/rtatomic.h"
static __inline rt_bool_t rt_atomic_dec_and_test(volatile rt_atomic_t *ptr)
{
    return rt_hw_atomic_sub(ptr, 1) == 0;
}

static __inline rt_atomic_t rt_atomic_fetch_add_unless(volatile rt_atomic_t *ptr, rt_atomic_t a, rt_atomic_t u)
{
    rt_atomic_t c = rt_hw_atomic_load(ptr);

    do {
        if (c == u)
        {
            break;
        }
    } while (!rt_hw_atomic_compare_exchange_strong(ptr, &c ,c + a));

    return c;
}

static __inline rt_bool_t rt_atomic_add_unless(volatile rt_atomic_t *ptr, rt_atomic_t a, rt_atomic_t u)
{
    return rt_atomic_fetch_add_unless(ptr, a, u) != u;
}

static __inline rt_bool_t rt_atomic_inc_not_zero(volatile rt_atomic_t *ptr)
{
    return rt_atomic_add_unless(ptr, 1, 0);
}
# 32 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rt-thread\\include/rtthread.h" 2
# 48 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rt-thread\\include/rtthread.h"
struct rt_object_information *
rt_object_get_information(enum rt_object_class_type type);
int rt_object_get_length(enum rt_object_class_type type);
int rt_object_get_pointers(enum rt_object_class_type type, rt_object_t *pointers, int maxlen);

void rt_object_init(struct rt_object *object,
                    enum rt_object_class_type type,
                    const char *name);
void rt_object_detach(rt_object_t object);

rt_object_t rt_object_allocate(enum rt_object_class_type type,
                               const char *name);
void rt_object_delete(rt_object_t object);

rt_bool_t rt_object_is_systemobject(rt_object_t object);
rt_uint8_t rt_object_get_type(rt_object_t object);
rt_object_t rt_object_find(const char *name, rt_uint8_t type);
rt_err_t rt_object_get_name(rt_object_t object, char *name, rt_uint8_t name_size);



rt_object_t rt_custom_object_create(const char *name, void *data, rt_err_t (*data_destroy)(void *));
rt_err_t rt_custom_object_destroy(rt_object_t obj);



void rt_object_attach_sethook(void (*hook)(struct rt_object *object));
void rt_object_detach_sethook(void (*hook)(struct rt_object *object));
void rt_object_trytake_sethook(void (*hook)(struct rt_object *object));
void rt_object_take_sethook(void (*hook)(struct rt_object *object));
void rt_object_put_sethook(void (*hook)(struct rt_object *object));
# 91 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rt-thread\\include/rtthread.h"
rt_tick_t rt_tick_get(void);
void rt_tick_set(rt_tick_t tick);
void rt_tick_increase(void);
rt_tick_t rt_tick_from_millisecond(rt_int32_t ms);
rt_tick_t rt_tick_get_millisecond(void);

void rt_tick_sethook(void (*hook)(void));


void rt_system_timer_init(void);
void rt_system_timer_thread_init(void);

void rt_timer_init(rt_timer_t timer,
                   const char *name,
                   void (*timeout)(void *parameter),
                   void *parameter,
                   rt_tick_t time,
                   rt_uint8_t flag);
rt_err_t rt_timer_detach(rt_timer_t timer);

rt_timer_t rt_timer_create(const char *name,
                           void (*timeout)(void *parameter),
                           void *parameter,
                           rt_tick_t time,
                           rt_uint8_t flag);
rt_err_t rt_timer_delete(rt_timer_t timer);

rt_err_t rt_timer_start(rt_timer_t timer);
rt_err_t rt_timer_stop(rt_timer_t timer);
rt_err_t rt_timer_control(rt_timer_t timer, int cmd, void *arg);

rt_tick_t rt_timer_next_timeout_tick(void);
void rt_timer_check(void);


void rt_timer_enter_sethook(void (*hook)(struct rt_timer *timer));
void rt_timer_exit_sethook(void (*hook)(struct rt_timer *timer));
# 140 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rt-thread\\include/rtthread.h"
rt_err_t rt_thread_init(struct rt_thread *thread,
                        const char *name,
                        void (*entry)(void *parameter),
                        void *parameter,
                        void *stack_start,
                        rt_uint32_t stack_size,
                        rt_uint8_t priority,
                        rt_uint32_t tick);
rt_err_t rt_thread_detach(rt_thread_t thread);

rt_thread_t rt_thread_create(const char *name,
                             void (*entry)(void *parameter),
                             void *parameter,
                             rt_uint32_t stack_size,
                             rt_uint8_t priority,
                             rt_uint32_t tick);
rt_err_t rt_thread_delete(rt_thread_t thread);

rt_thread_t rt_thread_self(void);
rt_thread_t rt_thread_find(char *name);
rt_err_t rt_thread_startup(rt_thread_t thread);
rt_err_t rt_thread_yield(void);
rt_err_t rt_thread_delay(rt_tick_t tick);
rt_err_t rt_thread_delay_until(rt_tick_t *tick, rt_tick_t inc_tick);
rt_err_t rt_thread_mdelay(rt_int32_t ms);
rt_err_t rt_thread_control(rt_thread_t thread, int cmd, void *arg);
rt_err_t rt_thread_suspend(rt_thread_t thread);
rt_err_t rt_thread_suspend_with_flag(rt_thread_t thread, int suspend_flag);
rt_err_t rt_thread_resume(rt_thread_t thread);




void rt_thread_timeout(void *parameter);

rt_err_t rt_thread_get_name(rt_thread_t thread, char *name, rt_uint8_t name_size);
# 184 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rt-thread\\include/rtthread.h"
void rt_thread_suspend_sethook(void (*hook)(rt_thread_t thread));
void rt_thread_resume_sethook (void (*hook)(rt_thread_t thread));
void rt_thread_inited_sethook (void (*hook)(rt_thread_t thread));





void rt_thread_idle_init(void);

rt_err_t rt_thread_idle_sethook(void (*hook)(void));
rt_err_t rt_thread_idle_delhook(void (*hook)(void));

rt_thread_t rt_thread_idle_gethandler(void);




void rt_system_scheduler_init(void);
void rt_system_scheduler_start(void);

void rt_schedule(void);
void rt_schedule_insert_thread(struct rt_thread *thread);
void rt_schedule_remove_thread(struct rt_thread *thread);

void rt_enter_critical(void);
void rt_exit_critical(void);
rt_uint16_t rt_critical_level(void);


void rt_scheduler_sethook(void (*hook)(rt_thread_t from, rt_thread_t to));
void rt_scheduler_switch_sethook(void (*hook)(struct rt_thread *tid));
# 278 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rt-thread\\include/rtthread.h"
void rt_system_heap_init(void *begin_addr, void *end_addr);

void *rt_malloc(rt_size_t size);
void rt_free(void *ptr);
void *rt_realloc(void *ptr, rt_size_t newsize);
void *rt_calloc(rt_size_t count, rt_size_t size);
void *rt_malloc_align(rt_size_t size, rt_size_t align);
void rt_free_align(void *ptr);

void rt_memory_info(rt_size_t *total,
                    rt_size_t *used,
                    rt_size_t *max_used);







void rt_malloc_sethook(void (*hook)(void *ptr, rt_size_t size));
void rt_free_sethook(void (*hook)(void *ptr));
# 307 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rt-thread\\include/rtthread.h"
rt_smem_t rt_smem_init(const char *name,
                     void *begin_addr,
                     rt_size_t size);
rt_err_t rt_smem_detach(rt_smem_t m);
void *rt_smem_alloc(rt_smem_t m, rt_size_t size);
void *rt_smem_realloc(rt_smem_t m, void *rmem, rt_size_t newsize);
void rt_smem_free(void *rmem);
# 358 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rt-thread\\include/rtthread.h"
rt_err_t rt_sem_init(rt_sem_t sem,
                     const char *name,
                     rt_uint32_t value,
                     rt_uint8_t flag);
rt_err_t rt_sem_detach(rt_sem_t sem);

rt_sem_t rt_sem_create(const char *name, rt_uint32_t value, rt_uint8_t flag);
rt_err_t rt_sem_delete(rt_sem_t sem);


rt_err_t rt_sem_take(rt_sem_t sem, rt_int32_t timeout);
rt_err_t rt_sem_take_interruptible(rt_sem_t sem, rt_int32_t timeout);
rt_err_t rt_sem_take_killable(rt_sem_t sem, rt_int32_t timeout);
rt_err_t rt_sem_trytake(rt_sem_t sem);
rt_err_t rt_sem_release(rt_sem_t sem);
rt_err_t rt_sem_control(rt_sem_t sem, int cmd, void *arg);






rt_err_t rt_mutex_init(rt_mutex_t mutex, const char *name, rt_uint8_t flag);
rt_err_t rt_mutex_detach(rt_mutex_t mutex);

rt_mutex_t rt_mutex_create(const char *name, rt_uint8_t flag);
rt_err_t rt_mutex_delete(rt_mutex_t mutex);

void rt_mutex_drop_thread(rt_mutex_t mutex, rt_thread_t thread);
rt_uint8_t rt_mutex_setprioceiling(rt_mutex_t mutex, rt_uint8_t priority);
rt_uint8_t rt_mutex_getprioceiling(rt_mutex_t mutex);

rt_err_t rt_mutex_take(rt_mutex_t mutex, rt_int32_t timeout);
rt_err_t rt_mutex_trytake(rt_mutex_t mutex);
rt_err_t rt_mutex_take_interruptible(rt_mutex_t mutex, rt_int32_t time);
rt_err_t rt_mutex_take_killable(rt_mutex_t mutex, rt_int32_t time);
rt_err_t rt_mutex_release(rt_mutex_t mutex);
rt_err_t rt_mutex_control(rt_mutex_t mutex, int cmd, void *arg);






rt_err_t rt_event_init(rt_event_t event, const char *name, rt_uint8_t flag);
rt_err_t rt_event_detach(rt_event_t event);

rt_event_t rt_event_create(const char *name, rt_uint8_t flag);
rt_err_t rt_event_delete(rt_event_t event);


rt_err_t rt_event_send(rt_event_t event, rt_uint32_t set);
rt_err_t rt_event_recv(rt_event_t event,
                       rt_uint32_t set,
                       rt_uint8_t opt,
                       rt_int32_t timeout,
                       rt_uint32_t *recved);
rt_err_t rt_event_recv_interruptible(rt_event_t event,
                       rt_uint32_t set,
                       rt_uint8_t opt,
                       rt_int32_t timeout,
                       rt_uint32_t *recved);
rt_err_t rt_event_recv_killable(rt_event_t event,
                       rt_uint32_t set,
                       rt_uint8_t opt,
                       rt_int32_t timeout,
                       rt_uint32_t *recved);
rt_err_t rt_event_control(rt_event_t event, int cmd, void *arg);






rt_err_t rt_mb_init(rt_mailbox_t mb,
                    const char *name,
                    void *msgpool,
                    rt_size_t size,
                    rt_uint8_t flag);
rt_err_t rt_mb_detach(rt_mailbox_t mb);

rt_mailbox_t rt_mb_create(const char *name, rt_size_t size, rt_uint8_t flag);
rt_err_t rt_mb_delete(rt_mailbox_t mb);


rt_err_t rt_mb_send(rt_mailbox_t mb, rt_ubase_t value);
rt_err_t rt_mb_send_wait(rt_mailbox_t mb,
                         rt_ubase_t value,
                         rt_int32_t timeout);
rt_err_t rt_mb_send_wait_interruptible(rt_mailbox_t mb,
                         rt_ubase_t value,
                         rt_int32_t timeout);
rt_err_t rt_mb_send_wait_killable(rt_mailbox_t mb,
                         rt_ubase_t value,
                         rt_int32_t timeout);
rt_err_t rt_mb_urgent(rt_mailbox_t mb, rt_ubase_t value);
rt_err_t rt_mb_recv(rt_mailbox_t mb, rt_ubase_t *value, rt_int32_t timeout);
rt_err_t rt_mb_recv_interruptibale(rt_mailbox_t mb, rt_ubase_t *value, rt_int32_t timeout);
rt_err_t rt_mb_recv_killable(rt_mailbox_t mb, rt_ubase_t *value, rt_int32_t timeout);
rt_err_t rt_mb_control(rt_mailbox_t mb, int cmd, void *arg);




struct rt_mq_message
{
    struct rt_mq_message *next;
    rt_ssize_t length;



};

#define RT_MQ_BUF_SIZE(msg_size,max_msgs) ((RT_ALIGN((msg_size), RT_ALIGN_SIZE) + sizeof(struct rt_mq_message)) * (max_msgs))





rt_err_t rt_mq_init(rt_mq_t mq,
                    const char *name,
                    void *msgpool,
                    rt_size_t msg_size,
                    rt_size_t pool_size,
                    rt_uint8_t flag);
rt_err_t rt_mq_detach(rt_mq_t mq);

rt_mq_t rt_mq_create(const char *name,
                     rt_size_t msg_size,
                     rt_size_t max_msgs,
                     rt_uint8_t flag);
rt_err_t rt_mq_delete(rt_mq_t mq);


rt_err_t rt_mq_send(rt_mq_t mq, const void *buffer, rt_size_t size);
rt_err_t rt_mq_send_interrupt(rt_mq_t mq, const void *buffer, rt_size_t size);
rt_err_t rt_mq_send_killable(rt_mq_t mq, const void *buffer, rt_size_t size);
rt_err_t rt_mq_send_wait(rt_mq_t mq,
                         const void *buffer,
                         rt_size_t size,
                         rt_int32_t timeout);
rt_err_t rt_mq_send_wait_interruptible(rt_mq_t mq,
                         const void *buffer,
                         rt_size_t size,
                         rt_int32_t timeout);
rt_err_t rt_mq_send_wait_killable(rt_mq_t mq,
                         const void *buffer,
                         rt_size_t size,
                         rt_int32_t timeout);
rt_err_t rt_mq_urgent(rt_mq_t mq, const void *buffer, rt_size_t size);
rt_ssize_t rt_mq_recv(rt_mq_t mq,
                    void *buffer,
                    rt_size_t size,
                    rt_int32_t timeout);
rt_ssize_t rt_mq_recv_interruptible(rt_mq_t mq,
                    void *buffer,
                    rt_size_t size,
                    rt_int32_t timeout);
rt_ssize_t rt_mq_recv_killable(rt_mq_t mq,
                    void *buffer,
                    rt_size_t size,
                    rt_int32_t timeout);
rt_err_t rt_mq_control(rt_mq_t mq, int cmd, void *arg);
# 539 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rt-thread\\include/rtthread.h"
void rt_thread_defunct_enqueue(rt_thread_t thread);
rt_thread_t rt_thread_defunct_dequeue(void);
# 555 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rt-thread\\include/rtthread.h"
#define rt_spin_lock_init(lock) 
#define rt_spin_lock(lock) rt_enter_critical()
#define rt_spin_unlock(lock) rt_exit_critical()
#define rt_spin_lock_irqsave(lock) rt_hw_interrupt_disable()
#define rt_spin_unlock_irqrestore(lock,level) rt_hw_interrupt_enable(level)
# 574 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rt-thread\\include/rtthread.h"
rt_device_t rt_device_find(const char *name);

rt_err_t rt_device_register(rt_device_t dev,
                            const char *name,
                            rt_uint16_t flags);
rt_err_t rt_device_unregister(rt_device_t dev);


rt_device_t rt_device_create(int type, int attach_size);
void rt_device_destroy(rt_device_t device);


rt_err_t
rt_device_set_rx_indicate(rt_device_t dev,
                          rt_err_t (*rx_ind)(rt_device_t dev, rt_size_t size));
rt_err_t
rt_device_set_tx_complete(rt_device_t dev,
                          rt_err_t (*tx_done)(rt_device_t dev, void *buffer));

rt_err_t rt_device_init (rt_device_t dev);
rt_err_t rt_device_open (rt_device_t dev, rt_uint16_t oflag);
rt_err_t rt_device_close(rt_device_t dev);
rt_ssize_t rt_device_read(rt_device_t dev,
                          rt_off_t pos,
                          void *buffer,
                          rt_size_t size);
rt_ssize_t rt_device_write(rt_device_t dev,
                          rt_off_t pos,
                          const void *buffer,
                          rt_size_t size);
rt_err_t rt_device_control(rt_device_t dev, int cmd, void *arg);
# 623 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rt-thread\\include/rtthread.h"
void rt_interrupt_enter(void);
void rt_interrupt_leave(void);
# 643 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rt-thread\\include/rtthread.h"
rt_uint8_t rt_interrupt_get_nest(void);


void rt_interrupt_enter_sethook(void (*hook)(void));
void rt_interrupt_leave_sethook(void (*hook)(void));



void rt_components_init(void);
void rt_components_board_init(void);
# 667 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rt-thread\\include/rtthread.h"
int rt_kprintf(const char *fmt, ...);
void rt_kputs(const char *str);


int rt_vsprintf(char *dest, const char *format, va_list arg_ptr);
int rt_vsnprintf(char *buf, rt_size_t size, const char *fmt, va_list args);
int rt_sprintf(char *buf, const char *format, ...);
int rt_snprintf(char *buf, rt_size_t size, const char *format, ...);


rt_device_t rt_console_set_device(const char *name);
rt_device_t rt_console_get_device(void);


rt_err_t rt_get_errno(void);
void rt_set_errno(rt_err_t no);
int *_rt_errno(void);
const char *rt_strerror(rt_err_t error);






int __rt_ffs(int value);


void *rt_memset(void *src, int c, rt_ubase_t n);
void *rt_memcpy(void *dest, const void *src, rt_ubase_t n);
void *rt_memmove(void *dest, const void *src, rt_size_t n);
rt_int32_t rt_memcmp(const void *cs, const void *ct, rt_size_t count);

char *rt_strdup(const char *s);
rt_size_t rt_strnlen(const char *s, rt_ubase_t maxlen);

char *rt_strstr(const char *str1, const char *str2);
rt_int32_t rt_strcasecmp(const char *a, const char *b);
char *rt_strcpy(char *dst, const char *src);
char *rt_strncpy(char *dest, const char *src, rt_size_t n);
rt_int32_t rt_strncmp(const char *cs, const char *ct, rt_size_t count);
rt_int32_t rt_strcmp(const char *cs, const char *ct);
rt_size_t rt_strlen(const char *src);
# 726 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rt-thread\\include/rtthread.h"
void rt_show_version(void);
# 820 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rt-thread\\include/rtthread.h"
#define RT_ASSERT(EX) 
#define RT_DEBUG_NOT_IN_INTERRUPT 
#define RT_DEBUG_IN_THREAD_CONTEXT 
#define RT_DEBUG_SCHEDULER_AVAILABLE(need_check) 



# 1 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rt-thread\\components\\finsh/finsh.h" 1
# 11 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rt-thread\\components\\finsh/finsh.h"
#define __FINSH_H__ 







typedef long (*syscall_func)(void);
# 55 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rt-thread\\components\\finsh/finsh.h"
#define MSH_FUNCTION_EXPORT_CMD(name,cmd,desc) const char __fsym_ ##cmd ##_name[] rt_section(".rodata.name") = #cmd; const char __fsym_ ##cmd ##_desc[] rt_section(".rodata.name") = #desc; rt_used const struct finsh_syscall __fsym_ ##cmd rt_section("FSymTab")= { __fsym_ ##cmd ##_name, __fsym_ ##cmd ##_desc, (syscall_func)&name };
# 109 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rt-thread\\components\\finsh/finsh.h"
#define FINSH_FUNCTION_EXPORT(name,desc) 
# 120 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rt-thread\\components\\finsh/finsh.h"
#define FINSH_FUNCTION_EXPORT_ALIAS(name,alias,desc) 
# 130 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rt-thread\\components\\finsh/finsh.h"
#define MSH_CMD_EXPORT(command,desc) MSH_FUNCTION_EXPORT_CMD(command, command, desc)
# 142 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rt-thread\\components\\finsh/finsh.h"
#define MSH_CMD_EXPORT_ALIAS(command,alias,desc) MSH_FUNCTION_EXPORT_CMD(command, alias, desc)



struct finsh_syscall
{
    const char *name;

    const char *desc;

    syscall_func func;
};


struct finsh_syscall_item
{
    struct finsh_syscall_item *next;
    struct finsh_syscall syscall;
};

extern struct finsh_syscall_item *global_syscall_list;
extern struct finsh_syscall *_syscall_table_begin, *_syscall_table_end;





#define FINSH_NEXT_SYSCALL(index) index++



struct finsh_syscall *finsh_syscall_lookup(const char *name);


void finsh_set_device(const char *device_name);
# 828 "C:\\Users\\yaman\\OneDrive\\Documents\\rtthread-workspace\\CH32V208\\rt-thread\\include/rtthread.h" 2
# 3 "../applications/bmi270/bmi2.c" 2
# 52 "../applications/bmi270/bmi2.c"
struct bmi2_selftest_delta_limit
{

    int32_t x;


    int32_t y;


    int32_t z;
};


struct bmi2_foc_temp_value
{

    int32_t x;


    int32_t y;


    int32_t z;
};


struct bmi2_offset_delta
{

    int16_t x;


    int16_t y;


    int16_t z;
};


struct bmi2_accel_offset
{

    uint8_t x;


    uint8_t y;


    uint8_t z;
};
# 117 "../applications/bmi270/bmi2.c"
static int8_t write_config_file(struct bmi2_dev *dev);
# 130 "../applications/bmi270/bmi2.c"
static int8_t set_config_load(uint8_t enable, struct bmi2_dev *dev);
# 143 "../applications/bmi270/bmi2.c"
static int8_t upload_file(const uint8_t *config_data, uint16_t index, uint16_t write_len, struct bmi2_dev *dev);
# 156 "../applications/bmi270/bmi2.c"
static int8_t set_accel_config(struct bmi2_accel_config *config, struct bmi2_dev *dev);
# 172 "../applications/bmi270/bmi2.c"
static int8_t validate_bw_perf_mode(uint8_t *bandwidth, uint8_t *perf_mode, struct bmi2_dev *dev);
# 188 "../applications/bmi270/bmi2.c"
static int8_t validate_odr_range(uint8_t *odr, uint8_t *range, struct bmi2_dev *dev);
# 201 "../applications/bmi270/bmi2.c"
static int8_t set_gyro_config(struct bmi2_gyro_config *config, struct bmi2_dev *dev);
# 216 "../applications/bmi270/bmi2.c"
static int8_t validate_gyro_config(struct bmi2_gyro_config *config, struct bmi2_dev *dev);
# 228 "../applications/bmi270/bmi2.c"
static int8_t cfg_error_status(struct bmi2_dev *dev);
# 245 "../applications/bmi270/bmi2.c"
static int8_t set_aux_config(struct bmi2_aux_config *config, struct bmi2_dev *dev);
# 270 "../applications/bmi270/bmi2.c"
static int8_t set_gyro_user_gain_config(const struct bmi2_gyro_user_gain_config *config, struct bmi2_dev *dev);
# 282 "../applications/bmi270/bmi2.c"
static int8_t set_aux_interface(const struct bmi2_aux_config *config, struct bmi2_dev *dev);
# 298 "../applications/bmi270/bmi2.c"
static int8_t config_aux_interface(const struct bmi2_aux_config *config, struct bmi2_dev *dev);
# 311 "../applications/bmi270/bmi2.c"
static int8_t config_aux(const struct bmi2_aux_config *config, struct bmi2_dev *dev);
# 325 "../applications/bmi270/bmi2.c"
static int8_t validate_aux_config(struct bmi2_aux_config *config, struct bmi2_dev *dev);
# 338 "../applications/bmi270/bmi2.c"
static int8_t get_accel_config(struct bmi2_accel_config *config, struct bmi2_dev *dev);
# 351 "../applications/bmi270/bmi2.c"
static int8_t get_gyro_config(struct bmi2_gyro_config *config, struct bmi2_dev *dev);
# 368 "../applications/bmi270/bmi2.c"
static int8_t get_aux_config(struct bmi2_aux_config *config, struct bmi2_dev *dev);
# 394 "../applications/bmi270/bmi2.c"
static int8_t get_gyro_gain_update_config(struct bmi2_gyro_user_gain_config *config, struct bmi2_dev *dev);
# 406 "../applications/bmi270/bmi2.c"
static int8_t get_aux_interface(struct bmi2_aux_config *config, struct bmi2_dev *dev);
# 419 "../applications/bmi270/bmi2.c"
static int8_t get_aux_interface_config(struct bmi2_aux_config *config, struct bmi2_dev *dev);
# 432 "../applications/bmi270/bmi2.c"
static int8_t get_aux_cfg(struct bmi2_aux_config *config, struct bmi2_dev *dev);
# 445 "../applications/bmi270/bmi2.c"
static int8_t get_gyro_gain_update_status(struct bmi2_gyr_user_gain_status *user_gain, struct bmi2_dev *dev);
# 461 "../applications/bmi270/bmi2.c"
static uint8_t extract_output_feat_config(struct bmi2_feature_config *feat_output,
                                          uint8_t type,
                                          const struct bmi2_dev *dev);
# 477 "../applications/bmi270/bmi2.c"
static int8_t get_gyro_cross_sense(int16_t *cross_sense, struct bmi2_dev *dev);
# 489 "../applications/bmi270/bmi2.c"
static void get_acc_gyr_data(struct bmi2_sens_axes_data *data, const uint8_t *reg_data);
# 501 "../applications/bmi270/bmi2.c"
static void get_remapped_data(struct bmi2_sens_axes_data *data, const struct bmi2_dev *dev);
# 517 "../applications/bmi270/bmi2.c"
static int8_t read_aux_data(uint8_t reg_addr, uint8_t *aux_data, uint16_t len, uint8_t burst_len, struct bmi2_dev *dev);
# 533 "../applications/bmi270/bmi2.c"
static int8_t set_if_aux_not_busy(uint8_t reg_addr, uint8_t reg_data, struct bmi2_dev *dev);
# 546 "../applications/bmi270/bmi2.c"
static int8_t map_read_len(uint8_t *len, const struct bmi2_dev *dev);
# 564 "../applications/bmi270/bmi2.c"
static int8_t write_aux_data(uint8_t reg_addr, uint8_t reg_data, struct bmi2_dev *dev);
# 578 "../applications/bmi270/bmi2.c"
static int8_t map_feat_int(uint8_t *reg_data_array, enum bmi2_hw_int_pin int_pin, uint8_t int_mask);
# 594 "../applications/bmi270/bmi2.c"
static int8_t parse_fifo_accel_len(uint16_t *start_idx,
                                   uint16_t *len,
                                   uint8_t *skip_length,
                                   const uint16_t *acc_count,
                                   const struct bmi2_fifo_frame *fifo);
# 614 "../applications/bmi270/bmi2.c"
static int8_t extract_accel_header_mode(struct bmi2_sens_axes_data *acc,
                                        uint16_t *accel_length,
                                        struct bmi2_fifo_frame *fifo,
                                        const struct bmi2_dev *dev);
# 633 "../applications/bmi270/bmi2.c"
static int8_t extract_accel_headerless_mode(struct bmi2_sens_axes_data *acc,
                                            uint16_t *accel_length,
                                            struct bmi2_fifo_frame *fifo,
                                            const struct bmi2_dev *dev);
# 659 "../applications/bmi270/bmi2.c"
static int8_t check_dummy_frame(uint8_t dummy_frame_header,
                                uint16_t *data_index,
                                uint8_t skip_length,
                                const struct bmi2_fifo_frame *fifo);
# 683 "../applications/bmi270/bmi2.c"
static int8_t unpack_accel_header_frame(struct bmi2_sens_axes_data *acc,
                                        uint16_t *idx,
                                        uint16_t *acc_idx,
                                        uint8_t frame,
                                        const struct bmi2_fifo_frame *fifo,
                                        const struct bmi2_dev *dev);
# 709 "../applications/bmi270/bmi2.c"
static int8_t unpack_accel_headerless_frame(struct bmi2_sens_axes_data *acc,
                                            uint16_t *idx,
                                            uint16_t *acc_idx,
                                            uint8_t frame,
                                            const struct bmi2_fifo_frame *fifo,
                                            const struct bmi2_dev *dev);
# 730 "../applications/bmi270/bmi2.c"
static void unpack_accel_data(struct bmi2_sens_axes_data *acc,
                              uint16_t data_start_index,
                              const struct bmi2_fifo_frame *fifo,
                              const struct bmi2_dev *dev);
# 751 "../applications/bmi270/bmi2.c"
static int8_t parse_fifo_gyro_len(uint16_t *start_idx,
                                  uint16_t *len,
                                  uint8_t *skip_length,
                                  const uint16_t *gyr_count,
                                  const struct bmi2_fifo_frame *fifo);
# 775 "../applications/bmi270/bmi2.c"
static int8_t unpack_gyro_header_frame(struct bmi2_sens_axes_data *gyr,
                                       uint16_t *idx,
                                       uint16_t *gyr_idx,
                                       uint8_t frame,
                                       const struct bmi2_fifo_frame *fifo,
                                       const struct bmi2_dev *dev);
# 800 "../applications/bmi270/bmi2.c"
static int8_t unpack_gyro_headerless_frame(struct bmi2_sens_axes_data *gyr,
                                           uint16_t *idx,
                                           uint16_t *gyr_idx,
                                           uint8_t frame,
                                           const struct bmi2_fifo_frame *fifo,
                                           const struct bmi2_dev *dev);
# 820 "../applications/bmi270/bmi2.c"
static void unpack_gyro_data(struct bmi2_sens_axes_data *gyr,
                             uint16_t data_start_index,
                             const struct bmi2_fifo_frame *fifo,
                             const struct bmi2_dev *dev);
# 839 "../applications/bmi270/bmi2.c"
static int8_t extract_gyro_header_mode(struct bmi2_sens_axes_data *gyr,
                                       uint16_t *gyro_length,
                                       struct bmi2_fifo_frame *fifo,
                                       const struct bmi2_dev *dev);
# 858 "../applications/bmi270/bmi2.c"
static int8_t extract_gyro_headerless_mode(struct bmi2_sens_axes_data *gyr,
                                           uint16_t *gyro_length,
                                           struct bmi2_fifo_frame *fifo,
                                           const struct bmi2_dev *dev);
# 877 "../applications/bmi270/bmi2.c"
static int8_t parse_fifo_aux_len(uint16_t *start_idx,
                                 uint16_t *len,
                                 uint8_t *skip_length,
                                 const uint16_t *aux_count,
                                 const struct bmi2_fifo_frame *fifo);
# 896 "../applications/bmi270/bmi2.c"
static int8_t extract_aux_header_mode(struct bmi2_aux_fifo_data *aux,
                                      uint16_t *aux_length,
                                      struct bmi2_fifo_frame *fifo,
                                      const struct bmi2_dev *dev);
# 915 "../applications/bmi270/bmi2.c"
static int8_t extract_aux_headerless_mode(struct bmi2_aux_fifo_data *aux,
                                          uint16_t *aux_length,
                                          struct bmi2_fifo_frame *fifo,
                                          const struct bmi2_dev *dev);
# 939 "../applications/bmi270/bmi2.c"
static int8_t unpack_aux_frame(struct bmi2_aux_fifo_data *aux,
                               uint16_t *idx,
                               uint16_t *aux_idx,
                               uint8_t frame,
                               const struct bmi2_fifo_frame *fifo,
                               const struct bmi2_dev *dev);
# 958 "../applications/bmi270/bmi2.c"
static void unpack_aux_data(struct bmi2_aux_fifo_data *aux,
                            uint16_t data_start_index,
                            const struct bmi2_fifo_frame *fifo);
# 972 "../applications/bmi270/bmi2.c"
static void reset_fifo_frame_structure(struct bmi2_fifo_frame *fifo, const struct bmi2_dev *dev);
# 988 "../applications/bmi270/bmi2.c"
static int8_t check_empty_fifo(uint16_t *data_index, const struct bmi2_fifo_frame *fifo);
# 1004 "../applications/bmi270/bmi2.c"
static int8_t move_next_frame(uint16_t *data_index, uint8_t current_frame_length, const struct bmi2_fifo_frame *fifo);
# 1017 "../applications/bmi270/bmi2.c"
static int8_t unpack_sensortime_frame(uint16_t *data_index, struct bmi2_fifo_frame *fifo);
# 1031 "../applications/bmi270/bmi2.c"
static int8_t unpack_skipped_frame(uint16_t *data_index, struct bmi2_fifo_frame *fifo);
# 1043 "../applications/bmi270/bmi2.c"
static int8_t pre_self_test_config(struct bmi2_dev *dev);
# 1061 "../applications/bmi270/bmi2.c"
static int8_t self_test_config(uint8_t sign, struct bmi2_dev *dev);
# 1079 "../applications/bmi270/bmi2.c"
static int8_t set_accel_self_test_enable(uint8_t enable, struct bmi2_dev *dev);
# 1097 "../applications/bmi270/bmi2.c"
static int8_t set_acc_self_test_sign(uint8_t sign, struct bmi2_dev *dev);
# 1115 "../applications/bmi270/bmi2.c"
static int8_t set_accel_self_test_amp(uint8_t amp, struct bmi2_dev *dev);
# 1128 "../applications/bmi270/bmi2.c"
static int8_t read_accel_xyz(struct bmi2_sens_axes_data *accel, struct bmi2_dev *dev);
# 1141 "../applications/bmi270/bmi2.c"
static void convert_lsb_g(const struct bmi2_selftest_delta_limit *acc_data_diff,
                          struct bmi2_selftest_delta_limit *acc_data_diff_mg,
                          const struct bmi2_dev *dev);
# 1154 "../applications/bmi270/bmi2.c"
static int32_t power(int16_t base, uint8_t resolution);
# 1166 "../applications/bmi270/bmi2.c"
static int8_t validate_self_test(const struct bmi2_selftest_delta_limit *accel_data_diff);
# 1178 "../applications/bmi270/bmi2.c"
static int8_t get_remap_axes(struct bmi2_axes_remap *remap, struct bmi2_dev *dev);
# 1190 "../applications/bmi270/bmi2.c"
static int8_t set_remap_axes(const struct bmi2_axes_remap *remap, struct bmi2_dev *dev);
# 1202 "../applications/bmi270/bmi2.c"
static int8_t get_maxburst_len(uint8_t *max_burst_len, struct bmi2_dev *dev);
# 1214 "../applications/bmi270/bmi2.c"
static int8_t set_maxburst_len(const uint16_t write_len_byte, struct bmi2_dev *dev);
# 1227 "../applications/bmi270/bmi2.c"
static void parse_if_virtual_header(uint8_t *frame_header, uint16_t *data_index, const struct bmi2_fifo_frame *fifo);
# 1240 "../applications/bmi270/bmi2.c"
static void unpack_virt_sensor_time(struct bmi2_sens_axes_data *sens, uint16_t *idx,
                                    const struct bmi2_fifo_frame *fifo);
# 1254 "../applications/bmi270/bmi2.c"
static void unpack_virt_aux_sensor_time(struct bmi2_aux_fifo_data *aux,
                                        uint16_t *idx,
                                        const struct bmi2_fifo_frame *fifo);
# 1269 "../applications/bmi270/bmi2.c"
static int16_t saturate(int32_t value, uint16_t saturation_val);
# 1283 "../applications/bmi270/bmi2.c"
static void comp_gyro_cross_axis_sensitivity(struct bmi2_sens_axes_data *gyr_data, const struct bmi2_dev *dev);
# 1297 "../applications/bmi270/bmi2.c"
static int8_t save_accel_foc_config(struct bmi2_accel_config *acc_cfg,
                                    uint8_t *aps,
                                    uint8_t *acc_en,
                                    struct bmi2_dev *dev);
# 1320 "../applications/bmi270/bmi2.c"
static int8_t perform_accel_foc(const struct bmi2_accel_foc_g_value *accel_g_value,
                                const struct bmi2_accel_config *acc_cfg,
                                struct bmi2_dev *dev);
# 1333 "../applications/bmi270/bmi2.c"
static int8_t set_accel_foc_config(struct bmi2_dev *dev);
# 1346 "../applications/bmi270/bmi2.c"
static int8_t set_accel_offset_comp(uint8_t offset_en, struct bmi2_dev *dev);
# 1358 "../applications/bmi270/bmi2.c"
static void map_accel_range(uint8_t range_in, uint8_t *range_out);
# 1373 "../applications/bmi270/bmi2.c"
static void comp_for_gravity(uint16_t lsb_per_g,
                             const struct bmi2_accel_foc_g_value *g_val,
                             const struct bmi2_sens_axes_data *data,
                             struct bmi2_offset_delta *comp_data);
# 1391 "../applications/bmi270/bmi2.c"
static void scale_accel_offset(uint8_t range, const struct bmi2_offset_delta *comp_data,
                               struct bmi2_accel_offset *data);
# 1403 "../applications/bmi270/bmi2.c"
static int8_t get_bit_pos_3_9mg(uint8_t range);
# 1413 "../applications/bmi270/bmi2.c"
static void invert_accel_offset(struct bmi2_accel_offset *offset_data);
# 1426 "../applications/bmi270/bmi2.c"
static int8_t write_accel_offset(const struct bmi2_accel_offset *offset, struct bmi2_dev *dev);
# 1441 "../applications/bmi270/bmi2.c"
static int8_t restore_accel_foc_config(struct bmi2_accel_config *acc_cfg,
                                       uint8_t aps,
                                       uint8_t acc_en,
                                       struct bmi2_dev *dev);
# 1459 "../applications/bmi270/bmi2.c"
static int8_t save_gyro_config(struct bmi2_gyro_config *gyr_cfg, uint8_t *aps, uint8_t *gyr_en, struct bmi2_dev *dev);
# 1470 "../applications/bmi270/bmi2.c"
static int8_t set_gyro_foc_config(struct bmi2_dev *dev);
# 1480 "../applications/bmi270/bmi2.c"
static void invert_gyro_offset(struct bmi2_sens_axes_data *offset_data);
# 1495 "../applications/bmi270/bmi2.c"
static int8_t restore_gyro_config(struct bmi2_gyro_config *gyr_cfg, uint8_t aps, uint8_t gyr_en, struct bmi2_dev *dev);
# 1506 "../applications/bmi270/bmi2.c"
static void saturate_gyro_data(struct bmi2_sens_axes_data *gyr_off);
# 1519 "../applications/bmi270/bmi2.c"
static int8_t read_gyro_xyz(struct bmi2_sens_axes_data *gyro, struct bmi2_dev *dev);
# 1533 "../applications/bmi270/bmi2.c"
static int8_t check_boundary_val(uint8_t *val, uint8_t min, uint8_t max, struct bmi2_dev *dev);
# 1545 "../applications/bmi270/bmi2.c"
static int8_t null_ptr_check(const struct bmi2_dev *dev);
# 1556 "../applications/bmi270/bmi2.c"
static int8_t crt_gyro_st_update_result(struct bmi2_dev *dev);
# 1568 "../applications/bmi270/bmi2.c"
static int8_t get_st_running(uint8_t *st_status, struct bmi2_dev *dev);
# 1580 "../applications/bmi270/bmi2.c"
static int8_t set_st_running(uint8_t st_status, struct bmi2_dev *dev);
# 1593 "../applications/bmi270/bmi2.c"
static int8_t crt_prepare_setup(struct bmi2_dev *dev);
# 1605 "../applications/bmi270/bmi2.c"
static int8_t do_gtrigger_test(uint8_t gyro_st_crt, struct bmi2_dev *dev);
# 1619 "../applications/bmi270/bmi2.c"
static int8_t get_rdy_for_dl(uint8_t *rdy_for_dl, struct bmi2_dev *dev);
# 1635 "../applications/bmi270/bmi2.c"
static int8_t write_crt_config_file(uint16_t write_len,
                                    uint16_t config_file_size,
                                    uint16_t start_index,
                                    struct bmi2_dev *dev);
# 1651 "../applications/bmi270/bmi2.c"
static int8_t wait_rdy_for_dl_toggle(uint8_t retry_complete, uint8_t download_ready, struct bmi2_dev *dev);
# 1663 "../applications/bmi270/bmi2.c"
static int8_t wait_st_running(uint8_t retry_complete, struct bmi2_dev *dev);
# 1676 "../applications/bmi270/bmi2.c"
static int8_t process_crt_download(uint8_t last_byte_flag, struct bmi2_dev *dev);
# 1688 "../applications/bmi270/bmi2.c"
static int8_t select_self_test(uint8_t gyro_st_crt, struct bmi2_dev *dev);
# 1700 "../applications/bmi270/bmi2.c"
static int8_t abort_bmi2(uint8_t abort_enable, struct bmi2_dev *dev);
# 1712 "../applications/bmi270/bmi2.c"
static int8_t gyro_self_test_completed(struct bmi2_gyro_self_test_status *gyro_st_result, struct bmi2_dev *dev);
# 1724 "../applications/bmi270/bmi2.c"
static int8_t set_nvm_prep_prog(uint8_t nvm_prep, struct bmi2_dev *dev);
# 1737 "../applications/bmi270/bmi2.c"
static int8_t extract_config_file(uint8_t *config_major, uint8_t *config_minor, struct bmi2_dev *dev);
# 1749 "../applications/bmi270/bmi2.c"
static void extract_feat_int_map(struct bmi2_map_int *map_int, uint8_t type, const struct bmi2_dev *dev);
# 1763 "../applications/bmi270/bmi2.c"
static int8_t select_sensor(const uint8_t *sens_list, uint8_t n_sens, uint64_t *sensor_sel);
# 1775 "../applications/bmi270/bmi2.c"
static int8_t sensor_enable(uint64_t sensor_sel, struct bmi2_dev *dev);
# 1787 "../applications/bmi270/bmi2.c"
static int8_t sensor_disable(uint64_t sensor_sel, struct bmi2_dev *dev);
# 1802 "../applications/bmi270/bmi2.c"
static int8_t read_sensor_data(uint8_t aux_len,
                               uint8_t acc_len,
                               uint8_t gyr_len,
                               uint8_t *sensor_data,
                               struct bmi2_dev *dev);
# 1822 "../applications/bmi270/bmi2.c"
static int8_t parse_data(uint8_t aux_len,
                         uint8_t acc_len,
                         uint8_t gyr_len,
                         struct bmi2_sens_data *data,
                         const uint8_t *sensor_data,
                         struct bmi2_dev *dev);
# 1840 "../applications/bmi270/bmi2.c"
static int8_t gyro_crt_test(uint8_t max_burst_length, uint8_t gyro_st_crt, struct bmi2_dev *dev);
# 1857 "../applications/bmi270/bmi2.c"
static void unpack_virtual_aux_data(struct bmi2_aux_fifo_data *aux,
                                    uint16_t *idx,
                                    const uint16_t *aux_idx,
                                    const struct bmi2_fifo_frame *fifo,
                                    const struct bmi2_dev *dev);
# 1872 "../applications/bmi270/bmi2.c"
int8_t bmi2_sec_init(struct bmi2_dev *dev)
{

    int8_t rslt;


    uint8_t chip_id = 0;


    struct bmi2_axes_remap axes_remap = {
        .x_axis = 0x00, .x_axis_sign = 0, .y_axis = 0x01,
        .y_axis_sign = 0, .z_axis = 0x02, .z_axis_sign = 0
    };


    rslt = null_ptr_check(dev);

    if (rslt == 0)
    {


        dev->aps_status = 1;


        if (dev->intf == BMI2_SPI_INTF)
        {
            rslt = bmi2_get_regs(0x00, &chip_id, 1, dev);
        }

        if (rslt == 0)
        {


            rslt = bmi2_get_regs(0x00, &chip_id, 1, dev);

            if (rslt == 0)
            {


                if (chip_id == dev->chip_id)
                {


                    dev->resolution = 16;


                    dev->aux_man_en = 1;




                    dev->remap = axes_remap;




                    rslt = bmi2_soft_reset(dev);

                }
                else
                {



                    dev->chip_id = chip_id;
                    rslt = -3;
                }
            }
        }
    }

    return rslt;
}
# 1954 "../applications/bmi270/bmi2.c"
int8_t bmi2_get_regs(uint8_t reg_addr, uint8_t *data, uint16_t len, struct bmi2_dev *dev)
{

    int8_t rslt;


    uint16_t index = 0;


    uint8_t temp_buf[128];


    rslt = null_ptr_check(dev);
    if ((rslt == 0) && (data != 
# 1967 "../applications/bmi270/bmi2.c" 3 4
                                     ((void *)0)
# 1967 "../applications/bmi270/bmi2.c"
                                         ))
    {

        if (dev->intf == BMI2_SPI_INTF)
        {
            reg_addr = (reg_addr | 0x80);
        }

        dev->intf_rslt = dev->read(reg_addr, temp_buf, (len + dev->dummy_byte), dev->intf_ptr);

        if (dev->aps_status == 1)
        {
            dev->delay_us(450, dev->intf_ptr);
        }
        else
        {
            dev->delay_us(2, dev->intf_ptr);
        }

        if (dev->intf_rslt == 0)
        {

            while (index < len)
            {
                data[index] = temp_buf[index + dev->dummy_byte];
                index++;
            }
        }
        else
        {
            rslt = -2;
        }
    }
    else
    {
        rslt = -1;
    }

    return rslt;
}




int8_t bmi2_set_regs(uint8_t reg_addr, const uint8_t *data, uint16_t len, struct bmi2_dev *dev)
{

    int8_t rslt;


    rslt = null_ptr_check(dev);
    if ((rslt == 0) && (data != 
# 2018 "../applications/bmi270/bmi2.c" 3 4
                                     ((void *)0)
# 2018 "../applications/bmi270/bmi2.c"
                                         ))
    {

        if (dev->intf == BMI2_SPI_INTF)
        {
            reg_addr = (reg_addr & 0x7F);
        }

        dev->intf_rslt = dev->write(reg_addr, data, len, dev->intf_ptr);


        if (dev->aps_status == 1)
        {
            dev->delay_us(450, dev->intf_ptr);
        }

        else
        {
            dev->delay_us(2, dev->intf_ptr);
        }


        if (reg_addr == 0x7C)
        {
            if (*data & 0x01)
            {
                dev->aps_status = 1;
            }
            else
            {
                dev->aps_status = 0;
            }
        }

        if (dev->intf_rslt != 0)
        {
            rslt = -2;
        }
    }
    else
    {
        rslt = -1;
    }

    return rslt;
}





int8_t bmi2_soft_reset(struct bmi2_dev *dev)
{

    int8_t rslt;


    uint8_t data = 0xB6;


    uint8_t dummy_read = 0;


    rslt = null_ptr_check(dev);
    if (rslt == 0)
    {

        rslt = bmi2_set_regs(0x7E, &data, 1, dev);
        dev->delay_us(2000, dev->intf_ptr);


        dev->aps_status = 1;




        if ((rslt == 0) && (dev->intf == BMI2_SPI_INTF))
        {
            rslt = bmi2_get_regs(0x00, &dummy_read, 1, dev);
        }

        if (rslt == 0)
        {

            rslt = bmi2_write_config_file(dev);
        }


        if (rslt == 0)
        {
            dev->sens_en_stat = 0;
        }
    }

    return rslt;
}




int8_t bmi2_get_config_file_version(uint8_t *config_major, uint8_t *config_minor, struct bmi2_dev *dev)
{

    int8_t rslt;


    rslt = null_ptr_check(dev);
    if ((rslt == 0) && (config_major != 
# 2125 "../applications/bmi270/bmi2.c" 3 4
                                             ((void *)0)
# 2125 "../applications/bmi270/bmi2.c"
                                                 ) && (config_minor != 
# 2125 "../applications/bmi270/bmi2.c" 3 4
                                                                       ((void *)0)
# 2125 "../applications/bmi270/bmi2.c"
                                                                           ))
    {

        rslt = extract_config_file(config_major, config_minor, dev);
    }
    else
    {
        rslt = -1;
    }

    return rslt;
}




int8_t bmi2_set_adv_power_save(uint8_t enable, struct bmi2_dev *dev)
{

    int8_t rslt;


    uint8_t reg_data = 0;


    rslt = null_ptr_check(dev);
    if (rslt == 0)
    {
        rslt = bmi2_get_regs(0x7C, &reg_data, 1, dev);
        if (rslt == 0)
        {
            reg_data = ((reg_data & ~(0x01)) | (enable & 0x01));
            rslt = bmi2_set_regs(0x7C, &reg_data, 1, dev);

            if (rslt != 0)
            {

                rslt = -13;
            }

            if (rslt == 0)
            {
                dev->aps_status = (reg_data & (0x01));
            }
        }
    }

    return rslt;
}




int8_t bmi2_get_adv_power_save(uint8_t *aps_status, struct bmi2_dev *dev)
{

    int8_t rslt;


    uint8_t reg_data = 0;


    rslt = null_ptr_check(dev);
    if ((rslt == 0) && (aps_status != 
# 2188 "../applications/bmi270/bmi2.c" 3 4
                                           ((void *)0)
# 2188 "../applications/bmi270/bmi2.c"
                                               ))
    {
        rslt = bmi2_get_regs(0x7C, &reg_data, 1, dev);
        if (rslt == 0)
        {
            *aps_status = (reg_data & (0x01));
            dev->aps_status = *aps_status;
        }
    }
    else
    {
        rslt = -1;
    }

    return rslt;
}




int8_t bmi2_write_config_file(struct bmi2_dev *dev)
{

    int8_t rslt;


    uint8_t load_status = 0;


    rslt = null_ptr_check(dev);
    if ((rslt == 0) && (dev->config_size != 0))
    {

        if ((dev->read_write_len % 2) != 0)
        {
            dev->read_write_len = dev->read_write_len - 1;
        }

        if (dev->read_write_len < 2)
        {
            dev->read_write_len = 2;
        }


        rslt = write_config_file(dev);
        if (rslt == 0)
        {

            rslt = bmi2_get_internal_status(&load_status, dev);


            if ((rslt == 0) && (!(load_status & 1)))
            {
                rslt = -9;
            }
        }
    }
    else
    {
        rslt = -1;
    }

    return rslt;
}







int8_t bmi2_set_int_pin_config(const struct bmi2_int_pin_config *int_cfg, struct bmi2_dev *dev)
{

    int8_t rslt;


    uint8_t data_array[3] = { 0 };


    uint8_t reg_data = 0;


    uint8_t int_pin = 0;


    rslt = null_ptr_check(dev);
    if ((rslt == 0) && (int_cfg != 
# 2275 "../applications/bmi270/bmi2.c" 3 4
                                        ((void *)0)
# 2275 "../applications/bmi270/bmi2.c"
                                            ))
    {

        int_pin = int_cfg->pin_type;
        if ((int_pin > BMI2_INT_NONE) && (int_pin < BMI2_INT_PIN_MAX))
        {

            rslt = bmi2_get_regs(0x53, data_array, 3, dev);
            if (rslt == 0)
            {

                if ((int_pin == BMI2_INT1) || (int_pin == BMI2_INT_BOTH))
                {

     reg_data = ((data_array[0] & ~(0x02)) | ((int_cfg->pin_cfg[0].lvl << 0x01) & 0x02));


                    reg_data = ((reg_data & ~(0x04)) | ((int_cfg->pin_cfg[0].od << 0x02) & 0x04));


                    reg_data = ((reg_data & ~(0x08)) | ((int_cfg->pin_cfg[0].output_en << 0x03) & 0x08));


                    reg_data = ((reg_data & ~(0x10)) | ((int_cfg->pin_cfg[0].input_en << 0x04) & 0x10));


                    data_array[0] = reg_data;
                }


                if ((int_pin == BMI2_INT2) || (int_pin == BMI2_INT_BOTH))
                {

                    reg_data = ((data_array[1] & ~(0x02)) | ((int_cfg->pin_cfg[1].lvl << 0x01) & 0x02));


                    reg_data = ((reg_data & ~(0x04)) | ((int_cfg->pin_cfg[1].od << 0x02) & 0x04));


                    reg_data = ((reg_data & ~(0x08)) | ((int_cfg->pin_cfg[1].output_en << 0x03) & 0x08));


                    reg_data = ((reg_data & ~(0x10)) | ((int_cfg->pin_cfg[1].input_en << 0x04) & 0x10));


                    data_array[1] = reg_data;
                }


                data_array[2] = ((data_array[2] & ~(0x01)) | (int_cfg->int_latch & 0x01));





                rslt = bmi2_set_regs(0x53, data_array, 3, dev);
            }
        }
        else
        {
            rslt = -12;
        }
    }
    else
    {
        rslt = -1;
    }

    return rslt;
}







int8_t bmi2_get_int_pin_config(struct bmi2_int_pin_config *int_cfg, struct bmi2_dev *dev)
{

    int8_t rslt;


    uint8_t data_array[3] = { 0 };


    uint8_t int_pin = 0;


    rslt = null_ptr_check(dev);
    if ((rslt == 0) && (int_cfg != 
# 2365 "../applications/bmi270/bmi2.c" 3 4
                                        ((void *)0)
# 2365 "../applications/bmi270/bmi2.c"
                                            ))
    {

        int_pin = int_cfg->pin_type;


        rslt = bmi2_get_regs(0x53, data_array, 3, dev);
        if (rslt == 0)
        {

            if ((int_pin == BMI2_INT1) || (int_pin == BMI2_INT_BOTH))
            {

                int_cfg->pin_cfg[0].lvl = ((data_array[0] & (0x02)) >> (0x01));


                int_cfg->pin_cfg[0].od = ((data_array[0] & (0x04)) >> (0x02));


                int_cfg->pin_cfg[0].output_en = ((data_array[0] & (0x08)) >> (0x03));


                int_cfg->pin_cfg[0].input_en = ((data_array[0] & (0x10)) >> (0x04));
            }


            if ((int_pin == BMI2_INT2) || (int_pin == BMI2_INT_BOTH))
            {

                int_cfg->pin_cfg[1].lvl = ((data_array[1] & (0x02)) >> (0x01));


                int_cfg->pin_cfg[1].od = ((data_array[1] & (0x04)) >> (0x02));


                int_cfg->pin_cfg[1].output_en = ((data_array[1] & (0x08)) >> (0x03));


                int_cfg->pin_cfg[1].input_en = ((data_array[1] & (0x10)) >> (0x04));
            }


            int_cfg->int_latch = (data_array[2] & (0x01));
        }
    }
    else
    {
        rslt = -1;
    }

    return rslt;
}





int8_t bmi2_get_int_status(uint16_t *int_status, struct bmi2_dev *dev)
{

    int8_t rslt;


    uint8_t data_array[2] = { 0 };


    rslt = null_ptr_check(dev);
    if ((rslt == 0) && (int_status != 
# 2432 "../applications/bmi270/bmi2.c" 3 4
                                           ((void *)0)
# 2432 "../applications/bmi270/bmi2.c"
                                               ))
    {

        rslt = bmi2_get_regs(0x1C, data_array, 2, dev);
        if (rslt == 0)
        {
            *int_status = (uint16_t) data_array[0] | ((uint16_t) data_array[1] << 8);
        }
    }
    else
    {
        rslt = -1;
    }

    return rslt;
}




int8_t bmi2_sensor_enable(const uint8_t *sens_list, uint8_t n_sens, struct bmi2_dev *dev)
{

    int8_t rslt;


    uint64_t sensor_sel = 0;


    rslt = null_ptr_check(dev);
    if ((rslt == 0) && (sens_list != 
# 2462 "../applications/bmi270/bmi2.c" 3 4
                                          ((void *)0)
# 2462 "../applications/bmi270/bmi2.c"
                                              ))
    {

        rslt = select_sensor(sens_list, n_sens, &sensor_sel);
        if (rslt == 0)
        {

            rslt = sensor_enable(sensor_sel, dev);
        }
    }
    else
    {
        rslt = -1;
    }

    return rslt;
}




int8_t bmi2_sensor_disable(const uint8_t *sens_list, uint8_t n_sens, struct bmi2_dev *dev)
{

    int8_t rslt;


    uint64_t sensor_sel = 0;


    rslt = null_ptr_check(dev);
    if ((rslt == 0) && (sens_list != 
# 2493 "../applications/bmi270/bmi2.c" 3 4
                                          ((void *)0)
# 2493 "../applications/bmi270/bmi2.c"
                                              ))
    {

        rslt = select_sensor(sens_list, n_sens, &sensor_sel);
        if (rslt == 0)
        {

            rslt = sensor_disable(sensor_sel, dev);
        }
    }
    else
    {
        rslt = -1;
    }

    return rslt;
}




int8_t bmi2_set_sensor_config(struct bmi2_sens_config *sens_cfg, uint8_t n_sens, struct bmi2_dev *dev)
{

    int8_t rslt;


    uint8_t loop;


    uint8_t aps_stat = 0;


    rslt = null_ptr_check(dev);
    if ((rslt == 0) && (sens_cfg != 
# 2527 "../applications/bmi270/bmi2.c" 3 4
                                         ((void *)0)
# 2527 "../applications/bmi270/bmi2.c"
                                             ))
    {

        aps_stat = dev->aps_status;

        for (loop = 0; loop < n_sens; loop++)
        {



            if (aps_stat == 1)
            {



                rslt = bmi2_set_adv_power_save(0, dev);
            }

            if (rslt == 0)
            {
                switch (sens_cfg[loop].type)
                {

                    case 0:
                        rslt = set_accel_config(&sens_cfg[loop].cfg.acc, dev);
                        break;


                    case 1:
                        rslt = set_gyro_config(&sens_cfg[loop].cfg.gyr, dev);
                        break;


                    case 2:
                        rslt = set_aux_config(&sens_cfg[loop].cfg.aux, dev);
                        break;


                    case 9:
                        rslt = set_gyro_user_gain_config(&sens_cfg[loop].cfg.gyro_gain_update, dev);
                        break;

                    default:
                        rslt = -8;
                        break;
                }
            }


            if (rslt != 0)
            {
                break;
            }
        }




        if ((aps_stat == 1) && (rslt == 0))
        {
            rslt = bmi2_set_adv_power_save(1, dev);
        }
    }
    else
    {
        rslt = -1;
    }

    return rslt;
}




int8_t bmi2_get_sensor_config(struct bmi2_sens_config *sens_cfg, uint8_t n_sens, struct bmi2_dev *dev)
{

    int8_t rslt;


    uint8_t loop;


    uint8_t aps_stat = 0;


    rslt = null_ptr_check(dev);
    if ((rslt == 0) && (sens_cfg != 
# 2614 "../applications/bmi270/bmi2.c" 3 4
                                         ((void *)0)
# 2614 "../applications/bmi270/bmi2.c"
                                             ))
    {

        aps_stat = dev->aps_status;
        for (loop = 0; loop < n_sens; loop++)
        {



            if ((sens_cfg[loop].type >= 4) || (sens_cfg[loop].type == 2))
            {

                if (aps_stat == 1)
                {



                    rslt = bmi2_set_adv_power_save(0, dev);
                }
            }

            if (rslt == 0)
            {
                switch (sens_cfg[loop].type)
                {

                    case 0:
                        rslt = get_accel_config(&sens_cfg[loop].cfg.acc, dev);
                        break;


                    case 1:
                        rslt = get_gyro_config(&sens_cfg[loop].cfg.gyr, dev);
                        break;


                    case 2:
                        rslt = get_aux_config(&sens_cfg[loop].cfg.aux, dev);
                        break;


                    case 9:
                        rslt = get_gyro_gain_update_config(&sens_cfg[loop].cfg.gyro_gain_update, dev);
                        break;

                    default:
                        rslt = -8;
                        break;
                }
            }


            if (rslt != 0)
            {
                break;
            }
        }




        if ((aps_stat == 1) && (rslt == 0))
        {
            rslt = bmi2_set_adv_power_save(1, dev);
        }
    }
    else
    {
        rslt = -1;
    }

    return rslt;
}




int8_t bmi2_get_feature_data(struct bmi2_feat_sensor_data *feat_sensor_data, uint8_t n_sens, struct bmi2_dev *dev)
{

    int8_t rslt;


    uint8_t loop;


    uint8_t aps_stat = 0;


    rslt = null_ptr_check(dev);
    if ((rslt == 0) && (feat_sensor_data != 
# 2704 "../applications/bmi270/bmi2.c" 3 4
                                                 ((void *)0)
# 2704 "../applications/bmi270/bmi2.c"
                                                     ))
    {

        aps_stat = dev->aps_status;
        for (loop = 0; loop < n_sens; loop++)
        {



            if (feat_sensor_data[loop].type >= 4)
            {
                if (aps_stat == 1)
                {



                    rslt = bmi2_set_adv_power_save(0, dev);
                }
            }

            if (rslt == 0)
            {
                switch (feat_sensor_data[loop].type)
                {
                    case 41:


                        rslt = get_gyro_cross_sense(&feat_sensor_data[loop].sens_data.correction_factor_zx, dev);
                        break;

                    case 9:


                        rslt =
                            get_gyro_gain_update_status(&feat_sensor_data[loop].sens_data.gyro_user_gain_status, dev);
                        break;
                    default:
                        rslt = -8;
                        break;
                }


                if (rslt != 0)
                {
                    break;
                }
            }




            if ((aps_stat == 1) && (rslt == 0))
            {
                rslt = bmi2_set_adv_power_save(1, dev);
            }
        }
    }
    else
    {
        rslt = -1;
    }

    return rslt;
}





int8_t bmi2_get_sensor_data(struct bmi2_sens_data *data, struct bmi2_dev *dev)
{

    int8_t rslt;

    uint8_t reg_data = 0;

    uint8_t aux_len = 0, acc_len = 0, gyr_len = 0;


    uint8_t sensor_data[20] = { 0 };


    rslt = null_ptr_check(dev);
    if ((rslt == 0) && (data != 
# 2787 "../applications/bmi270/bmi2.c" 3 4
                                     ((void *)0)
# 2787 "../applications/bmi270/bmi2.c"
                                         ))
    {
        rslt = bmi2_get_regs(0x7D, &reg_data, 1, dev);

        if (rslt == 0)
        {

            if (reg_data & 0x01)
            {
                aux_len = 8;
            }


            if (reg_data & 0x04)
            {
                acc_len = aux_len + 6;
            }


            if (reg_data & 0x02)
            {
                gyr_len = aux_len + acc_len + 6;
            }


            rslt = read_sensor_data(aux_len, acc_len, gyr_len, sensor_data, dev);

            if (rslt == 0)
            {

                rslt = parse_data(aux_len, acc_len, gyr_len, data, sensor_data, dev);
            }
        }
    }
    else
    {
        rslt = -1;
    }

    return rslt;
}




int8_t bmi2_set_fifo_config(uint16_t config, uint8_t enable, struct bmi2_dev *dev)
{
    int8_t rslt;
    uint8_t data[2] = { 0 };
    uint8_t max_burst_len = 0;


    uint8_t fifo_config_0 = (uint8_t)(config & 0x0003);


    uint8_t fifo_config_1 = (uint8_t)((config & 0xFF00) >> 8);

    rslt = null_ptr_check(dev);
    if (rslt == 0)
    {
        rslt = bmi2_get_regs(0x48, data, 2, dev);
        if (rslt == 0)
        {

            if (fifo_config_0 > 0)
            {
                if (enable == 1)
                {
                    data[0] = data[0] | fifo_config_0;
                }
                else
                {
                    data[0] = data[0] & (~fifo_config_0);
                }
            }


            if (enable == 1)
            {
                data[1] = data[1] | fifo_config_1;
                if (dev->variant_feature & 0x01)
                {




                    rslt = get_maxburst_len(&max_burst_len, dev);
                    if (rslt == 0 && max_burst_len == 0)
                    {
                        rslt = set_maxburst_len(2, dev);
                    }
                }
            }
            else
            {
                data[1] = data[1] & (~fifo_config_1);
            }


            if (rslt == 0)
            {
                rslt = bmi2_set_regs(0x48, data, 2, dev);
            }
        }
    }

    return rslt;
}




int8_t bmi2_get_fifo_config(uint16_t *fifo_config, struct bmi2_dev *dev)
{

    int8_t rslt;


    uint8_t data[2] = { 0 };


    rslt = null_ptr_check(dev);
    if ((rslt == 0) && (fifo_config != 
# 2909 "../applications/bmi270/bmi2.c" 3 4
                                            ((void *)0)
# 2909 "../applications/bmi270/bmi2.c"
                                                ))
    {

        rslt = bmi2_get_regs(0x48, data, 2, dev);
        if (rslt == 0)
        {
            (*fifo_config) = (uint16_t)((uint16_t) data[0] & 0x0003);
            (*fifo_config) |= (uint16_t)(((uint16_t) data[1] << 8) & 0xFF00);
        }
    }
    else
    {
        rslt = -1;
    }

    return rslt;
}






int8_t bmi2_read_fifo_data(struct bmi2_fifo_frame *fifo, struct bmi2_dev *dev)
{

    int8_t rslt;


    uint8_t config_data[2] = { 0 };


    uint8_t addr = 0x26;


    rslt = null_ptr_check(dev);
    if ((rslt == 0) && (fifo != 
# 2945 "../applications/bmi270/bmi2.c" 3 4
                                     ((void *)0)
# 2945 "../applications/bmi270/bmi2.c"
                                         ))
    {

        reset_fifo_frame_structure(fifo, dev);


        if (dev->intf == BMI2_SPI_INTF)
        {
            addr = (addr | 0x80);
        }


        dev->intf_rslt = dev->read(addr, fifo->data, (uint32_t)fifo->length, dev->intf_ptr);


        if (dev->aps_status == 1)
        {
            dev->delay_us(450, dev->intf_ptr);
        }
        else
        {
            dev->delay_us(2, dev->intf_ptr);
        }


        if (dev->intf_rslt != 0)
        {
            rslt = -2;
        }

        if (rslt == 0)
        {

            rslt = bmi2_get_regs(0x48, config_data, 2, dev);
            if (rslt == 0)
            {

                fifo->header_enable = (uint8_t)((config_data[1]) & (0x1000 >> 8));


                fifo->data_enable =
                    (uint16_t)(((config_data[0]) | ((uint16_t) config_data[1] << 8)) & 0xE000);
            }
        }
        else
        {
            rslt = -2;
        }
    }
    else
    {
        rslt = -1;
    }

    return rslt;
}






int8_t bmi2_extract_accel(struct bmi2_sens_axes_data *accel_data,
                          uint16_t *accel_length,
                          struct bmi2_fifo_frame *fifo,
                          const struct bmi2_dev *dev)
{

    int8_t rslt;


    rslt = null_ptr_check(dev);

    if ((rslt == 0) && (accel_data != 
# 3018 "../applications/bmi270/bmi2.c" 3 4
                                           ((void *)0)
# 3018 "../applications/bmi270/bmi2.c"
                                               ) && (accel_length != 
# 3018 "../applications/bmi270/bmi2.c" 3 4
                                                                     ((void *)0)
# 3018 "../applications/bmi270/bmi2.c"
                                                                         ) && (fifo != 
# 3018 "../applications/bmi270/bmi2.c" 3 4
                                                                                       ((void *)0)
# 3018 "../applications/bmi270/bmi2.c"
                                                                                           ))
    {



        if (fifo->acc_byte_start_idx == 0)
        {

            fifo->acc_byte_start_idx = dev->dummy_byte;
        }


        if (fifo->header_enable == 0)
        {

            rslt = extract_accel_headerless_mode(accel_data, accel_length, fifo, dev);
        }
        else
        {

            rslt = extract_accel_header_mode(accel_data, accel_length, fifo, dev);
        }
    }
    else
    {
        rslt = -1;
    }

    return rslt;
}






int8_t bmi2_extract_gyro(struct bmi2_sens_axes_data *gyro_data,
                         uint16_t *gyro_length,
                         struct bmi2_fifo_frame *fifo,
                         const struct bmi2_dev *dev)
{

    int8_t rslt;


    rslt = null_ptr_check(dev);
    if ((rslt == 0) && (gyro_data != 
# 3064 "../applications/bmi270/bmi2.c" 3 4
                                          ((void *)0)
# 3064 "../applications/bmi270/bmi2.c"
                                              ) && (gyro_length != 
# 3064 "../applications/bmi270/bmi2.c" 3 4
                                                                   ((void *)0)
# 3064 "../applications/bmi270/bmi2.c"
                                                                       ) && (fifo != 
# 3064 "../applications/bmi270/bmi2.c" 3 4
                                                                                     ((void *)0)
# 3064 "../applications/bmi270/bmi2.c"
                                                                                         ))
    {



        if (fifo->gyr_byte_start_idx == 0)
        {

            fifo->gyr_byte_start_idx = dev->dummy_byte;
        }


        if (fifo->header_enable == 0)
        {

            rslt = extract_gyro_headerless_mode(gyro_data, gyro_length, fifo, dev);
        }
        else
        {

            rslt = extract_gyro_header_mode(gyro_data, gyro_length, fifo, dev);
        }
    }
    else
    {
        rslt = -1;
    }

    return rslt;
}





int8_t bmi2_extract_aux(struct bmi2_aux_fifo_data *aux,
                        uint16_t *aux_length,
                        struct bmi2_fifo_frame *fifo,
                        const struct bmi2_dev *dev)
{

    int8_t rslt;


    rslt = null_ptr_check(dev);
    if ((rslt == 0) && (aux != 
# 3109 "../applications/bmi270/bmi2.c" 3 4
                                    ((void *)0)
# 3109 "../applications/bmi270/bmi2.c"
                                        ) && (aux_length != 
# 3109 "../applications/bmi270/bmi2.c" 3 4
                                                            ((void *)0)
# 3109 "../applications/bmi270/bmi2.c"
                                                                ) && (fifo != 
# 3109 "../applications/bmi270/bmi2.c" 3 4
                                                                              ((void *)0)
# 3109 "../applications/bmi270/bmi2.c"
                                                                                  ))
    {



        if (fifo->aux_byte_start_idx == 0)
        {

            fifo->aux_byte_start_idx = dev->dummy_byte;
        }


        if (fifo->header_enable == 0)
        {

            rslt = extract_aux_headerless_mode(aux, aux_length, fifo, dev);
        }
        else
        {

            rslt = extract_aux_header_mode(aux, aux_length, fifo, dev);
        }
    }
    else
    {
        rslt = -1;
    }

    return rslt;
}




int8_t bmi2_set_command_register(uint8_t command, struct bmi2_dev *dev)
{

    int8_t rslt;


    rslt = null_ptr_check(dev);
    if (rslt == 0)
    {

        rslt = bmi2_set_regs(0x7E, &command, 1, dev);
    }

    return rslt;
}




int8_t bmi2_set_fifo_self_wake_up(uint8_t fifo_self_wake_up, struct bmi2_dev *dev)
{

    int8_t rslt;


    uint8_t data = 0;


    rslt = null_ptr_check(dev);
    if (rslt == 0)
    {

        rslt = bmi2_get_regs(0x7C, &data, 1, dev);
        if (rslt == 0)
        {
            data = ((data & ~(0x02)) | ((fifo_self_wake_up << 0x01) & 0x02));
            rslt = bmi2_set_regs(0x7C, &data, 1, dev);
        }
    }

    return rslt;
}





int8_t bmi2_get_fifo_self_wake_up(uint8_t *fifo_self_wake_up, struct bmi2_dev *dev)
{

    int8_t rslt;


    uint8_t data = 0;


    rslt = null_ptr_check(dev);
    if ((rslt == 0) && (fifo_self_wake_up != 
# 3200 "../applications/bmi270/bmi2.c" 3 4
                                                  ((void *)0)
# 3200 "../applications/bmi270/bmi2.c"
                                                      ))
    {

        rslt = bmi2_get_regs(0x7C, &data, 1, dev);
        if (rslt == 0)
        {
            (*fifo_self_wake_up) = ((data & (0x02)) >> (0x01));
        }
    }
    else
    {
        rslt = -1;
    }

    return rslt;
}




int8_t bmi2_set_fifo_wm(uint16_t fifo_wm, struct bmi2_dev *dev)
{

    int8_t rslt;


    uint8_t data[2] = { 0 };


    rslt = null_ptr_check(dev);
    if (rslt == 0)
    {

        data[0] = (uint8_t)(fifo_wm & 0x00FF);


        data[1] = (uint8_t)((fifo_wm & 0xFF00) >> 8);


        rslt = bmi2_set_regs(0x46, data, 2, dev);
    }

    return rslt;
}




int8_t bmi2_get_fifo_wm(uint16_t *fifo_wm, struct bmi2_dev *dev)
{

    int8_t rslt;


    uint8_t data[2] = { 0 };


    rslt = null_ptr_check(dev);
    if ((rslt == 0) && (fifo_wm != 
# 3258 "../applications/bmi270/bmi2.c" 3 4
                                        ((void *)0)
# 3258 "../applications/bmi270/bmi2.c"
                                            ))
    {

        rslt = bmi2_get_regs(0x46, data, 2, dev);
        if (rslt == 0)
        {
            (*fifo_wm) = (uint16_t)((uint16_t) data[1] << 8) | (data[0]);
        }
    }
    else
    {
        rslt = -1;
    }

    return rslt;
}





int8_t bmi2_set_fifo_filter_data(uint8_t sens_sel, uint8_t fifo_filter_data, struct bmi2_dev *dev)
{

    int8_t rslt;


    uint8_t data = 0;


    rslt = null_ptr_check(dev);
    if (rslt == 0)
    {
        switch (sens_sel)
        {
            case 0:


                if (fifo_filter_data <= 1)
                {

                    rslt = bmi2_get_regs(0x45, &data, 1, dev);
                    if (rslt == 0)
                    {
                        data = ((data & ~(0x80)) | ((fifo_filter_data << 0x07) & 0x80));
                        rslt = bmi2_set_regs(0x45, &data, 1, dev);
                    }
                }
                else
                {
                    rslt = -4;
                }

                break;
            case 1:


                if (fifo_filter_data <= 1)
                {

                    rslt = bmi2_get_regs(0x45, &data, 1, dev);
                    if (rslt == 0)
                    {
                        data = ((data & ~(0x08)) | ((fifo_filter_data << 0x03) & 0x08));
                        rslt = bmi2_set_regs(0x45, &data, 1, dev);
                    }
                }
                else
                {
                    rslt = -4;
                }

                break;
            default:
                rslt = -8;
                break;
        }
    }

    return rslt;
}




int8_t bmi2_get_fifo_filter_data(uint8_t sens_sel, uint8_t *fifo_filter_data, struct bmi2_dev *dev)
{

    int8_t rslt;


    uint8_t data = 0;


    rslt = null_ptr_check(dev);
    if ((rslt == 0) && (fifo_filter_data != 
# 3353 "../applications/bmi270/bmi2.c" 3 4
                                                 ((void *)0)
# 3353 "../applications/bmi270/bmi2.c"
                                                     ))
    {
        switch (sens_sel)
        {
            case 0:


                rslt = bmi2_get_regs(0x45, &data, 1, dev);
                if (rslt == 0)
                {
                    (*fifo_filter_data) = ((data & (0x80)) >> (0x07));
                }

                break;
            case 1:


                rslt = bmi2_get_regs(0x45, &data, 1, dev);
                if (rslt == 0)
                {
                    (*fifo_filter_data) = ((data & (0x08)) >> (0x03));
                }

                break;
            default:
                rslt = -8;
                break;
        }
    }
    else
    {
        rslt = -1;
    }

    return rslt;
}





int8_t bmi2_set_fifo_down_sample(uint8_t sens_sel, uint8_t fifo_down_samp, struct bmi2_dev *dev)
{

    int8_t rslt;


    uint8_t data = 0;


    rslt = null_ptr_check(dev);
    if (rslt == 0)
    {
        switch (sens_sel)
        {
            case 0:


                rslt = bmi2_get_regs(0x45, &data, 1, dev);
                if (rslt == 0)
                {
                    data = ((data & ~(0x70)) | ((fifo_down_samp << 0x04) & 0x70));
                    rslt = bmi2_set_regs(0x45, &data, 1, dev);
                }

                break;
            case 1:


                rslt = bmi2_get_regs(0x45, &data, 1, dev);
                if (rslt == 0)
                {
                    data = ((data & ~(0x07)) | (fifo_down_samp & 0x07));
                    rslt = bmi2_set_regs(0x45, &data, 1, dev);
                }

                break;
            default:
                rslt = -8;
                break;
        }
    }

    return rslt;
}





int8_t bmi2_get_fifo_down_sample(uint8_t sens_sel, uint8_t *fifo_down_samp, struct bmi2_dev *dev)
{

    int8_t rslt;


    uint8_t data = 0;


    rslt = null_ptr_check(dev);
    if ((rslt == 0) && (fifo_down_samp != 
# 3453 "../applications/bmi270/bmi2.c" 3 4
                                               ((void *)0)
# 3453 "../applications/bmi270/bmi2.c"
                                                   ))
    {
        switch (sens_sel)
        {
            case 0:


                rslt = bmi2_get_regs(0x45, &data, 1, dev);
                if (rslt == 0)
                {
                    (*fifo_down_samp) = ((data & (0x70)) >> (0x04));
                }

                break;
            case 1:


                rslt = bmi2_get_regs(0x45, &data, 1, dev);
                if (rslt == 0)
                {
                    (*fifo_down_samp) = (data & (0x07));
                }

                break;
            default:
                rslt = -8;
                break;
        }
    }
    else
    {
        rslt = -1;
    }

    return rslt;
}





int8_t bmi2_get_fifo_length(uint16_t *fifo_length, struct bmi2_dev *dev)
{

    int8_t rslt;


    uint8_t index = 0;


    uint8_t data[2] = { 0 };


    rslt = null_ptr_check(dev);
    if ((rslt == 0) && (fifo_length != 
# 3507 "../applications/bmi270/bmi2.c" 3 4
                                            ((void *)0)
# 3507 "../applications/bmi270/bmi2.c"
                                                ))
    {

        rslt = bmi2_get_regs(0x24, data, 2, dev);
        if (rslt == 0)
        {

            index = 1;


            data[index] = (data[index] & (0x3F));


            (*fifo_length) = ((data[index] << 8) | data[index - 1]);
        }
    }
    else
    {
        rslt = -1;
    }

    return rslt;
}







int8_t bmi2_read_aux_man_mode(uint8_t reg_addr, uint8_t *aux_data, uint16_t len, struct bmi2_dev *dev)
{

    int8_t rslt;


    uint8_t burst_len = 0;


    uint8_t aps_stat = 0;


    rslt = null_ptr_check(dev);
    if ((rslt == 0) && (aux_data != 
# 3550 "../applications/bmi270/bmi2.c" 3 4
                                         ((void *)0)
# 3550 "../applications/bmi270/bmi2.c"
                                             ))
    {

        if (dev->aux_man_en)
        {

            aps_stat = dev->aps_status;
            if (aps_stat == 1)
            {

                rslt = bmi2_set_adv_power_save(0, dev);
            }

            if (rslt == 0)
            {



                rslt = map_read_len(&burst_len, dev);
                if (rslt == 0)
                {

                    rslt = read_aux_data(reg_addr, aux_data, len, burst_len, dev);
                }
            }




            if ((rslt == 0) && (aps_stat == 1))
            {
                rslt = bmi2_set_adv_power_save(1, dev);
            }
        }
        else
        {
            rslt = -14;
        }
    }
    else
    {
        rslt = -1;
    }

    return rslt;
}







int8_t bmi2_write_aux_man_mode(uint8_t reg_addr, const uint8_t *aux_data, uint16_t len, struct bmi2_dev *dev)
{

    int8_t rslt;


    uint8_t loop = 0;


    uint8_t aps_stat = 0;


    rslt = null_ptr_check(dev);
    if ((rslt == 0) && (aux_data != 
# 3616 "../applications/bmi270/bmi2.c" 3 4
                                         ((void *)0)
# 3616 "../applications/bmi270/bmi2.c"
                                             ))
    {

        if (dev->aux_man_en)
        {

            aps_stat = dev->aps_status;
            if (aps_stat == 1)
            {

                rslt = bmi2_set_adv_power_save(0, dev);
            }


            if (rslt == 0)
            {
                for (; ((loop < len) && (rslt == 0)); loop++)
                {
                    rslt = write_aux_data((reg_addr + loop), aux_data[loop], dev);
                    dev->delay_us(1000, dev->intf_ptr);
                }
            }




            if ((rslt == 0) && (aps_stat == 1))
            {
                rslt = bmi2_set_adv_power_save(1, dev);
            }
        }
        else
        {
            rslt = -14;
        }
    }
    else
    {
        rslt = -1;
    }

    return rslt;
}





int8_t bmi2_get_status(uint8_t *status, struct bmi2_dev *dev)
{

    int8_t rslt;


    rslt = null_ptr_check(dev);
    if ((rslt == 0) && (status != 
# 3671 "../applications/bmi270/bmi2.c" 3 4
                                       ((void *)0)
# 3671 "../applications/bmi270/bmi2.c"
                                           ))
    {
        rslt = bmi2_get_regs(0x03, status, 1, dev);
    }
    else
    {
        rslt = -1;
    }

    return rslt;
}




int8_t bmi2_set_ois_interface(uint8_t enable, struct bmi2_dev *dev)
{

    int8_t rslt;


    uint8_t reg_data = 0;


    rslt = null_ptr_check(dev);
    if (rslt == 0)
    {
        rslt = bmi2_get_regs(0x6B, &reg_data, 1, dev);
        if (rslt == 0)
        {

            reg_data = ((reg_data & ~(0x10)) | ((enable << 0x04) & 0x10));
            if (enable)
            {

                reg_data = (reg_data & ~(0x20));
            }


            rslt = bmi2_set_regs(0x6B, &reg_data, 1, dev);
        }
    }

    return rslt;
}





int8_t bmi2_write_sync_commands(const uint8_t *command, uint8_t n_comm, struct bmi2_dev *dev)
{

    int8_t rslt;


    rslt = null_ptr_check(dev);
    if ((rslt == 0) && (command != 
# 3728 "../applications/bmi270/bmi2.c" 3 4
                                        ((void *)0)
# 3728 "../applications/bmi270/bmi2.c"
                                            ))
    {
        rslt = bmi2_set_regs(0x1E, command, n_comm, dev);
    }
    else
    {
        rslt = -1;
    }

    return rslt;
}





int8_t bmi2_perform_accel_self_test(struct bmi2_dev *dev)
{

    int8_t rslt;


    int8_t st_rslt = 0;


    struct bmi2_sens_axes_data positive = { 0, 0, 0, 0 };


    struct bmi2_sens_axes_data negative = { 0, 0, 0, 0 };


    struct bmi2_selftest_delta_limit accel_data_diff = { 0, 0, 0 };


    struct bmi2_selftest_delta_limit accel_data_diff_mg = { 0, 0, 0 };


    int8_t sign = 1;


    rslt = null_ptr_check(dev);
    if (rslt == 0)
    {

        rslt = pre_self_test_config(dev);


        dev->delay_us(3000, dev->intf_ptr);
        if (rslt == 0)
        {
            do
            {



                rslt = self_test_config((uint8_t) sign, dev);
                if (rslt == 0)
                {

                    dev->delay_us(51000, dev->intf_ptr);


                    if (sign == 1)
                    {

                        rslt = read_accel_xyz(&positive, dev);
                    }

                    else if (sign == 0)
                    {

                        rslt = read_accel_xyz(&negative, dev);
                    }
                }
                else
                {

                    break;
                }


                if (rslt != 0)
                {
                    break;
                }


                sign--;
            } while (sign >= 0);
            if (rslt == 0)
            {

                accel_data_diff.x = (positive.x) - (negative.x);
                accel_data_diff.y = (positive.y) - (negative.y);
                accel_data_diff.z = (positive.z) - (negative.z);




                convert_lsb_g(&accel_data_diff, &accel_data_diff_mg, dev);




                st_rslt = validate_self_test(&accel_data_diff_mg);


                rslt = bmi2_soft_reset(dev);


                if (rslt == 0)
                {
                    rslt = st_rslt;
                }
            }
        }
    }

    return rslt;
}




int8_t bmi2_map_feat_int(uint8_t type, enum bmi2_hw_int_pin hw_int_pin, struct bmi2_dev *dev)
{

    int8_t rslt;


    uint8_t feat_int = 0;


    uint8_t data_array[2] = { 0 };


    struct bmi2_map_int map_int = { 0 };


    rslt = null_ptr_check(dev);
    if (rslt == 0)
    {

        rslt = bmi2_get_regs(0x56, data_array, 2, dev);

        if (rslt == 0)
        {

            extract_feat_int_map(&map_int, type, dev);

            feat_int = map_int.sens_map_int;


            rslt = map_feat_int(data_array, hw_int_pin, feat_int);


            if (rslt == 0)
            {
                rslt = bmi2_set_regs(0x56, &data_array[0], 1, dev);
                if (rslt == 0)
                {
                    rslt = bmi2_set_regs(0x57, &data_array[1], 1, dev);
                }
            }
        }
    }
    else
    {
        rslt = -1;
    }

    return rslt;
}




int8_t bmi2_map_data_int(uint8_t data_int, enum bmi2_hw_int_pin int_pin, struct bmi2_dev *dev)
{

    int8_t rslt;


    uint8_t int1_mask = data_int;


    uint8_t int2_mask = (uint8_t)(data_int << 4);


    uint8_t reg_data = 0;


    rslt = bmi2_get_regs(0x58, &reg_data, 1, dev);
    if (rslt == 0)
    {
        if (int_pin < BMI2_INT_PIN_MAX)
        {
            switch (int_pin)
            {
                case BMI2_INT_NONE:




                    reg_data &= ~(int1_mask | int2_mask);
                    break;
                case BMI2_INT1:




                    reg_data |= int1_mask;
                    break;
                case BMI2_INT2:




                    reg_data |= int2_mask;
                    break;
                case BMI2_INT_BOTH:




                    reg_data |= (int1_mask | int2_mask);
                    break;
                default:
                    break;
            }


            rslt = bmi2_set_regs(0x58, &reg_data, 1, dev);
        }
        else
        {

            rslt = -12;
        }
    }

    return rslt;
}





int8_t bmi2_get_remap_axes(struct bmi2_remap *remapped_axis, struct bmi2_dev *dev)
{

    int8_t rslt;


    struct bmi2_axes_remap remap = { 0, 0, 0, 0, 0, 0 };


    rslt = null_ptr_check(dev);
    if ((rslt == 0) && (remapped_axis != 
# 3986 "../applications/bmi270/bmi2.c" 3 4
                                              ((void *)0)
# 3986 "../applications/bmi270/bmi2.c"
                                                  ))
    {

        rslt = get_remap_axes(&remap, dev);
        if (rslt == 0)
        {



            switch (remap.x_axis)
            {
                case 0x00:


                    dev->remap.x_axis = 0x00;
                    remapped_axis->x = 0x01;
                    break;
                case 0x01:


                    dev->remap.x_axis = 0x01;
                    remapped_axis->x = 0x02;
                    break;
                case 0x02:


                    dev->remap.x_axis = 0x02;
                    remapped_axis->x = 0x04;
                    break;
                default:
                    break;
            }




            if (remap.x_axis_sign)
            {

                dev->remap.x_axis_sign = 1;
                remapped_axis->x |= 0x08;
            }
            else
            {
                dev->remap.x_axis_sign = 0;
            }




            switch (remap.y_axis)
            {
                case 0x00:


                    dev->remap.y_axis = 0x00;
                    remapped_axis->y = 0x01;
                    break;
                case 0x01:


                    dev->remap.y_axis = 0x01;
                    remapped_axis->y = 0x02;
                    break;
                case 0x02:


                    dev->remap.y_axis = 0x02;
                    remapped_axis->y = 0x04;
                    break;
                default:
                    break;
            }




            if (remap.y_axis_sign)
            {

                dev->remap.y_axis_sign = 1;
                remapped_axis->y |= 0x08;
            }
            else
            {
                dev->remap.y_axis_sign = 0;
            }




            switch (remap.z_axis)
            {
                case 0x00:


                    dev->remap.z_axis = 0x00;
                    remapped_axis->z = 0x01;
                    break;
                case 0x01:


                    dev->remap.z_axis = 0x01;
                    remapped_axis->z = 0x02;
                    break;
                case 0x02:


                    dev->remap.z_axis = 0x02;
                    remapped_axis->z = 0x04;
                    break;
                default:
                    break;
            }




            if (remap.z_axis_sign)
            {

                dev->remap.z_axis_sign = 1;
                remapped_axis->z |= 0x08;
            }
            else
            {
                dev->remap.z_axis_sign = 0;
            }
        }
    }
    else
    {
        rslt = -1;
    }

    return rslt;
}





int8_t bmi2_set_remap_axes(const struct bmi2_remap *remapped_axis, struct bmi2_dev *dev)
{

    int8_t rslt;


    uint8_t remap_axes = 0;


    uint8_t remap_x = 0;


    uint8_t remap_y = 0;


    uint8_t remap_z = 0;


    struct bmi2_axes_remap remap = { 0, 0, 0, 0, 0, 0 };


    rslt = null_ptr_check(dev);
    if ((rslt == 0) && (remapped_axis != 
# 4150 "../applications/bmi270/bmi2.c" 3 4
                                              ((void *)0)
# 4150 "../applications/bmi270/bmi2.c"
                                                  ))
    {

        remap_axes = remapped_axis->x | remapped_axis->y | remapped_axis->z;


        if ((remap_axes & 0x07) == 0x07)
        {

            remap_x = remapped_axis->x & 0x07;
            remap_y = remapped_axis->y & 0x07;
            remap_z = remapped_axis->z & 0x07;




            switch (remap_x)
            {
                case 0x01:


                    dev->remap.x_axis = 0x00;
                    remap.x_axis = 0x00;
                    break;
                case 0x02:


                    dev->remap.x_axis = 0x01;
                    remap.x_axis = 0x01;
                    break;
                case 0x04:


                    dev->remap.x_axis = 0x02;
                    remap.x_axis = 0x02;
                    break;
                default:
                    break;
            }




            if (remapped_axis->x & 0x08)
            {

                dev->remap.x_axis_sign = 1;
                remap.x_axis_sign = 0x01;
            }
            else
            {
                dev->remap.x_axis_sign = 0;
                remap.x_axis_sign = 0x00;
            }




            switch (remap_y)
            {
                case 0x01:


                    dev->remap.y_axis = 0x00;
                    remap.y_axis = 0x00;
                    break;
                case 0x02:


                    dev->remap.y_axis = 0x01;
                    remap.y_axis = 0x01;
                    break;
                case 0x04:


                    dev->remap.y_axis = 0x02;
                    remap.y_axis = 0x02;
                    break;
                default:
                    break;
            }




            if (remapped_axis->y & 0x08)
            {

                dev->remap.y_axis_sign = 1;
                remap.y_axis_sign = 0x01;
            }
            else
            {
                dev->remap.y_axis_sign = 0;
                remap.y_axis_sign = 0x00;
            }




            switch (remap_z)
            {
                case 0x01:


                    dev->remap.z_axis = 0x00;
                    remap.z_axis = 0x00;
                    break;
                case 0x02:


                    dev->remap.z_axis = 0x01;
                    remap.z_axis = 0x01;
                    break;
                case 0x04:


                    dev->remap.z_axis = 0x02;
                    remap.z_axis = 0x02;
                    break;
                default:
                    break;
            }




            if (remapped_axis->z & 0x08)
            {

                dev->remap.z_axis_sign = 1;
                remap.z_axis_sign = 0x01;
            }
            else
            {
                dev->remap.z_axis_sign = 0;
                remap.z_axis_sign = 0x00;
            }


            rslt = set_remap_axes(&remap, dev);
        }
        else
        {
            rslt = -17;
        }
    }
    else
    {
        rslt = -1;
    }

    return rslt;
}





int8_t bmi2_set_gyro_offset_comp(uint8_t enable, struct bmi2_dev *dev)
{

    int8_t rslt;


    uint8_t reg_data = 0;


    rslt = null_ptr_check(dev);
    if (rslt == 0)
    {

        rslt = bmi2_get_regs(0x77, &reg_data, 1, dev);
        if (rslt == 0)
        {
            reg_data = ((reg_data & ~(0x40)) | ((enable << 0x06) & 0x40));


            rslt = bmi2_set_regs(0x77, &reg_data, 1, dev);
        }
    }
    else
    {
        rslt = -1;
    }

    return rslt;
}





int8_t bmi2_read_gyro_offset_comp_axes(struct bmi2_sens_axes_data *gyr_off_comp_axes, struct bmi2_dev *dev)
{

    int8_t rslt;


    uint8_t reg_data[4] = { 0 };


    uint8_t gyr_off_lsb_x;


    uint8_t gyr_off_lsb_y;


    uint8_t gyr_off_lsb_z;


    uint8_t gyr_off_msb_x;


    uint8_t gyr_off_msb_y;


    uint8_t gyr_off_msb_z;


    rslt = null_ptr_check(dev);
    if ((rslt == 0) && (gyr_off_comp_axes != 
# 4371 "../applications/bmi270/bmi2.c" 3 4
                                                  ((void *)0)
# 4371 "../applications/bmi270/bmi2.c"
                                                      ))
    {

        rslt = bmi2_get_regs(0x74, reg_data, 4, dev);
        if (rslt == 0)
        {



            gyr_off_lsb_x = reg_data[0];
            gyr_off_lsb_y = reg_data[1];
            gyr_off_lsb_z = reg_data[2];
            gyr_off_msb_x = reg_data[3] & 0x03;
            gyr_off_msb_y = reg_data[3] & 0x0C;
            gyr_off_msb_z = reg_data[3] & 0x30;


            gyr_off_comp_axes->x = (int16_t)(((uint16_t) gyr_off_msb_x << 8) | gyr_off_lsb_x);


            gyr_off_comp_axes->y = (int16_t)(((uint16_t) gyr_off_msb_y << 6) | gyr_off_lsb_y);


            gyr_off_comp_axes->z = (int16_t)(((uint16_t) gyr_off_msb_z << 4) | gyr_off_lsb_z);
        }
    }
    else
    {
        rslt = -1;
    }

    return rslt;
}





int8_t bmi2_write_gyro_offset_comp_axes(const struct bmi2_sens_axes_data *gyr_off_comp_axes, struct bmi2_dev *dev)
{

    int8_t rslt;


    uint8_t reg_data[4] = { 0 };


    uint8_t gyr_off_msb_x;


    uint8_t gyr_off_msb_y;


    uint8_t gyr_off_msb_z;


    rslt = null_ptr_check(dev);
    if ((rslt == 0) && (gyr_off_comp_axes != 
# 4428 "../applications/bmi270/bmi2.c" 3 4
                                                  ((void *)0)
# 4428 "../applications/bmi270/bmi2.c"
                                                      ))
    {

        rslt = bmi2_get_regs(0x74, reg_data, 4, dev);

        if (rslt == 0)
        {

            gyr_off_msb_x = (uint8_t)((gyr_off_comp_axes->x & 0x0300) >> 8);


            gyr_off_msb_y = (uint8_t)((gyr_off_comp_axes->y & 0x0300) >> 8);


            gyr_off_msb_z = (uint8_t)((gyr_off_comp_axes->z & 0x0300) >> 8);


            reg_data[0] = (uint8_t)(gyr_off_comp_axes->x & 0x00FF);


            reg_data[1] = (uint8_t)(gyr_off_comp_axes->y & 0x00FF);


            reg_data[2] = (uint8_t)(gyr_off_comp_axes->z & 0x00FF);


            reg_data[3] = ((reg_data[3] & ~(0x03)) | (gyr_off_msb_x & 0x03));


            reg_data[3] = ((reg_data[3] & ~(0x0C)) | ((gyr_off_msb_y << 0x02) & 0x0C));


            reg_data[3] = ((reg_data[3] & ~(0x30)) | ((gyr_off_msb_z << 0x04) & 0x30));


            rslt = bmi2_set_regs(0x74, reg_data, 4, dev);
        }
    }
    else
    {
        rslt = -1;
    }

    return rslt;
}





int8_t bmi2_get_gyro_cross_sense(struct bmi2_dev *dev)
{

    int8_t rslt = 0;
    struct bmi2_feat_sensor_data data;


    if (dev->variant_feature & 0x02)
    {
        rslt = null_ptr_check(dev);
        if (rslt == 0)
        {

            data.type = 41;


            rslt = bmi2_get_feature_data(&data, 1, dev);
            if (rslt == 0)
            {



                dev->gyr_cross_sens_zx = data.sens_data.correction_factor_zx;
            }
        }
        else
        {
            rslt = -1;
        }
    }
    else
    {
        rslt = -8;
    }

    return rslt;
}




int8_t bmi2_get_internal_status(uint8_t *int_stat, struct bmi2_dev *dev)
{

    int8_t rslt;


    rslt = null_ptr_check(dev);
    if ((rslt == 0) && (int_stat != 
# 4526 "../applications/bmi270/bmi2.c" 3 4
                                         ((void *)0)
# 4526 "../applications/bmi270/bmi2.c"
                                             ))
    {

        dev->delay_us(140000UL, dev->intf_ptr);


        rslt = bmi2_get_regs(0x21, int_stat, 1, dev);
    }
    else
    {
        rslt = -1;
    }

    return rslt;
}




int8_t bmi2_perform_accel_foc(const struct bmi2_accel_foc_g_value *accel_g_value, struct bmi2_dev *dev)
{

    int8_t rslt;


    struct bmi2_accel_config acc_cfg = { 0, 0, 0, 0 };


    uint8_t aps = 0;


    uint8_t acc_en = 0;


    rslt = null_ptr_check(dev);
    if ((rslt == 0) && (accel_g_value != 
# 4561 "../applications/bmi270/bmi2.c" 3 4
                                              ((void *)0)
# 4561 "../applications/bmi270/bmi2.c"
                                                  ))
    {

        if ((((((accel_g_value->x) > 0 ? (accel_g_value->x) : -(accel_g_value->x))) + (((accel_g_value->y) > 0 ? (accel_g_value->y) : -(accel_g_value->y))) + (((accel_g_value->z) > 0 ? (accel_g_value->z) : -(accel_g_value->z)))) == 1) &&
            ((accel_g_value->sign == 1) || (accel_g_value->sign == 0)))
        {



            rslt = save_accel_foc_config(&acc_cfg, &aps, &acc_en, dev);


            if (rslt == 0)
            {
                rslt = set_accel_foc_config(dev);
            }


            if (rslt == 0)
            {
                rslt = perform_accel_foc(accel_g_value, &acc_cfg, dev);
            }


            if (rslt == 0)
            {
                rslt = restore_accel_foc_config(&acc_cfg, aps, acc_en, dev);
            }
        }
        else
        {
            rslt = -20;
        }
    }
    else
    {
        rslt = -1;
    }

    return rslt;
}




int8_t bmi2_perform_gyro_foc(struct bmi2_dev *dev)
{

    int8_t rslt;


    struct bmi2_gyro_config gyr_cfg = { 0, 0, 0, 0, 0, 0 };


    uint8_t aps = 0;


    uint8_t gyr_en = 0;


    struct bmi2_sens_axes_data gyr_value[128];


    struct bmi2_foc_temp_value temp = { 0, 0, 0 };


    uint8_t reg_status = 0;


    uint8_t loop = 0;


    struct bmi2_sens_axes_data gyro_offset = { 0, 0, 0, 0 };


    rslt = null_ptr_check(dev);
    if (rslt == 0)
    {



        rslt = save_gyro_config(&gyr_cfg, &aps, &gyr_en, dev);


        if (rslt == 0)
        {
            rslt = set_gyro_foc_config(dev);
        }


        if (rslt == 0)
        {
            for (loop = 0; loop < 128; loop++)
            {

                dev->delay_us(50000, dev->intf_ptr);


                rslt = bmi2_get_status(&reg_status, dev);


                if ((rslt == 0) && (reg_status & 0x40))
                {
                    rslt = read_gyro_xyz(&gyr_value[loop], dev);
                    if (rslt == 0)
                    {

                        temp.x = temp.x + (int32_t)gyr_value[loop].x;
                        temp.y = temp.y + (int32_t)gyr_value[loop].y;
                        temp.z = temp.z + (int32_t)gyr_value[loop].z;
                    }
                }

                if (rslt != 0)
                {
                    break;
                }
                else if ((reg_status & 0x40) != 0x40)
                {
                    rslt = -21;
                    break;
                }
            }

            if (rslt == 0)
            {




                gyro_offset.x = (int16_t)(temp.x / 128);
                gyro_offset.y = (int16_t)(temp.y / 128);
                gyro_offset.z = (int16_t)(temp.z / 128);





                saturate_gyro_data(&gyro_offset);


                invert_gyro_offset(&gyro_offset);




                rslt = bmi2_write_gyro_offset_comp_axes(&gyro_offset, dev);
            }


            if (rslt == 0)
            {
                rslt = bmi2_set_gyro_offset_comp(1, dev);
            }


            if (rslt == 0)
            {
                rslt = restore_gyro_config(&gyr_cfg, aps, gyr_en, dev);
            }
        }
    }

    return rslt;
}





int8_t bmi2_get_feat_config(uint8_t sw_page, uint8_t *feat_config, struct bmi2_dev *dev)
{

    int8_t rslt;


    uint8_t bytes_remain = 16;


    uint8_t read_write_len = 0;


    uint8_t addr = 0x30;


    uint8_t index = 0;

    if ((feat_config == 
# 4748 "../applications/bmi270/bmi2.c" 3 4
                       ((void *)0)
# 4748 "../applications/bmi270/bmi2.c"
                           ) || (dev == 
# 4748 "../applications/bmi270/bmi2.c" 3 4
                                        ((void *)0)
# 4748 "../applications/bmi270/bmi2.c"
                                            ))
    {
        rslt = -1;
    }
    else
    {

        if (sw_page < dev->page_max)
        {

            rslt = bmi2_set_regs(0x2F, &sw_page, 1, dev);


            if ((rslt == 0) && (dev->read_write_len < 16))
            {

                if ((dev->read_write_len % 2) != 0)
                {
                    dev->read_write_len--;
                }

                while (bytes_remain > 0)
                {
                    if (bytes_remain >= dev->read_write_len)
                    {

                        rslt = bmi2_get_regs(addr, &feat_config[index], dev->read_write_len, dev);


                        index += (uint8_t) dev->read_write_len;


                        addr += (uint8_t) dev->read_write_len;


                        read_write_len += (uint8_t) dev->read_write_len;
                    }
                    else
                    {

                        rslt = bmi2_get_regs(addr, (uint8_t *) (feat_config + index), (uint16_t) bytes_remain, dev);


                        read_write_len += bytes_remain;
                    }


                    bytes_remain = 16 - read_write_len;

                    if (rslt != 0)
                    {
                        break;
                    }
                }
            }
            else if (rslt == 0)
            {

                rslt = bmi2_get_regs(0x30, feat_config, 16, dev);
            }
        }
        else
        {
            rslt = -10;
        }
    }

    return rslt;
}





uint8_t bmi2_extract_input_feat_config(struct bmi2_feature_config *feat_config, uint8_t type,
                                       const struct bmi2_dev *dev)
{

    uint8_t loop = 0;


    uint8_t feat_found = 0;


    while (loop < dev->input_sens)
    {
        if (dev->feat_config[loop].type == type)
        {
            *feat_config = dev->feat_config[loop];
            feat_found = 1;
            break;
        }

        loop++;
    }


    return feat_found;
}
# 4861 "../applications/bmi270/bmi2.c"
static int8_t write_config_file(struct bmi2_dev *dev)
{

    int8_t rslt;


    uint16_t index = 0;


    uint16_t config_size = dev->config_size;


    uint8_t remain = (uint8_t)(config_size % dev->read_write_len);


    uint16_t bal_byte = 0;


    uint16_t read_write_len = 0;


    rslt = bmi2_set_adv_power_save(0, dev);
    if (rslt == 0)
    {

        rslt = set_config_load(0, dev);
        if (rslt == 0)
        {
            if (!remain)
            {

                for (index = 0; (index < config_size) && (rslt == 0); index += dev->read_write_len)
                {
                    rslt = upload_file((dev->config_file_ptr + index), index, dev->read_write_len, dev);
                }
            }
            else
            {

                bal_byte = (uint16_t) config_size - (uint16_t) remain;


                for (index = 0; (index < bal_byte) && (rslt == 0); index += dev->read_write_len)
                {
                    rslt = upload_file((dev->config_file_ptr + index), index, dev->read_write_len, dev);
                }

                if (rslt == 0)
                {

                    read_write_len = dev->read_write_len;


                    dev->read_write_len = 2;


                    for (index = bal_byte;
                         (index < config_size) && (rslt == 0);
                         index += dev->read_write_len)
                    {
                        rslt = upload_file((dev->config_file_ptr + index), index, dev->read_write_len, dev);
                    }


                    dev->read_write_len = read_write_len;
                }
            }

            if (rslt == 0)
            {

                rslt = set_config_load(1, dev);

                if (rslt == 0)
                {

                    rslt = bmi2_set_adv_power_save(1, dev);
                }
            }
        }
    }

    return rslt;
}





static int8_t set_config_load(uint8_t enable, struct bmi2_dev *dev)
{

    int8_t rslt;


    uint8_t reg_data = 0;

    rslt = bmi2_get_regs(0x59, &reg_data, 1, dev);
    if (rslt == 0)
    {
        reg_data = ((reg_data & ~(0x01)) | (enable & 0x01));
        rslt = bmi2_set_regs(0x59, &reg_data, 1, dev);
    }

    return rslt;
}




static int8_t upload_file(const uint8_t *config_data, uint16_t index, uint16_t write_len, struct bmi2_dev *dev)
{

    int8_t rslt;


    uint8_t addr_array[2] = { 0 };

    if (config_data != 
# 4979 "../applications/bmi270/bmi2.c" 3 4
                      ((void *)0)
# 4979 "../applications/bmi270/bmi2.c"
                          )
    {

        addr_array[0] = (uint8_t)((index / 2) & 0x0F);


        addr_array[1] = (uint8_t)((index / 2) >> 4);


        rslt = bmi2_set_regs(0x5B, addr_array, 2, dev);
        if (rslt == 0)
        {

            rslt = bmi2_set_regs(0x5E, (uint8_t *)config_data, write_len, dev);
        }
    }
    else
    {
        rslt = -1;
    }

    return rslt;
}





static int8_t validate_bw_perf_mode(uint8_t *bandwidth, uint8_t *perf_mode, struct bmi2_dev *dev)
{

    int8_t rslt;


    rslt = check_boundary_val(perf_mode, 0, 1, dev);
    if (rslt == 0)
    {

        if (*perf_mode == 1)
        {

            rslt = check_boundary_val(bandwidth, 0x00, 0x03, dev);
        }
        else
        {

            rslt = check_boundary_val(bandwidth, 0x00, 0x07, dev);
        }
    }

    return rslt;
}





static int8_t validate_odr_range(uint8_t *odr, uint8_t *range, struct bmi2_dev *dev)
{

    int8_t rslt;


    rslt = check_boundary_val(odr, 0x01, 0x0C, dev);
    if (rslt == 0)
    {

        rslt = check_boundary_val(range, 0x00, 0x03, dev);
    }

    return rslt;
}





static int8_t validate_gyro_config(struct bmi2_gyro_config *config, struct bmi2_dev *dev)
{

    int8_t rslt;


    rslt = check_boundary_val(&config->filter_perf, 0, 1, dev);
    if (rslt == 0)
    {

        rslt = check_boundary_val(&config->bwp, 0x00, 0x03, dev);
        if (rslt == 0)
        {

            rslt = check_boundary_val(&config->noise_perf, 0, 1, dev);
            if (rslt == 0)
            {

                rslt = check_boundary_val(&config->odr, 0x06, 0x0D, dev);
                if (rslt == 0)
                {

                    rslt = check_boundary_val(&config->ois_range, 0x00, 0x01, dev);
                    if (rslt == 0)
                    {

                        rslt = check_boundary_val(&config->range, 0x00, 0x04, dev);
                    }
                }
            }
        }
    }

    return rslt;
}





static int8_t cfg_error_status(struct bmi2_dev *dev)
{

    int8_t rslt;


    uint8_t reg_data;


    rslt = bmi2_get_regs(0x1B, &reg_data, 1, dev);
    if (rslt == 0)
    {
        reg_data = ((reg_data & (0x1C)) >> (0x02));
        switch (reg_data)
        {
            case BMI2_NO_ERROR:
                rslt = 0;
                break;
            case BMI2_ACC_ERROR:
                rslt = -5;
                break;
            case BMI2_GYR_ERROR:
                rslt = -6;
                break;
            case BMI2_ACC_GYR_ERROR:
                rslt = -7;
                break;
            default:
                break;
        }
    }

    return rslt;
}
# 5139 "../applications/bmi270/bmi2.c"
static int8_t set_aux_config(struct bmi2_aux_config *config, struct bmi2_dev *dev)
{

    int8_t rslt;


    rslt = validate_aux_config(config, dev);
    if (rslt == 0)
    {

        rslt = set_aux_interface(config, dev);
        if (rslt == 0)
        {

            rslt = config_aux_interface(config, dev);
            if (rslt == 0)
            {

                rslt = config_aux(config, dev);
            }
        }
    }

    return rslt;
}





static int8_t set_gyro_user_gain_config(const struct bmi2_gyro_user_gain_config *config, struct bmi2_dev *dev)
{

    int8_t rslt;


    uint8_t feat_config[16] = { 0 };


    uint8_t idx = 0;


    uint8_t index = 0;


    uint8_t feat_found;


    struct bmi2_feature_config user_gain_config = { 0, 0, 0 };


    uint16_t *data_p = (uint16_t *) (void *)feat_config;


    feat_found = bmi2_extract_input_feat_config(&user_gain_config, 9, dev);
    if (feat_found)
    {

        rslt = bmi2_get_feat_config(user_gain_config.page, feat_config, dev);
        if (rslt == 0)
        {

            idx = user_gain_config.start_addr;


            idx = idx / 2;


            *(data_p + idx) = ((*(data_p + idx) & ~(0x07FF)) | (config->ratio_x & 0x07FF));


            idx++;


            *(data_p + idx) = ((*(data_p + idx) & ~(0x07FF)) | (config->ratio_y & 0x07FF));


            idx++;


            *(data_p + idx) = ((*(data_p + idx) & ~(0x07FF)) | (config->ratio_z & 0x07FF));


            idx++;


            idx = (uint8_t)(idx * 2) - user_gain_config.start_addr;


            for (index = 0; index < idx; index++)
            {
                feat_config[user_gain_config.start_addr +
                            index] = *((uint8_t *) data_p + user_gain_config.start_addr + index);
            }


            rslt = bmi2_set_regs(0x30, feat_config, 16, dev);
        }
    }
    else
    {
        rslt = -8;
    }

    return rslt;
}




static int8_t set_aux_interface(const struct bmi2_aux_config *config, struct bmi2_dev *dev)
{

    int8_t rslt;


    uint8_t reg_data;

    rslt = bmi2_get_regs(0x6B, &reg_data, 1, dev);
    if (rslt == 0)
    {
        reg_data = ((reg_data & ~(0x20)) | ((config->aux_en << 0x05) & 0x20));


        rslt = bmi2_set_regs(0x6B, &reg_data, 1, dev);
    }

    return rslt;
}
# 5276 "../applications/bmi270/bmi2.c"
static int8_t config_aux_interface(const struct bmi2_aux_config *config, struct bmi2_dev *dev)
{

    int8_t rslt;


    uint8_t reg_data[2] = { 0 };


    uint8_t status = 0;


    uint8_t count = 0;

    rslt = bmi2_get_regs(0x4B, reg_data, 2, dev);
    if (rslt == 0)
    {

        reg_data[0] = ((reg_data[0] & ~(0xFE)) | ((config->i2c_device_addr << 0x01) & 0xFE));


        reg_data[1] = ((reg_data[1] & ~(0x80)) | ((config->manual_en << 0x07) & 0x80));


        reg_data[1] = ((reg_data[1] & ~(0x40)) | ((config->fcu_write_en << 0x06) & 0x40));


        reg_data[1] = ((reg_data[1] & ~(0x0C)) | ((config->man_rd_burst << 0x02) & 0x0C));


        reg_data[1] = ((reg_data[1] & ~(0x03)) | (config->aux_rd_burst & 0x03));
        for (;;)
        {

            rslt = bmi2_get_status(&status, dev);
            if ((rslt == 0) && (!(status & 0x04)))
            {

                rslt = bmi2_set_regs(0x4B, reg_data, 2, dev);
                dev->delay_us(1000, dev->intf_ptr);
                if (rslt == 0)
                {

                    if (!config->manual_en)
                    {

                        dev->aux_man_en = 0;


                        rslt = bmi2_set_regs(0x4D, (uint8_t *) &config->read_addr, 1, dev);
                        dev->delay_us(1000, dev->intf_ptr);
                    }
                    else
                    {

                        dev->aux_man_en = 1;


                        dev->aux_man_rd_burst_len = config->man_rd_burst;
                    }
                }


                break;
            }


            dev->delay_us(10000, dev->intf_ptr);
            count++;


            if (count > 20)
            {
                rslt = -15;
                break;
            }
        }
    }

    return rslt;
}





static int8_t config_aux(const struct bmi2_aux_config *config, struct bmi2_dev *dev)
{

    int8_t rslt;


    uint8_t reg_data;

    rslt = bmi2_get_regs(0x44, &reg_data, 1, dev);
    if (rslt == 0)
    {

        reg_data = ((reg_data & ~(0xF0)) | ((config->offset << 0x04) & 0xF0));


        reg_data = ((reg_data & ~(0x0F)) | (config->odr & 0x0F));


        rslt = bmi2_set_regs(0x44, &reg_data, 1, dev);
        dev->delay_us(1000, dev->intf_ptr);
    }

    return rslt;
}





static int8_t set_if_aux_not_busy(uint8_t reg_addr, uint8_t reg_data, struct bmi2_dev *dev)
{

    int8_t rslt;


    uint8_t status = 0;


    uint8_t count = 0;

    for (;;)
    {

        rslt = bmi2_get_status(&status, dev);


        if ((rslt == 0) && (!(status & 0x04)))
        {
            rslt = bmi2_set_regs(reg_addr, &reg_data, 1, dev);
            dev->delay_us(1000, dev->intf_ptr);


            break;
        }


        dev->delay_us(10000, dev->intf_ptr);
        count++;


        if (count > 20)
        {
            rslt = -15;
            break;
        }
    }

    return rslt;
}




static int8_t validate_aux_config(struct bmi2_aux_config *config, struct bmi2_dev *dev)
{

    int8_t rslt;


    rslt = check_boundary_val(&config->odr, 0x01, 0x0B, dev);

    return rslt;
}





static int8_t get_accel_config(struct bmi2_accel_config *config, struct bmi2_dev *dev)
{

    int8_t rslt;


    uint8_t data_array[2] = { 0 };


    rslt = null_ptr_check(dev);
    if ((rslt == 0) && (config != 
# 5460 "../applications/bmi270/bmi2.c" 3 4
                                       ((void *)0)
# 5460 "../applications/bmi270/bmi2.c"
                                           ))
    {

        rslt = bmi2_get_regs(0x40, data_array, 2, dev);
        if (rslt == 0)
        {

            config->filter_perf = ((data_array[0] & (0x80)) >> (0x07));


            config->bwp = ((data_array[0] & (0x70)) >> (0x04));


            config->odr = (data_array[0] & (0x0F));


            config->range = (data_array[1] & (0x03));
        }
    }
    else
    {
        rslt = -1;
    }

    return rslt;
}





static int8_t get_gyro_config(struct bmi2_gyro_config *config, struct bmi2_dev *dev)
{

    int8_t rslt;


    uint8_t data_array[2] = { 0 };


    rslt = null_ptr_check(dev);
    if ((rslt == 0) && (config != 
# 5501 "../applications/bmi270/bmi2.c" 3 4
                                       ((void *)0)
# 5501 "../applications/bmi270/bmi2.c"
                                           ))
    {

        rslt = bmi2_get_regs(0x42, data_array, 2, dev);
        if (rslt == 0)
        {

            config->filter_perf = ((data_array[0] & (0x80)) >> (0x07));


            config->noise_perf = ((data_array[0] & (0x40)) >> (0x06));


            config->bwp = ((data_array[0] & (0x30)) >> (0x04));


            config->odr = (data_array[0] & (0x0F));


            config->ois_range = ((data_array[1] & (0x08)) >> (0x03));


            config->range = (data_array[1] & (0x07));
        }
    }
    else
    {
        rslt = -1;
    }

    return rslt;
}
# 5542 "../applications/bmi270/bmi2.c"
static int8_t get_aux_config(struct bmi2_aux_config *config, struct bmi2_dev *dev)
{

    int8_t rslt;


    rslt = null_ptr_check(dev);
    if ((rslt == 0) && (config != 
# 5549 "../applications/bmi270/bmi2.c" 3 4
                                       ((void *)0)
# 5549 "../applications/bmi270/bmi2.c"
                                           ))
    {

        rslt = get_aux_interface(config, dev);
        if (rslt == 0)
        {

            rslt = get_aux_interface_config(config, dev);
            if (rslt == 0)
            {

                rslt = get_aux_cfg(config, dev);
            }
        }
    }
    else
    {
        rslt = -1;
    }

    return rslt;
}





static int8_t get_gyro_gain_update_config(struct bmi2_gyro_user_gain_config *config, struct bmi2_dev *dev)
{

    int8_t rslt;


    uint8_t feat_config[16] = { 0 };


    uint8_t idx = 0;


    uint16_t lsb = 0;


    uint16_t msb = 0;


    uint16_t lsb_msb = 0;


    uint8_t feat_found;


    struct bmi2_feature_config user_gain_config = { 0, 0, 0 };


    feat_found = bmi2_extract_input_feat_config(&user_gain_config, 9, dev);
    if (feat_found)
    {

        rslt = bmi2_get_feat_config(user_gain_config.page, feat_config, dev);
        if (rslt == 0)
        {

            idx = user_gain_config.start_addr;


            lsb = (uint16_t) feat_config[idx++];
            msb = ((uint16_t) feat_config[idx++] << 8);
            lsb_msb = lsb | msb;


            config->ratio_x = lsb_msb & 0x07FF;


            lsb = (uint16_t) feat_config[idx++];
            msb = ((uint16_t) feat_config[idx++] << 8);
            lsb_msb = lsb | msb;


            config->ratio_y = lsb_msb & 0x07FF;


            lsb = (uint16_t) feat_config[idx++];
            msb = ((uint16_t) feat_config[idx++] << 8);
            lsb_msb = lsb | msb;


            config->ratio_z = lsb_msb & 0x07FF;
        }
    }
    else
    {
        rslt = -8;
    }

    return rslt;
}




static int8_t get_aux_interface(struct bmi2_aux_config *config, struct bmi2_dev *dev)
{

    int8_t rslt;


    uint8_t reg_data;


    rslt = bmi2_get_regs(0x6B, &reg_data, 1, dev);
    if (rslt == 0)
    {
        config->aux_en = ((reg_data & (0x20)) >> (0x05));
    }

    return rslt;
}





static int8_t get_aux_interface_config(struct bmi2_aux_config *config, struct bmi2_dev *dev)
{

    int8_t rslt;


    uint8_t reg_data[2] = { 0 };

    rslt = bmi2_get_regs(0x4B, reg_data, 2, dev);
    if (rslt == 0)
    {

        config->i2c_device_addr = ((reg_data[0] & (0xFE)) >> (0x01));


        config->manual_en = ((reg_data[1] & (0x80)) >> (0x07));


        config->fcu_write_en = ((reg_data[1] & (0x40)) >> (0x06));


        config->man_rd_burst = ((reg_data[1] & (0x0C)) >> (0x02));


        config->aux_rd_burst = (reg_data[1] & (0x03));


        if (!config->manual_en)
        {
            rslt = bmi2_get_regs(0x4D, &config->read_addr, 1, dev);
        }
    }

    return rslt;
}





static int8_t get_aux_cfg(struct bmi2_aux_config *config, struct bmi2_dev *dev)
{

    int8_t rslt;


    uint8_t reg_data;

    rslt = bmi2_get_regs(0x44, &reg_data, 1, dev);
    if (rslt == 0)
    {

        config->offset = ((reg_data & (0xF0)) >> (0x04));


        config->odr = (reg_data & (0x0F));
    }

    return rslt;
}





static int8_t map_feat_int(uint8_t *reg_data_array, enum bmi2_hw_int_pin int_pin, uint8_t int_mask)
{

    int8_t rslt = 0;


    if (reg_data_array != 
# 5742 "../applications/bmi270/bmi2.c" 3 4
                         ((void *)0)
# 5742 "../applications/bmi270/bmi2.c"
                             )
    {

        if (int_pin < BMI2_INT_PIN_MAX)
        {
            switch (int_pin)
            {
                case BMI2_INT_NONE:


                    reg_data_array[0] &= ~(int_mask);
                    reg_data_array[1] &= ~(int_mask);
                    break;
                case BMI2_INT1:


                    reg_data_array[0] |= int_mask;


                    reg_data_array[1] &= ~(int_mask);
                    break;
                case BMI2_INT2:


                    reg_data_array[1] |= int_mask;


                    reg_data_array[0] &= ~(int_mask);
                    break;
                case BMI2_INT_BOTH:


                    reg_data_array[0] |= int_mask;
                    reg_data_array[1] |= int_mask;
                    break;
                default:
                    break;
            }
        }
        else
        {

            rslt = -12;
        }
    }
    else
    {
        rslt = -1;
    }

    return rslt;
}




static void get_acc_gyr_data(struct bmi2_sens_axes_data *data, const uint8_t *reg_data)
{

    uint8_t msb;


    uint8_t lsb;


    uint16_t msb_lsb;


    uint8_t index = 0;


    lsb = reg_data[index++];
    msb = reg_data[index++];
    msb_lsb = ((uint16_t) msb << 8) | (uint16_t) lsb;
    data->x = (int16_t) msb_lsb;


    lsb = reg_data[index++];
    msb = reg_data[index++];
    msb_lsb = ((uint16_t) msb << 8) | (uint16_t) lsb;
    data->y = (int16_t) msb_lsb;


    lsb = reg_data[index++];
    msb = reg_data[index++];
    msb_lsb = ((uint16_t) msb << 8) | (uint16_t) lsb;
    data->z = (int16_t) msb_lsb;
}




static void get_remapped_data(struct bmi2_sens_axes_data *data, const struct bmi2_dev *dev)
{

    int16_t remap_data[3] = { 0 };
    int16_t pos_multiplier = 1;
    int16_t neg_multiplier = -1;


    remap_data[0] = data->x;
    remap_data[1] = data->y;
    remap_data[2] = data->z;


    if (dev->remap.x_axis_sign == 0)
    {
        data->x = (int16_t)(remap_data[dev->remap.x_axis] * pos_multiplier);
    }
    else
    {
        data->x = (int16_t)(remap_data[dev->remap.x_axis] * neg_multiplier);
    }


    if (dev->remap.y_axis_sign == 0)
    {
        data->y = (int16_t)(remap_data[dev->remap.y_axis] * pos_multiplier);
    }
    else
    {
        data->y = (int16_t)(remap_data[dev->remap.y_axis] * neg_multiplier);
    }


    if (dev->remap.z_axis_sign == 0)
    {
        data->z = (int16_t)(remap_data[dev->remap.z_axis] * pos_multiplier);
    }
    else
    {
        data->z = (int16_t)(remap_data[dev->remap.z_axis] * neg_multiplier);
    }
}





static int8_t read_aux_data(uint8_t reg_addr, uint8_t *aux_data, uint16_t len, uint8_t burst_len, struct bmi2_dev *dev)
{

    int8_t rslt = 0;


    uint8_t reg_data[15] = { 0 };


    uint16_t read_length = 0;


    uint8_t loop = 0;


    uint8_t count = 0;


    uint8_t idx = 0;

    while (len > 0)
    {

        rslt = set_if_aux_not_busy(0x4D, reg_addr, dev);
        if (rslt == 0)
        {

            rslt = bmi2_get_regs(0x04, reg_data, (uint16_t) burst_len, dev);
            dev->delay_us(1000, dev->intf_ptr);
            if (rslt == 0)
            {

                if (len < burst_len)
                {
                    read_length = (uint8_t) len;
                }
                else
                {
                    read_length = burst_len;
                }


                for (loop = 0; loop < read_length; loop++)
                {
                    idx = loop + count;
                    aux_data[idx] = reg_data[loop];
                }
            }
        }


        reg_addr += burst_len;


        count += burst_len;


        len -= read_length;
    }

    return rslt;
}







static int8_t write_aux_data(uint8_t reg_addr, uint8_t reg_data, struct bmi2_dev *dev)
{

    int8_t rslt;


    rslt = bmi2_set_regs(0x4F, &reg_data, 1, dev);
    if (rslt == 0)
    {

        rslt = set_if_aux_not_busy(0x4E, reg_addr, dev);
    }

    return rslt;
}





static int8_t map_read_len(uint8_t *len, const struct bmi2_dev *dev)
{

    int8_t rslt = 0;


    switch (dev->aux_man_rd_burst_len)
    {
        case 0x00:
            *len = 1;
            break;
        case 0x01:
            *len = 2;
            break;
        case 0x02:
            *len = 6;
            break;
        case 0x03:
            *len = 8;
            break;
        default:
            rslt = -14;
            break;
    }

    return rslt;
}





static int8_t parse_fifo_accel_len(uint16_t *start_idx,
                                   uint16_t *len,
                                   uint8_t *skip_length,
                                   const uint16_t *acc_count,
                                   const struct bmi2_fifo_frame *fifo)
{

    int8_t rslt = 0;


    (*start_idx) = fifo->acc_byte_start_idx;


    if (fifo->data_enable == 0x4000)
    {

        (*len) = (uint16_t)((*acc_count) * 6);


        (*skip_length) = 6;
    }

    else if (fifo->data_enable == (0x4000 | 0x2000))
    {

        (*len) = (uint16_t)((*acc_count) * 14);


        (*skip_length) = 14;


        (*start_idx) = fifo->acc_byte_start_idx + 8;
    }

    else if (fifo->data_enable == (0x4000 | 0x8000))
    {

        (*len) = (uint16_t)((*acc_count) * 12);


        (*skip_length) = 12;


        (*start_idx) = fifo->acc_byte_start_idx + 6;
    }

    else if (fifo->data_enable == (0x4000 | 0x8000 | 0x2000))
    {

        (*len) = (uint16_t)((*acc_count) * 20);


        (*skip_length) = 20;


        (*start_idx) = fifo->acc_byte_start_idx + 14;
    }
    else
    {



        (*start_idx) = fifo->length;


        rslt = 1;
    }


    if ((*len) > fifo->length)
    {
        (*len) = fifo->length;
    }

    return rslt;
}




static int8_t check_dummy_frame(uint8_t dummy_frame_header,
                                uint16_t *data_index,
                                uint8_t skip_length,
                                const struct bmi2_fifo_frame *fifo)
{
    int8_t rslt;


    if (((*data_index) + 6) < fifo->length)
    {

        if (((fifo->data[(*data_index)] == dummy_frame_header) &&
             (fifo->data[(*data_index) + 1] == 0x7F) &&
             (fifo->data[(*data_index) + 2] == 0x00)) &&
            ((fifo->data[(*data_index) + 3] == 0x80)))
        {

            (*data_index) = (*data_index) + skip_length;


            rslt = 3;
        }
        else
        {

            rslt = 0;
        }
    }
    else
    {

        (*data_index) = fifo->length;


        rslt = 1;
    }

    return rslt;

}





static int8_t extract_accel_headerless_mode(struct bmi2_sens_axes_data *acc,
                                            uint16_t *accel_length,
                                            struct bmi2_fifo_frame *fifo,
                                            const struct bmi2_dev *dev)
{
    int8_t rslt;


    uint16_t data_index = 0;


    uint8_t data_enable;


    uint16_t accel_index = 0;


    uint16_t data_read_length = 0;


    uint8_t skip_length = 0;


    rslt = parse_fifo_accel_len(&data_index, &data_read_length, &skip_length, accel_length, fifo);


    data_enable = (uint8_t)(fifo->data_enable >> 8);

    for (; (data_index < data_read_length) && (rslt != 1);)
    {
        rslt = check_dummy_frame(0x01, &data_index, skip_length, fifo);


        if (rslt == 0)
        {

            rslt = unpack_accel_headerless_frame(acc, &data_index, &accel_index, data_enable, fifo, dev);

            if (rslt != 1)
            {

                rslt = check_empty_fifo(&data_index, fifo);
            }
        }
    }


    (*accel_length) = accel_index;


    fifo->acc_byte_start_idx = data_index;

    return rslt;
}





static int8_t extract_accel_header_mode(struct bmi2_sens_axes_data *acc,
                                        uint16_t *accel_length,
                                        struct bmi2_fifo_frame *fifo,
                                        const struct bmi2_dev *dev)
{

    int8_t rslt = 0;


    uint8_t frame_header = 0;


    uint16_t data_index;


    uint16_t accel_index = 0;


    uint16_t frame_to_read = *accel_length;

    for (data_index = fifo->acc_byte_start_idx; data_index < fifo->length;)
    {

        frame_header = fifo->data[data_index] & 0xFF;


        parse_if_virtual_header(&frame_header, &data_index, fifo);


        data_index++;
        switch (frame_header)
        {

            case 0x84:
            case 0x94:
            case 0x8C:
            case 0x9C:


                rslt = unpack_accel_header_frame(acc, &data_index, &accel_index, frame_header, fifo, dev);
                break;


            case 0x88:
                rslt = move_next_frame(&data_index, fifo->gyr_frm_len, fifo);
                break;


            case 0x90:
                rslt = move_next_frame(&data_index, fifo->aux_frm_len, fifo);
                break;


            case 0x98:
                rslt = move_next_frame(&data_index, fifo->aux_gyr_frm_len, fifo);
                break;


            case 0x44:
                rslt = unpack_sensortime_frame(&data_index, fifo);
                break;


            case 0x40:
                rslt = unpack_skipped_frame(&data_index, fifo);
                break;


            case 0x48:
                rslt = move_next_frame(&data_index, 4, fifo);
                break;


            case 0x80:


                data_index = fifo->length;


                rslt = 1;
                break;
            case 0xC8:
                rslt = move_next_frame(&data_index, 6, fifo);
                break;
            default:


                data_index = fifo->length;


                rslt = 1;
                break;
        }


        if ((frame_to_read == accel_index) || (rslt == 1))
        {
            break;
        }
    }


    (*accel_length) = accel_index;


    fifo->acc_byte_start_idx = data_index;

    return rslt;
}






static int8_t unpack_accel_headerless_frame(struct bmi2_sens_axes_data *acc,
                                            uint16_t *idx,
                                            uint16_t *acc_idx,
                                            uint8_t frame,
                                            const struct bmi2_fifo_frame *fifo,
                                            const struct bmi2_dev *dev)
{

    int8_t rslt = 0;

    switch (frame)
    {

        case 0x40:


            if (((*idx) + fifo->acc_frm_len) > fifo->length)
            {

                (*idx) = fifo->length;

                rslt = 0;
                break;
            }


            unpack_accel_data(&acc[(*acc_idx)], *idx, fifo, dev);


            (*idx) = (*idx) + 6;


            if (dev->sens_en_stat & (1 << 18))
            {
                unpack_virt_sensor_time(&acc[(*acc_idx)], idx, fifo);
            }


            (*acc_idx)++;


            rslt = 2;
            break;


        case 0xC0:


            if (((*idx) + fifo->acc_gyr_frm_len) > fifo->length)
            {

                (*idx) = fifo->length;

                rslt = 0;
                break;
            }


            unpack_accel_data(&acc[(*acc_idx)], *idx, fifo, dev);


            (*idx) = (*idx) + 12;


            if (dev->sens_en_stat & (1 << 18))
            {
                unpack_virt_sensor_time(&acc[(*acc_idx)], idx, fifo);
            }


            (*acc_idx)++;


            rslt = 2;
            break;


        case 0x60:


            if (((*idx) + fifo->acc_aux_frm_len) > fifo->length)
            {

                (*idx) = fifo->length;

                rslt = 0;
                break;
            }


            unpack_accel_data(&acc[(*acc_idx)], *idx, fifo, dev);


            (*idx) = (*idx) + 14;


            if (dev->sens_en_stat & (1 << 18))
            {
                unpack_virt_sensor_time(&acc[(*acc_idx)], idx, fifo);
            }


            (*acc_idx)++;


            rslt = 2;
            break;


        case 0xE0:


            if ((*idx + fifo->all_frm_len) > fifo->length)
            {

                (*idx) = fifo->length;

                rslt = 0;
                break;
            }


            unpack_accel_data(&acc[(*acc_idx)], *idx, fifo, dev);


            (*idx) = (*idx) + 20;


            if (dev->sens_en_stat & (1 << 18))
            {
                unpack_virt_sensor_time(&acc[(*acc_idx)], idx, fifo);
            }


            (*acc_idx)++;


            rslt = 2;
            break;


        case 0xA0:


            (*idx) = (*idx) + fifo->aux_gyr_frm_len;


            rslt = 2;
            break;


        case 0x20:


            (*idx) = (*idx) + fifo->aux_frm_len;


            rslt = 2;
            break;


        case 0x80:


            (*idx) = (*idx) + fifo->gyr_frm_len;


            rslt = 2;
            break;
        default:


            (*idx) = fifo->length;


            rslt = 1;
            break;
    }

    return rslt;
}






static int8_t unpack_accel_header_frame(struct bmi2_sens_axes_data *acc,
                                        uint16_t *idx,
                                        uint16_t *acc_idx,
                                        uint8_t frame,
                                        const struct bmi2_fifo_frame *fifo,
                                        const struct bmi2_dev *dev)
{

    int8_t rslt = 0;

    switch (frame)
    {

        case 0x84:


            if (((*idx) + fifo->acc_frm_len) > fifo->length)
            {

                (*idx) = fifo->length;

                rslt = 0;
                break;
            }


            unpack_accel_data(&acc[(*acc_idx)], *idx, fifo, dev);


            (*idx) = (*idx) + 6;


            if (dev->sens_en_stat & (1 << 18))
            {
                unpack_virt_sensor_time(&acc[(*acc_idx)], idx, fifo);
            }


            (*acc_idx)++;


            rslt = 2;
            break;


        case 0x8C:


            if (((*idx) + fifo->acc_gyr_frm_len) > fifo->length)
            {

                (*idx) = fifo->length;

                rslt = 0;
                break;
            }


            unpack_accel_data(&acc[(*acc_idx)], ((*idx) + 6), fifo, dev);


            (*idx) = (*idx) + 12;


            if (dev->sens_en_stat & (1 << 18))
            {
                unpack_virt_sensor_time(&acc[(*acc_idx)], idx, fifo);
            }


            (*acc_idx)++;


            rslt = 2;
            break;


        case 0x94:


            if (((*idx) + fifo->acc_aux_frm_len) > fifo->length)
            {

                (*idx) = fifo->length;

                rslt = 0;
                break;
            }


            unpack_accel_data(&acc[(*acc_idx)], ((*idx) + 8), fifo, dev);


            (*idx) = (*idx) + 14;


            if (dev->sens_en_stat & (1 << 18))
            {
                unpack_virt_sensor_time(&acc[(*acc_idx)], idx, fifo);
            }


            (*acc_idx)++;


            rslt = 2;
            break;


        case 0x9C:


            if ((*idx + fifo->all_frm_len) > fifo->length)
            {

                (*idx) = fifo->length;

                rslt = 0;
                break;
            }


            unpack_accel_data(&acc[(*acc_idx)], ((*idx) + 14), fifo, dev);


            (*idx) = (*idx) + 20;


            if (dev->sens_en_stat & (1 << 18))
            {
                unpack_virt_sensor_time(&acc[(*acc_idx)], idx, fifo);
            }


            (*acc_idx)++;


            rslt = 2;
            break;


        case 0x98:


            (*idx) = (*idx) + fifo->aux_gyr_frm_len;


            rslt = 2;
            break;


        case 0x90:


            (*idx) = (*idx) + fifo->aux_frm_len;


            rslt = 2;
            break;


        case 0x88:


            (*idx) = (*idx) + fifo->gyr_frm_len;


            rslt = 2;
            break;
        default:


            (*idx) = fifo->length;


            rslt = 1;
            break;
    }

    return rslt;
}





static void unpack_accel_data(struct bmi2_sens_axes_data *acc,
                              uint16_t data_start_index,
                              const struct bmi2_fifo_frame *fifo,
                              const struct bmi2_dev *dev)
{

    uint16_t data_lsb;


    uint16_t data_msb;


    data_lsb = fifo->data[data_start_index++];
    data_msb = fifo->data[data_start_index++];
    acc->x = (int16_t)((data_msb << 8) | data_lsb);


    data_lsb = fifo->data[data_start_index++];
    data_msb = fifo->data[data_start_index++];
    acc->y = (int16_t)((data_msb << 8) | data_lsb);


    data_lsb = fifo->data[data_start_index++];
    data_msb = fifo->data[data_start_index++];
    acc->z = (int16_t)((data_msb << 8) | data_lsb);


    get_remapped_data(acc, dev);
}





static int8_t parse_fifo_gyro_len(uint16_t *start_idx,
                                  uint16_t *len,
                                  uint8_t *skip_length,
                                  const uint16_t *gyr_count,
                                  const struct bmi2_fifo_frame *fifo)
{

    int8_t rslt = 0;


    (*start_idx) = fifo->gyr_byte_start_idx;


    if (fifo->data_enable == 0x8000)
    {

        (*len) = (uint16_t)((*gyr_count) * 6);


        (*skip_length) = 6;
    }

    else if (fifo->data_enable == (0x8000 | 0x2000))
    {

        (*len) = (uint16_t)((*gyr_count) * 14);


        (*skip_length) = 14;


        (*start_idx) = fifo->gyr_byte_start_idx + 8;
    }

    else if (fifo->data_enable == (0x4000 | 0x8000))
    {

        (*len) = (uint16_t)((*gyr_count) * 12);


        (*skip_length) = 12;
    }

    else if (fifo->data_enable == (0x8000 | 0x2000 | 0x4000))
    {

        (*len) = (uint16_t)((*gyr_count) * 20);


        (*skip_length) = 20;


        (*start_idx) = fifo->gyr_byte_start_idx + 8;
    }
    else
    {



        (*start_idx) = fifo->length;


        rslt = 1;
    }


    if (((*len)) > fifo->length)
    {
        (*len) = fifo->length;
    }

    return rslt;
}





static int8_t extract_gyro_headerless_mode(struct bmi2_sens_axes_data *gyr,
                                           uint16_t *gyro_length,
                                           struct bmi2_fifo_frame *fifo,
                                           const struct bmi2_dev *dev)
{
    int8_t rslt;


    uint16_t data_index = 0;


    uint16_t gyro_index = 0;


    uint16_t data_read_length = 0;


    uint8_t data_enable;


    uint8_t skip_length = 0;


    rslt = parse_fifo_gyro_len(&data_index, &data_read_length, &skip_length, gyro_length, fifo);


    data_enable = (uint8_t)(fifo->data_enable >> 8);

    for (; (data_index < data_read_length) && (rslt != 1);)
    {
        rslt = check_dummy_frame(0x02, &data_index, skip_length, fifo);


        if (rslt == 0)
        {

            rslt = unpack_gyro_headerless_frame(gyr, &data_index, &gyro_index, data_enable, fifo, dev);

            if (rslt != 1)
            {

                rslt = check_empty_fifo(&data_index, fifo);
            }
        }
    }


    (*gyro_length) = gyro_index;


    fifo->gyr_byte_start_idx = data_index;

    return rslt;
}





static int8_t extract_gyro_header_mode(struct bmi2_sens_axes_data *gyr,
                                       uint16_t *gyro_length,
                                       struct bmi2_fifo_frame *fifo,
                                       const struct bmi2_dev *dev)
{

    int8_t rslt = 0;


    uint8_t frame_header = 0;


    uint16_t data_index;


    uint16_t gyro_index = 0;


    uint16_t frame_to_read = (*gyro_length);

    for (data_index = fifo->gyr_byte_start_idx; data_index < fifo->length;)
    {

        frame_header = fifo->data[data_index] & 0xFF;


        parse_if_virtual_header(&frame_header, &data_index, fifo);


        data_index++;
        switch (frame_header)
        {

            case 0x88:
            case 0x8C:
            case 0x98:
            case 0x9C:


                rslt = unpack_gyro_header_frame(gyr, &data_index, &gyro_index, frame_header, fifo, dev);
                break;


            case 0x84:
                rslt = move_next_frame(&data_index, fifo->acc_frm_len, fifo);
                break;


            case 0x90:
                rslt = move_next_frame(&data_index, fifo->aux_frm_len, fifo);
                break;


            case 0x94:
                rslt = move_next_frame(&data_index, fifo->acc_aux_frm_len, fifo);
                break;


            case 0x44:
                rslt = unpack_sensortime_frame(&data_index, fifo);
                break;


            case 0x40:
                rslt = unpack_skipped_frame(&data_index, fifo);
                break;


            case 0x48:
                rslt = move_next_frame(&data_index, 4, fifo);
                break;


            case 0x80:


                data_index = fifo->length;


                rslt = 1;
                break;
            case 0xC8:
                rslt = move_next_frame(&data_index, 6, fifo);
                break;
            default:


                data_index = fifo->length;


                rslt = 1;
                break;
        }


        if ((frame_to_read == gyro_index) || (rslt == 1))
        {
            break;
        }
    }


    (*gyro_length) = gyro_index;


    fifo->gyr_byte_start_idx = data_index;

    return rslt;
}






static int8_t unpack_gyro_header_frame(struct bmi2_sens_axes_data *gyr,
                                       uint16_t *idx,
                                       uint16_t *gyr_idx,
                                       uint8_t frame,
                                       const struct bmi2_fifo_frame *fifo,
                                       const struct bmi2_dev *dev)
{

    int8_t rslt = 0;

    switch (frame)
    {

        case 0x88:


            if (((*idx) + fifo->gyr_frm_len) > fifo->length)
            {

                (*idx) = fifo->length;

                rslt = 0;
                break;
            }


            unpack_gyro_data(&gyr[(*gyr_idx)], *idx, fifo, dev);


            (*idx) = (*idx) + 6;


            if (dev->sens_en_stat & (1 << 18))
            {
                unpack_virt_sensor_time(&gyr[(*gyr_idx)], idx, fifo);
            }


            (*gyr_idx)++;


            rslt = 2;
            break;


        case 0x8C:


            if (((*idx) + fifo->acc_gyr_frm_len) > fifo->length)
            {

                (*idx) = fifo->length;

                rslt = 0;
                break;
            }


            unpack_gyro_data(&gyr[(*gyr_idx)], (*idx), fifo, dev);


            (*idx) = (*idx) + 12;


            if (dev->sens_en_stat & (1 << 18))
            {
                unpack_virt_sensor_time(&gyr[(*gyr_idx)], idx, fifo);
            }


            (*gyr_idx)++;


            rslt = 2;
            break;


        case 0x98:


            if (((*idx) + fifo->aux_gyr_frm_len) > fifo->length)
            {

                (*idx) = fifo->length;

                rslt = 0;
                break;
            }


            unpack_gyro_data(&gyr[(*gyr_idx)], ((*idx) + 8), fifo, dev);


            (*idx) = (*idx) + 14;


            if (dev->sens_en_stat & (1 << 18))
            {
                unpack_virt_sensor_time(&gyr[(*gyr_idx)], idx, fifo);
            }


            (*gyr_idx)++;


            rslt = 2;
            break;


        case 0x9C:


            if ((*idx + fifo->all_frm_len) > fifo->length)
            {

                (*idx) = fifo->length;

                rslt = 0;
                break;
            }


            unpack_gyro_data(&gyr[(*gyr_idx)], ((*idx) + 8), fifo, dev);


            (*idx) = (*idx) + 20;


            if (dev->sens_en_stat & (1 << 18))
            {
                unpack_virt_sensor_time(&gyr[(*gyr_idx)], idx, fifo);
            }


            (*gyr_idx)++;


            rslt = 2;
            break;


        case 0x94:


            (*idx) = (*idx) + fifo->acc_aux_frm_len;


            rslt = 2;
            break;


        case 0x90:
        case 0x20:


            (*idx) = (*idx) + fifo->aux_frm_len;


            rslt = 2;
            break;


        case 0x84:


            (*idx) = (*idx) + fifo->acc_frm_len;


            rslt = 2;
            break;
        default:


            (*idx) = fifo->length;


            rslt = 1;
            break;
    }

    return rslt;
}






static int8_t unpack_gyro_headerless_frame(struct bmi2_sens_axes_data *gyr,
                                           uint16_t *idx,
                                           uint16_t *gyr_idx,
                                           uint8_t frame,
                                           const struct bmi2_fifo_frame *fifo,
                                           const struct bmi2_dev *dev)
{

    int8_t rslt = 0;

    switch (frame)
    {

        case 0x80:


            if (((*idx) + fifo->gyr_frm_len) > fifo->length)
            {

                (*idx) = fifo->length;

                rslt = 0;
                break;
            }


            unpack_gyro_data(&gyr[(*gyr_idx)], *idx, fifo, dev);


            (*idx) = (*idx) + 6;


            if (dev->sens_en_stat & (1 << 18))
            {
                unpack_virt_sensor_time(&gyr[(*gyr_idx)], idx, fifo);
            }


            (*gyr_idx)++;


            rslt = 2;
            break;


        case 0xC0:


            if (((*idx) + fifo->acc_gyr_frm_len) > fifo->length)
            {

                (*idx) = fifo->length;

                rslt = 0;
                break;
            }


            unpack_gyro_data(&gyr[(*gyr_idx)], (*idx), fifo, dev);


            (*idx) = (*idx) + 12;


            if (dev->sens_en_stat & (1 << 18))
            {
                unpack_virt_sensor_time(&gyr[(*gyr_idx)], idx, fifo);
            }


            (*gyr_idx)++;


            rslt = 2;
            break;


        case 0xA0:


            if (((*idx) + fifo->aux_gyr_frm_len) > fifo->length)
            {

                (*idx) = fifo->length;

                rslt = 0;
                break;
            }


            unpack_gyro_data(&gyr[(*gyr_idx)], (*idx), fifo, dev);


            (*idx) = (*idx) + 14;


            if (dev->sens_en_stat & (1 << 18))
            {
                unpack_virt_sensor_time(&gyr[(*gyr_idx)], idx, fifo);
            }


            (*gyr_idx)++;


            rslt = 2;
            break;


        case 0xE0:


            if ((*idx + fifo->all_frm_len) > fifo->length)
            {

                (*idx) = fifo->length;

                rslt = 0;
                break;
            }


            unpack_gyro_data(&gyr[(*gyr_idx)], (*idx), fifo, dev);


            (*idx) = (*idx) + 20;


            if (dev->sens_en_stat & (1 << 18))
            {
                unpack_virt_sensor_time(&gyr[(*gyr_idx)], idx, fifo);
            }


            (*gyr_idx)++;


            rslt = 2;
            break;


        case 0x60:


            (*idx) = (*idx) + fifo->acc_aux_frm_len;


            rslt = 2;
            break;


        case 0x20:


            (*idx) = (*idx) + fifo->aux_frm_len;


            rslt = 2;
            break;


        case 0x40:


            (*idx) = (*idx) + fifo->acc_frm_len;


            rslt = 2;
            break;
        default:


            (*idx) = fifo->length;


            rslt = 1;
            break;
    }

    return rslt;
}




static void unpack_gyro_data(struct bmi2_sens_axes_data *gyr,
                             uint16_t data_start_index,
                             const struct bmi2_fifo_frame *fifo,
                             const struct bmi2_dev *dev)
{

    uint16_t data_lsb;


    uint16_t data_msb;


    data_lsb = fifo->data[data_start_index++];
    data_msb = fifo->data[data_start_index++];
    gyr->x = (int16_t)((data_msb << 8) | data_lsb);


    data_lsb = fifo->data[data_start_index++];
    data_msb = fifo->data[data_start_index++];
    gyr->y = (int16_t)((data_msb << 8) | data_lsb);


    data_lsb = fifo->data[data_start_index++];
    data_msb = fifo->data[data_start_index++];
    gyr->z = (int16_t)((data_msb << 8) | data_lsb);


    comp_gyro_cross_axis_sensitivity(gyr, dev);


    get_remapped_data(gyr, dev);
}





static int8_t parse_fifo_aux_len(uint16_t *start_idx,
                                 uint16_t *len,
                                 uint8_t *skip_length,
                                 const uint16_t *aux_count,
                                 const struct bmi2_fifo_frame *fifo)
{

    int8_t rslt = 0;


    *start_idx = fifo->aux_byte_start_idx;


    if (fifo->data_enable == 0x2000)
    {

        (*len) = (uint16_t)((*aux_count) * 8);


        (*skip_length) = 8;
    }

    else if (fifo->data_enable == (0x2000 | 0x4000))
    {

        (*len) = (uint16_t)((*aux_count) * 14);


        (*skip_length) = 14;
    }

    else if (fifo->data_enable == (0x2000 | 0x8000))
    {

        (*len) = (uint16_t)((*aux_count) * 14);


        (*skip_length) = 14;
    }

    else if (fifo->data_enable == (0x2000 | 0x8000 | 0x4000))
    {

        (*len) = (uint16_t)((*aux_count) * 20);


        (*skip_length) = 20;
    }
    else
    {

        (*start_idx) = fifo->length;


        rslt = 1;
    }


    if (((*len)) > fifo->length)
    {
        (*len) = fifo->length;
    }

    return rslt;
}





static int8_t extract_aux_headerless_mode(struct bmi2_aux_fifo_data *aux,
                                          uint16_t *aux_length,
                                          struct bmi2_fifo_frame *fifo,
                                          const struct bmi2_dev *dev)
{
    int8_t rslt;


    uint16_t data_index = 0;


    uint16_t aux_index = 0;


    uint16_t data_read_length = 0;


    uint8_t data_enable;


    uint8_t skip_length = 0;

    rslt = parse_fifo_aux_len(&data_index, &data_read_length, &skip_length, aux_length, fifo);


    data_enable = (uint8_t)(fifo->data_enable >> 8);

    for (; (data_index < data_read_length) && (rslt != 1);)
    {
        rslt = check_dummy_frame(0x03, &data_index, skip_length, fifo);


        if (rslt == 0)
        {

            rslt = unpack_aux_frame(aux, &data_index, &aux_index, data_enable, fifo, dev);

            if (rslt != 1)
            {

                rslt = check_empty_fifo(&data_index, fifo);
            }
        }
    }


    *aux_length = aux_index;


    fifo->aux_byte_start_idx = data_index;

    return rslt;
}





static int8_t extract_aux_header_mode(struct bmi2_aux_fifo_data *aux,
                                      uint16_t *aux_len,
                                      struct bmi2_fifo_frame *fifo,
                                      const struct bmi2_dev *dev)
{

    int8_t rslt = 0;


    uint8_t frame_header = 0;


    uint16_t data_index;


    uint16_t aux_index = 0;


    uint16_t frame_to_read = *aux_len;

    for (data_index = fifo->aux_byte_start_idx; data_index < fifo->length;)
    {

        frame_header = fifo->data[data_index] & 0xFF;


        parse_if_virtual_header(&frame_header, &data_index, fifo);


        data_index++;
        switch (frame_header)
        {

            case 0x90:
            case 0x94:
            case 0x98:
            case 0x9C:


                rslt = unpack_aux_frame(aux, &data_index, &aux_index, frame_header, fifo, dev);
                break;


            case 0x84:
                rslt = move_next_frame(&data_index, fifo->acc_frm_len, fifo);
                break;


            case 0x88:
                rslt = move_next_frame(&data_index, fifo->gyr_frm_len, fifo);
                break;


            case 0x8C:
                rslt = move_next_frame(&data_index, fifo->acc_gyr_frm_len, fifo);
                break;


            case 0x44:
                rslt = unpack_sensortime_frame(&data_index, fifo);
                break;


            case 0x40:
                rslt = unpack_skipped_frame(&data_index, fifo);
                break;


            case 0x48:
                rslt = move_next_frame(&data_index, 4, fifo);
                break;


            case 0x80:


                data_index = fifo->length;


                rslt = 1;
                break;
            case 0xC8:
                rslt = move_next_frame(&data_index, 6, fifo);
                break;
            default:




                data_index = fifo->length;


                rslt = 1;
                break;
        }




        if ((frame_to_read == aux_index) || (rslt == 1))
        {
            break;
        }
    }


    (*aux_len) = aux_index;


    fifo->aux_byte_start_idx = data_index;

    return rslt;
}






static int8_t unpack_aux_frame(struct bmi2_aux_fifo_data *aux,
                               uint16_t *idx,
                               uint16_t *aux_idx,
                               uint8_t frame,
                               const struct bmi2_fifo_frame *fifo,
                               const struct bmi2_dev *dev)
{

    int8_t rslt = 0;

    switch (frame)
    {

        case 0x90:
        case 0x20:


            if (((*idx) + fifo->aux_frm_len) > fifo->length)
            {

                (*idx) = fifo->length;

                rslt = 0;
                break;
            }


            unpack_aux_data(&aux[(*aux_idx)], (*idx), fifo);


            (*idx) = (*idx) + 8;

            unpack_virtual_aux_data(&aux[(*aux_idx)], idx, aux_idx, fifo, dev);


            (*aux_idx)++;


            rslt = 2;
            break;


        case 0x94:
        case 0x60:


            if (((*idx) + fifo->acc_aux_frm_len) > fifo->length)
            {

                (*idx) = fifo->length;

                rslt = 0;
                break;
            }


            unpack_aux_data(&aux[(*aux_idx)], (*idx), fifo);


            (*idx) = (*idx) + 14;

            unpack_virtual_aux_data(&aux[(*aux_idx)], idx, aux_idx, fifo, dev);


            (*aux_idx)++;


            rslt = 2;
            break;


        case 0x98:
        case 0xA0:


            if (((*idx) + fifo->aux_gyr_frm_len) > fifo->length)
            {

                (*idx) = fifo->length;

                rslt = 0;
                break;
            }


            unpack_aux_data(&aux[(*aux_idx)], (*idx), fifo);


            (*idx) = (*idx) + 14;

            unpack_virtual_aux_data(&aux[(*aux_idx)], idx, aux_idx, fifo, dev);


            (*aux_idx)++;


            rslt = 2;
            break;


        case 0x9C:
        case 0xE0:


            if ((*idx + fifo->all_frm_len) > fifo->length)
            {

                (*idx) = fifo->length;

                rslt = 0;
                break;
            }


            unpack_aux_data(&aux[(*aux_idx)], (*idx), fifo);


            (*idx) = (*idx) + 20;

            unpack_virtual_aux_data(&aux[(*aux_idx)], idx, aux_idx, fifo, dev);


            (*aux_idx)++;


            rslt = 2;
            break;


        case 0x84:
        case 0x40:


            (*idx) = (*idx) + fifo->acc_frm_len;


            rslt = 2;
            break;


        case 0x88:
        case 0x80:


            (*idx) = (*idx) + fifo->gyr_frm_len;


            rslt = 2;
            break;


        case 0x8C:
        case 0xC0:


            (*idx) = (*idx) + fifo->acc_gyr_frm_len;


            rslt = 2;
            break;
        default:




            (*idx) = fifo->length;


            rslt = 1;
            break;
    }

    return rslt;
}




static void unpack_virtual_aux_data(struct bmi2_aux_fifo_data *aux,
                                    uint16_t *idx,
                                    const uint16_t *aux_idx,
                                    const struct bmi2_fifo_frame *fifo,
                                    const struct bmi2_dev *dev)
{

    if (dev->sens_en_stat & (1 << 18))
    {
        unpack_virt_aux_sensor_time(&aux[(*aux_idx)], idx, fifo);
    }
}




static void unpack_aux_data(struct bmi2_aux_fifo_data *aux,
                            uint16_t data_start_index,
                            const struct bmi2_fifo_frame *fifo)
{

    uint16_t idx = 0;


    for (; idx < 8; idx++)
    {
        aux->data[idx] = fifo->data[data_start_index++];
    }
}




static void parse_if_virtual_header(uint8_t *frame_header, uint16_t *data_index, const struct bmi2_fifo_frame *fifo)
{

    uint8_t virtual_header_mode;


    virtual_header_mode = ((*frame_header & (0xC0)) >> (0x06));


    if (virtual_header_mode == 0x03)
    {

        if (*frame_header != 0xC8)
        {

            (*data_index) = (*data_index) + 1;


            *frame_header = fifo->data[*data_index] & 0xFF;
        }
    }
}





static void unpack_virt_sensor_time(struct bmi2_sens_axes_data *sens, uint16_t *idx, const struct bmi2_fifo_frame *fifo)
{

    uint32_t sensor_time_byte3;
    uint16_t sensor_time_byte2;
    uint8_t sensor_time_byte1;


    sensor_time_byte3 = (uint32_t)(fifo->data[(*idx) + 2] << 16);
    sensor_time_byte2 = (uint16_t) fifo->data[(*idx) + 1] << 8;
    sensor_time_byte1 = fifo->data[(*idx)];


    sens->virt_sens_time = (uint32_t)(sensor_time_byte3 | sensor_time_byte2 | sensor_time_byte1);


    (*idx) = (*idx) + 3;
}





static void unpack_virt_aux_sensor_time(struct bmi2_aux_fifo_data *aux,
                                        uint16_t *idx,
                                        const struct bmi2_fifo_frame *fifo)
{

    uint32_t sensor_time_byte3;
    uint16_t sensor_time_byte2;
    uint8_t sensor_time_byte1;


    sensor_time_byte3 = (uint32_t)(fifo->data[(*idx) + 2] << 16);
    sensor_time_byte2 = (uint16_t) fifo->data[(*idx) + 1] << 8;
    sensor_time_byte1 = fifo->data[(*idx)];


    aux->virt_sens_time = (uint32_t)(sensor_time_byte3 | sensor_time_byte2 | sensor_time_byte1);


    (*idx) = (*idx) + 3;
}





static void reset_fifo_frame_structure(struct bmi2_fifo_frame *fifo, const struct bmi2_dev *dev)
{

    fifo->acc_byte_start_idx = 0;
    fifo->aux_byte_start_idx = 0;
    fifo->gyr_byte_start_idx = 0;
    fifo->sensor_time = 0;
    fifo->skipped_frame_count = 0;
    fifo->act_recog_byte_start_idx = 0;


    if ((dev->sens_en_stat & (1 << 18)) == (1 << 18))
    {
        fifo->acc_frm_len = 9;
        fifo->gyr_frm_len = 9;
        fifo->aux_frm_len = 11;
        fifo->acc_gyr_frm_len = 15;
        fifo->acc_aux_frm_len = 17;
        fifo->aux_gyr_frm_len = 17;
        fifo->all_frm_len = 23;


    }
    else
    {
        fifo->acc_frm_len = 6;
        fifo->gyr_frm_len = 6;
        fifo->aux_frm_len = 8;
        fifo->acc_gyr_frm_len = 12;
        fifo->acc_aux_frm_len = 14;
        fifo->aux_gyr_frm_len = 14;
        fifo->all_frm_len = 20;
    }
}





static int8_t check_empty_fifo(uint16_t *data_index, const struct bmi2_fifo_frame *fifo)
{

    int8_t rslt = 0;


    if (((*data_index) + 6) < fifo->length)
    {

        if (((fifo->data[(*data_index)] == 0x00) &&
             (fifo->data[(*data_index) + 1] == 0x80) &&
             (fifo->data[(*data_index) + 2] == 0x00)) &&
            ((fifo->data[(*data_index) + 3] == 0x80) &&
             (fifo->data[(*data_index) + 4] == 0x00)) &&
            ((fifo->data[(*data_index) + 5] == 0x80)))
        {

            (*data_index) = fifo->length;


            rslt = 1;
        }
        else
        {

            rslt = 2;
        }
    }

    return rslt;
}






static int8_t move_next_frame(uint16_t *data_index, uint8_t current_frame_length, const struct bmi2_fifo_frame *fifo)
{

    int8_t rslt = 0;


    if (((*data_index) + current_frame_length) > fifo->length)
    {

        (*data_index) = fifo->length;

        rslt = 0;
    }
    else
    {

        (*data_index) = (*data_index) + current_frame_length;


        rslt = 2;
    }

    return rslt;
}





static int8_t unpack_sensortime_frame(uint16_t *data_index, struct bmi2_fifo_frame *fifo)
{

    int8_t rslt = 0;


    uint32_t sensor_time_byte3 = 0;
    uint16_t sensor_time_byte2 = 0;
    uint8_t sensor_time_byte1 = 0;


    if (((*data_index) + 3) > fifo->length)
    {

        (*data_index) = fifo->length;

        rslt = 0;
    }
    else
    {

        sensor_time_byte3 = fifo->data[(*data_index) + 2] << 16;
        sensor_time_byte2 = fifo->data[(*data_index) + 1] << 8;
        sensor_time_byte1 = fifo->data[(*data_index)];


        fifo->sensor_time = (uint32_t)(sensor_time_byte3 | sensor_time_byte2 | sensor_time_byte1);


        (*data_index) = (*data_index) + 3;


        rslt = 2;
    }

    return rslt;
}





static int8_t unpack_skipped_frame(uint16_t *data_index, struct bmi2_fifo_frame *fifo)
{

    int8_t rslt = 0;


    if ((*data_index) >= fifo->length)
    {

        (*data_index) = fifo->length;

        rslt = 0;
    }
    else
    {

        fifo->skipped_frame_count = fifo->data[(*data_index)];


        (*data_index) = (*data_index) + 1;


        rslt = 2;
    }

    return rslt;
}





static int8_t pre_self_test_config(struct bmi2_dev *dev)
{

    int8_t rslt;


    struct bmi2_sens_config sens_cfg;


    uint8_t sens_sel = 0;


    rslt = bmi2_sensor_enable(&sens_sel, 1, dev);
    dev->delay_us(1000, dev->intf_ptr);


    if (rslt == 0)
    {
        rslt = set_accel_self_test_amp(1, dev);
    }

    if (rslt == 0)
    {

        sens_cfg.type = 0;


        rslt = bmi2_get_sensor_config(&sens_cfg, 1, dev);
        if (rslt == 0)
        {

            sens_cfg.cfg.acc.odr = 0x0C;
            sens_cfg.cfg.acc.bwp = 0x02;
            sens_cfg.cfg.acc.filter_perf = 1;
            sens_cfg.cfg.acc.range = 0x03;


            rslt = bmi2_set_sensor_config(&sens_cfg, 1, dev);
        }
    }

    return rslt;
}





static int8_t self_test_config(uint8_t sign, struct bmi2_dev *dev)
{

    int8_t rslt;


    rslt = set_accel_self_test_enable(1, dev);
    if (rslt == 0)
    {

        rslt = set_acc_self_test_sign(sign, dev);
    }

    return rslt;
}





static int8_t set_accel_self_test_enable(uint8_t enable, struct bmi2_dev *dev)
{

    int8_t rslt;


    uint8_t data = 0;


    rslt = bmi2_get_regs(0x6D, &data, 1, dev);
    if (rslt == 0)
    {
        data = ((data & ~(0x01)) | (enable & 0x01));
        rslt = bmi2_set_regs(0x6D, &data, 1, dev);
    }

    return rslt;
}





static int8_t set_acc_self_test_sign(uint8_t sign, struct bmi2_dev *dev)
{

    int8_t rslt;


    uint8_t data = 0;


    rslt = bmi2_get_regs(0x6D, &data, 1, dev);
    if (rslt == 0)
    {
        data = ((data & ~(0x04)) | ((sign << 0x02) & 0x04));
        rslt = bmi2_set_regs(0x6D, &data, 1, dev);
    }

    return rslt;
}





static int8_t set_accel_self_test_amp(uint8_t amp, struct bmi2_dev *dev)
{

    int8_t rslt;


    uint8_t data = 0;


    rslt = bmi2_get_regs(0x6D, &data, 1, dev);
    if (rslt == 0)
    {
        data = ((data & ~(0x08)) | ((amp << 0x03) & 0x08));
        rslt = bmi2_set_regs(0x6D, &data, 1, dev);
    }

    return rslt;
}





static int8_t read_accel_xyz(struct bmi2_sens_axes_data *accel, struct bmi2_dev *dev)
{

    int8_t rslt;


    uint16_t lsb = 0;


    uint16_t msb = 0;


    uint8_t data[6] = { 0 };

    rslt = bmi2_get_regs(0x0C, data, 6, dev);
    if (rslt == 0)
    {

        msb = data[1];
        lsb = data[0];
        accel->x = (int16_t)((msb << 8) | lsb);


        msb = data[3];
        lsb = data[2];
        accel->y = (int16_t)((msb << 8) | lsb);


        msb = data[5];
        lsb = data[4];
        accel->z = (int16_t)((msb << 8) | lsb);
    }

    return rslt;
}





static int8_t read_gyro_xyz(struct bmi2_sens_axes_data *gyro, struct bmi2_dev *dev)
{

    int8_t rslt;


    uint16_t lsb = 0;


    uint16_t msb = 0;


    uint8_t data[6] = { 0 };

    rslt = bmi2_get_regs(0x12, data, 6, dev);
    if (rslt == 0)
    {

        msb = data[1];
        lsb = data[0];
        gyro->x = (int16_t)((msb << 8) | lsb);


        msb = data[3];
        lsb = data[2];
        gyro->y = (int16_t)((msb << 8) | lsb);


        msb = data[5];
        lsb = data[4];
        gyro->z = (int16_t)((msb << 8) | lsb);
    }

    return rslt;
}





static void convert_lsb_g(const struct bmi2_selftest_delta_limit *acc_data_diff,
                          struct bmi2_selftest_delta_limit *acc_data_diff_mg,
                          const struct bmi2_dev *dev)
{

    uint32_t lsb_per_g;


    uint8_t range = 16;


    lsb_per_g = (uint32_t)(power(2, dev->resolution) / (2 * range));


    acc_data_diff_mg->x = (acc_data_diff->x / (int32_t) lsb_per_g) * 1000;


    acc_data_diff_mg->y = (acc_data_diff->y / (int32_t) lsb_per_g) * 1000;


    acc_data_diff_mg->z = (acc_data_diff->z / (int32_t) lsb_per_g) * 1000;
}




static int32_t power(int16_t base, uint8_t resolution)
{

    uint8_t loop = 1;


    int32_t value = 1;

    for (; loop <= resolution; loop++)
    {
        value = (int32_t)(value * base);
    }

    return value;
}





static int8_t validate_self_test(const struct bmi2_selftest_delta_limit *accel_data_diff)
{

    int8_t rslt;




    if ((accel_data_diff->x > 16000) && (accel_data_diff->y < -15000) &&
        (accel_data_diff->z > 10000))
    {

        rslt = 0;
    }
    else
    {

        rslt = -16;
    }

    return rslt;
}




static int8_t get_remap_axes(struct bmi2_axes_remap *remap, struct bmi2_dev *dev)
{

    int8_t rslt = 0;


    uint8_t feat_config[16] = { 0 };


    uint8_t idx = 0;


    uint8_t feat_found;


    struct bmi2_feature_config remap_config = { 0, 0, 0 };


    uint8_t aps_stat;


    aps_stat = dev->aps_status;
    if (aps_stat == 1)
    {

        rslt = bmi2_set_adv_power_save(0, dev);
    }

    if (rslt == 0)
    {

        feat_found = bmi2_extract_input_feat_config(&remap_config, 38, dev);
        if (feat_found)
        {
            rslt = bmi2_get_feat_config(remap_config.page, feat_config, dev);
            if (rslt == 0)
            {

                idx = remap_config.start_addr;


                remap->x_axis = (feat_config[idx] & (0x03));


                remap->x_axis_sign = ((feat_config[idx] & (0x04)) >> (0x02));


                remap->y_axis = ((feat_config[idx] & (0x18)) >> (0x03));


                remap->y_axis_sign = ((feat_config[idx] & (0x20)) >> (0x05));


                remap->z_axis = ((feat_config[idx] & (0xC0)) >> (0x06));


                idx++;


                remap->z_axis_sign = (feat_config[idx] & (0x01));
            }
        }
        else
        {
            rslt = -8;
        }




        if ((aps_stat == 1) && (rslt == 0))
        {
            rslt = bmi2_set_adv_power_save(1, dev);
        }
    }

    return rslt;
}




static int8_t set_remap_axes(const struct bmi2_axes_remap *remap, struct bmi2_dev *dev)
{

    int8_t rslt = 0;


    uint8_t feat_config[16] = { 0 };


    uint8_t idx = 0;


    uint8_t reg_addr = 0;


    uint8_t x_axis = 0;


    uint8_t y_axis = 0;


    uint8_t z_axis = 0;


    uint8_t x_axis_sign = 0;


    uint8_t y_axis_sign = 0;


    uint8_t z_axis_sign = 0;


    uint8_t feat_found;


    struct bmi2_feature_config remap_config = { 0, 0, 0 };


    uint8_t aps_stat;


    aps_stat = dev->aps_status;
    if (aps_stat == 1)
    {

        rslt = bmi2_set_adv_power_save(0, dev);
    }

    if (rslt == 0)
    {

        feat_found = bmi2_extract_input_feat_config(&remap_config, 38, dev);
        if (feat_found)
        {

            rslt = bmi2_get_feat_config(remap_config.page, feat_config, dev);
            if (rslt == 0)
            {

                idx = remap_config.start_addr;


                x_axis = remap->x_axis & 0x03;


                x_axis_sign = ((remap->x_axis_sign << 0x02) & 0x04);


                y_axis = ((remap->y_axis << 0x03) & 0x18);


                y_axis_sign = ((remap->y_axis_sign << 0x05) & 0x20);


                z_axis = ((remap->z_axis << 0x06) & 0xC0);


                z_axis_sign = remap->z_axis_sign & 0x01;


                feat_config[idx] = x_axis | x_axis_sign | y_axis | y_axis_sign | z_axis;


                idx++;




                feat_config[idx] = ((feat_config[idx] & ~(0x01)) | (z_axis_sign & 0x01));


                reg_addr = 0x30 + remap_config.start_addr;


                rslt = bmi2_set_regs(reg_addr, &feat_config[remap_config.start_addr], 2, dev);
            }
        }
        else
        {
            rslt = -8;
        }




        if ((aps_stat == 1) && (rslt == 0))
        {
            rslt = bmi2_set_adv_power_save(1, dev);
        }
    }

    return rslt;
}




static int16_t saturate(int32_t value, uint16_t saturation_val)
{
    int16_t retval = (int16_t)value;

    if (value > (int32_t)saturation_val)
    {
        retval = (int16_t)saturation_val;
    }
    else if (value < (-(int32_t)saturation_val - 1))
    {
        retval = -(int16_t)saturation_val - 1;
    }

    return retval;
}





static void comp_gyro_cross_axis_sensitivity(struct bmi2_sens_axes_data *gyr_data, const struct bmi2_dev *dev)
{
    uint16_t int16_max = 32767;


    gyr_data->x =
        saturate((int32_t)(gyr_data->x - (int16_t)(((int32_t) dev->gyr_cross_sens_zx * (int32_t) gyr_data->z) / 512)),
                 int16_max);
}




static int8_t check_boundary_val(uint8_t *val, uint8_t min, uint8_t max, struct bmi2_dev *dev)
{

    int8_t rslt = 0;

    if (val != 
# 8609 "../applications/bmi270/bmi2.c" 3 4
              ((void *)0)
# 8609 "../applications/bmi270/bmi2.c"
                  )
    {

        if (*val < min)
        {

            *val = min;
            dev->info |= 1;
        }


        if (*val > max)
        {

            *val = max;
            dev->info |= 2;
        }
    }
    else
    {
        rslt = -1;
    }

    return rslt;
}




static int8_t save_accel_foc_config(struct bmi2_accel_config *acc_cfg,
                                    uint8_t *aps,
                                    uint8_t *acc_en,
                                    struct bmi2_dev *dev)
{

    int8_t rslt;


    uint8_t pwr_ctrl_data = 0;


    rslt = get_accel_config(acc_cfg, dev);
    if (rslt == 0)
    {

        rslt = bmi2_get_regs(0x7D, &pwr_ctrl_data, 1, dev);
        *acc_en = ((pwr_ctrl_data & (0x04)) >> (0x02));


        if (rslt == 0)
        {
            rslt = bmi2_get_adv_power_save(aps, dev);
        }
    }

    return rslt;
}




static int8_t set_accel_foc_config(struct bmi2_dev *dev)
{

    int8_t rslt;


    uint8_t sens_list = 0;


    uint8_t acc_conf_data = 0xB7;


    rslt = set_accel_offset_comp(0, dev);
    if (rslt == 0)
    {

        rslt = bmi2_set_regs(0x40, &acc_conf_data, 1, dev);
        if (rslt == 0)
        {

            rslt = bmi2_sensor_enable(&sens_list, 1, dev);

            if (rslt == 0)
            {

                rslt = bmi2_set_adv_power_save(0, dev);
            }
        }
    }

    return rslt;
}




static int8_t perform_accel_foc(const struct bmi2_accel_foc_g_value *accel_g_value,
                                const struct bmi2_accel_config *acc_cfg,
                                struct bmi2_dev *dev)
{

    int8_t rslt = -21;


    uint8_t loop;


    uint8_t reg_status = 0;


    struct bmi2_sens_axes_data accel_value[128] = { { 0 } };


    struct bmi2_foc_temp_value temp = { 0, 0, 0 };


    struct bmi2_sens_axes_data accel_avg = { 0, 0, 0, 0 };


    uint16_t lsb_per_g = 0;


    uint8_t range = 0;


    struct bmi2_offset_delta delta = { 0, 0, 0 };


    struct bmi2_accel_offset offset = { 0, 0, 0 };


    uint8_t try_cnt;

    for (loop = 0; loop < 128; loop++)
    {
        try_cnt = 5;
        while (try_cnt && (!(reg_status & 0x80)))
        {

            dev->delay_us(20000, dev->intf_ptr);
            rslt = bmi2_get_status(&reg_status, dev);
            try_cnt--;
        }

        if ((rslt == 0) && (reg_status & 0x80))
        {
            rslt = read_accel_xyz(&accel_value[loop], dev);
        }

        if (rslt == 0)
        {
            rslt = read_accel_xyz(&accel_value[loop], dev);
        }

        if (rslt == 0)
        {

            temp.x = temp.x + (int32_t)accel_value[loop].x;
            temp.y = temp.y + (int32_t)accel_value[loop].y;
            temp.z = temp.z + (int32_t)accel_value[loop].z;
        }
        else
        {
            break;
        }
    }

    if (rslt == 0)
    {

        accel_avg.x = (int16_t)(temp.x / 128);
        accel_avg.y = (int16_t)(temp.y / 128);
        accel_avg.z = (int16_t)(temp.z / 128);


        map_accel_range(acc_cfg->range, &range);



        lsb_per_g = (uint16_t)(power(2, dev->resolution) / (2 * range));


        comp_for_gravity(lsb_per_g, accel_g_value, &accel_avg, &delta);


        scale_accel_offset(range, &delta, &offset);


        invert_accel_offset(&offset);


        rslt = write_accel_offset(&offset, dev);


        if (rslt == 0)
        {
            rslt = set_accel_offset_comp(1, dev);
        }
    }

    return rslt;
}





static int8_t set_accel_offset_comp(uint8_t offset_en, struct bmi2_dev *dev)
{

    int8_t rslt;


    uint8_t data = 0;


    rslt = bmi2_get_regs(0x70, &data, 1, dev);
    if (rslt == 0)
    {
        data = ((data & ~(0x08)) | ((offset_en << 0x03) & 0x08));
        rslt = bmi2_set_regs(0x70, &data, 1, dev);
    }

    return rslt;
}





static void map_accel_range(uint8_t range_in, uint8_t *range_out)
{
    switch (range_in)
    {
        case 0x00:
            *range_out = 2;
            break;
        case 0x01:
            *range_out = 4;
            break;
        case 0x02:
            *range_out = 8;
            break;
        case 0x03:
            *range_out = 16;
            break;
        default:


            *range_out = 8;
            break;
    }
}




static void comp_for_gravity(uint16_t lsb_per_g,
                             const struct bmi2_accel_foc_g_value *g_val,
                             const struct bmi2_sens_axes_data *data,
                             struct bmi2_offset_delta *comp_data)
{

    int16_t accel_value_lsb[3] = { 0 };


    accel_value_lsb[0] = (int16_t)(lsb_per_g * g_val->x);
    accel_value_lsb[1] = (int16_t)(lsb_per_g * g_val->y);
    accel_value_lsb[2] = (int16_t)(lsb_per_g * g_val->z);


    comp_data->x = (data->x - accel_value_lsb[0]);
    comp_data->y = (data->y - accel_value_lsb[1]);
    comp_data->z = (data->z - accel_value_lsb[2]);
}
# 8893 "../applications/bmi270/bmi2.c"
static void scale_accel_offset(uint8_t range, const struct bmi2_offset_delta *comp_data, struct bmi2_accel_offset *data)
{

    int8_t bit_pos_3_9mg;


    int8_t bit_pos_3_9mg_prev_bit;


    uint8_t round_off;


    bit_pos_3_9mg = get_bit_pos_3_9mg(range);


    bit_pos_3_9mg_prev_bit = bit_pos_3_9mg - 1;
    round_off = (uint8_t)(power(2, ((uint8_t) bit_pos_3_9mg_prev_bit)));


    data->x = (uint8_t)((comp_data->x + round_off) / power(2, ((uint8_t) bit_pos_3_9mg)));
    data->y = (uint8_t)((comp_data->y + round_off) / power(2, ((uint8_t) bit_pos_3_9mg)));
    data->z = (uint8_t)((comp_data->z + round_off) / power(2, ((uint8_t) bit_pos_3_9mg)));
}





static int8_t get_bit_pos_3_9mg(uint8_t range)
{

    int8_t bit_pos_3_9mg;


    uint32_t divisor = 1;


    int16_t scale_factor = -1;


    uint16_t temp;


    divisor = divisor << 16;


    temp = (uint16_t)(divisor / (range * 256));


    while (temp != 1)
    {
        scale_factor++;
        temp = temp >> 1;
    }


    bit_pos_3_9mg = (int8_t) scale_factor;

    return bit_pos_3_9mg;
}




static void invert_accel_offset(struct bmi2_accel_offset *offset_data)
{

    offset_data->x = (uint8_t)((offset_data->x) * (-1));
    offset_data->y = (uint8_t)((offset_data->y) * (-1));
    offset_data->z = (uint8_t)((offset_data->z) * (-1));
}





static int8_t write_accel_offset(const struct bmi2_accel_offset *offset, struct bmi2_dev *dev)
{

    int8_t rslt;


    uint8_t data_array[3] = { 0 };

    data_array[0] = offset->x;
    data_array[1] = offset->y;
    data_array[2] = offset->z;


    rslt = bmi2_set_regs(0x71, data_array, 3, dev);

    return rslt;
}





static int8_t restore_accel_foc_config(struct bmi2_accel_config *acc_cfg,
                                       uint8_t aps,
                                       uint8_t acc_en,
                                       struct bmi2_dev *dev)
{

    int8_t rslt;


    uint8_t pwr_ctrl_data = 0;


    rslt = set_accel_config(acc_cfg, dev);
    if (rslt == 0)
    {

        rslt = bmi2_get_regs(0x7D, &pwr_ctrl_data, 1, dev);
        if (rslt == 0)
        {
            pwr_ctrl_data = ((pwr_ctrl_data & ~(0x04)) | ((acc_en << 0x02) & 0x04));
            rslt = bmi2_set_regs(0x7D, &pwr_ctrl_data, 1, dev);


            if (rslt == 0)
            {
                rslt = bmi2_set_adv_power_save(aps, dev);
            }
        }
    }

    return rslt;
}





static int8_t set_accel_config(struct bmi2_accel_config *config, struct bmi2_dev *dev)
{

    int8_t rslt;


    uint8_t reg_data;




    uint8_t data_array[2] = { 0 };


    rslt = validate_bw_perf_mode(&config->bwp, &config->filter_perf, dev);
    if (rslt == 0)
    {

        rslt = validate_odr_range(&config->odr, &config->range, dev);
        if (rslt == 0)
        {

            reg_data = ((data_array[0] & ~(0x80)) | ((config->filter_perf << 0x07) & 0x80));


            reg_data = ((reg_data & ~(0x70)) | ((config->bwp << 0x04) & 0x70));


            reg_data = ((reg_data & ~(0x0F)) | (config->odr & 0x0F));


            data_array[0] = reg_data;


            reg_data = ((data_array[1] & ~(0x03)) | (config->range & 0x03));


            data_array[1] = reg_data;




            rslt = bmi2_set_regs(0x40, data_array, 2, dev);


            if (rslt == 0)
            {
                rslt = cfg_error_status(dev);
            }
        }
    }

    return rslt;
}






static int8_t set_gyro_config(struct bmi2_gyro_config *config, struct bmi2_dev *dev)
{

    int8_t rslt;


    uint8_t reg_data;


    uint8_t data_array[2] = { 0 };


    rslt = validate_gyro_config(config, dev);
    if (rslt == 0)
    {

        reg_data = ((data_array[0] & ~(0x80)) | ((config->filter_perf << 0x07) & 0x80));


        reg_data = ((reg_data & ~(0x40)) | ((config->noise_perf << 0x06) & 0x40));


        reg_data = ((reg_data & ~(0x30)) | ((config->bwp << 0x04) & 0x30));


        reg_data = ((reg_data & ~(0x0F)) | (config->odr & 0x0F));


        data_array[0] = reg_data;


        reg_data = ((data_array[1] & ~(0x08)) | ((config->ois_range << 0x03) & 0x08));


        reg_data = ((reg_data & ~(0x07)) | (config->range & 0x07));


        data_array[1] = reg_data;




        rslt = bmi2_set_regs(0x42, data_array, 2, dev);


        if (rslt == 0)
        {
            rslt = cfg_error_status(dev);
        }
    }

    return rslt;
}





static int8_t save_gyro_config(struct bmi2_gyro_config *gyr_cfg, uint8_t *aps, uint8_t *gyr_en, struct bmi2_dev *dev)
{

    int8_t rslt;


    uint8_t pwr_ctrl_data = 0;


    rslt = get_gyro_config(gyr_cfg, dev);
    if (rslt == 0)
    {

        rslt = bmi2_get_regs(0x7D, &pwr_ctrl_data, 1, dev);
        *gyr_en = ((pwr_ctrl_data & (0x02)) >> (0x01));


        if (rslt == 0)
        {
            rslt = bmi2_get_adv_power_save(aps, dev);
        }
    }

    return rslt;
}




static int8_t set_gyro_foc_config(struct bmi2_dev *dev)
{
    int8_t rslt;


    uint8_t sens_list = 1;




    uint8_t gyr_conf_data[2] = { 0xB6, 0x00 };


    rslt = bmi2_set_gyro_offset_comp(0, dev);
    if (rslt == 0)
    {



        rslt = bmi2_set_regs(0x42, gyr_conf_data, 2, dev);
        if (rslt == 0)
        {

            rslt = bmi2_sensor_enable(&sens_list, 1, dev);

            if (rslt == 0)
            {

                rslt = bmi2_set_adv_power_save(0, dev);
            }
        }
    }

    return rslt;
}




static void invert_gyro_offset(struct bmi2_sens_axes_data *offset_data)
{

    offset_data->x = (int16_t)((offset_data->x) * (-1));
    offset_data->y = (int16_t)((offset_data->y) * (-1));
    offset_data->z = (int16_t)((offset_data->z) * (-1));
}





static int8_t restore_gyro_config(struct bmi2_gyro_config *gyr_cfg, uint8_t aps, uint8_t gyr_en, struct bmi2_dev *dev)
{
    int8_t rslt;
    uint8_t pwr_ctrl_data = 0;


    rslt = set_gyro_config(gyr_cfg, dev);
    if (rslt == 0)
    {

        rslt = bmi2_get_regs(0x7D, &pwr_ctrl_data, 1, dev);
        if (rslt == 0)
        {
            pwr_ctrl_data = ((pwr_ctrl_data & ~(0x02)) | ((gyr_en << 0x01) & 0x02));
            rslt = bmi2_set_regs(0x7D, &pwr_ctrl_data, 1, dev);


            if (rslt == 0)
            {
                rslt = bmi2_set_adv_power_save(aps, dev);
            }
        }
    }

    return rslt;
}





static void saturate_gyro_data(struct bmi2_sens_axes_data *gyr_off)
{
    if (gyr_off->x > 511)
    {
        gyr_off->x = 511;
    }

    if (gyr_off->x < -512)
    {
        gyr_off->x = -512;
    }

    if (gyr_off->y > 511)
    {
        gyr_off->y = 511;
    }

    if (gyr_off->y < -512)
    {
        gyr_off->y = -512;
    }

    if (gyr_off->z > 511)
    {
        gyr_off->z = 511;
    }

    if (gyr_off->z < -512)
    {
        gyr_off->z = -512;
    }
}





static int8_t null_ptr_check(const struct bmi2_dev *dev)
{
    int8_t rslt = 0;

    if ((dev == 
# 9298 "../applications/bmi270/bmi2.c" 3 4
               ((void *)0)
# 9298 "../applications/bmi270/bmi2.c"
                   ) || (dev->read == 
# 9298 "../applications/bmi270/bmi2.c" 3 4
                                      ((void *)0)
# 9298 "../applications/bmi270/bmi2.c"
                                          ) || (dev->write == 
# 9298 "../applications/bmi270/bmi2.c" 3 4
                                                              ((void *)0)
# 9298 "../applications/bmi270/bmi2.c"
                                                                  ) || (dev->delay_us == 
# 9298 "../applications/bmi270/bmi2.c" 3 4
                                                                                         ((void *)0)
# 9298 "../applications/bmi270/bmi2.c"
                                                                                             ))
    {

        rslt = -1;
    }

    return rslt;
}




static int8_t get_st_running(uint8_t *st_status, struct bmi2_dev *dev)
{
    int8_t rslt;
    uint8_t reg_data = 0;

    rslt = null_ptr_check(dev);
    if (rslt == 0)
    {

        rslt = bmi2_get_regs(0x69, &reg_data, 1, dev);
        if (rslt == 0)
        {
            (*st_status) = ((reg_data & (0x04)) >> (0x02));
        }
    }
    else
    {
        rslt = -1;
    }

    return rslt;
}




static int8_t set_st_running(uint8_t st_status, struct bmi2_dev *dev)
{
    int8_t rslt;
    uint8_t reg_data = 0;

    rslt = null_ptr_check(dev);
    if (rslt == 0)
    {
        rslt = bmi2_get_regs(0x69, &reg_data, 1, dev);
        if (rslt == 0)
        {
            reg_data = ((reg_data & ~(0x04)) | ((st_status << 0x02) & 0x04));
            rslt = bmi2_set_regs(0x69, &reg_data, 1, dev);
        }
    }

    return rslt;
}




static int8_t get_rdy_for_dl(uint8_t *rdy_for_dl, struct bmi2_dev *dev)
{
    int8_t rslt;
    uint8_t reg_data = 0;

    rslt = null_ptr_check(dev);
    if (rslt == 0)
    {

        rslt = bmi2_get_regs(0x69, &reg_data, 1, dev);
        if (rslt == 0)
        {
            (*rdy_for_dl) = ((reg_data & (0x08)) >> (0x03));
        }
    }
    else
    {
        rslt = -1;
    }

    return rslt;
}




static int8_t process_crt_download(uint8_t last_byte_flag, struct bmi2_dev *dev)
{
    int8_t rslt;
    uint8_t rdy_for_dl = 0;
    uint8_t cmd = 0x02;

    rslt = null_ptr_check(dev);
    if (rslt == 0)
    {
        rslt = get_rdy_for_dl(&rdy_for_dl, dev);
    }


    if (rslt == 0)
    {
        rslt = bmi2_set_regs(0x7E, &cmd, 1, dev);
    }

    if ((!last_byte_flag) && (rslt == 0))
    {
        rslt = wait_rdy_for_dl_toggle(100, rdy_for_dl, dev);
    }

    return rslt;
}




static int8_t write_crt_config_file(uint16_t write_len,
                                    uint16_t config_file_size,
                                    uint16_t start_index,
                                    struct bmi2_dev *dev)
{
    int8_t rslt = 0;
    uint16_t index = 0;
    uint8_t last_byte_flag = 0;
    uint8_t remain = (uint8_t)(config_file_size % write_len);
    uint16_t balance_byte = 0;

    if (!remain)
    {


        for (index = start_index;
             (index < (start_index + config_file_size)) && (rslt == 0);
             index += write_len)
        {
            rslt = upload_file((dev->config_file_ptr + index), index, write_len, dev);
            if (index >= ((start_index + config_file_size) - (write_len)))
            {
                last_byte_flag = 1;
            }

            if (rslt == 0)
            {
                rslt = process_crt_download(last_byte_flag, dev);
            }
        }
    }
    else
    {

        balance_byte = (uint16_t)start_index + (uint16_t)config_file_size - (uint16_t)remain;


        for (index = start_index; (index < balance_byte) && (rslt == 0); index += write_len)
        {
            rslt = upload_file((dev->config_file_ptr + index), index, write_len, dev);
            if (rslt == 0)
            {
                rslt = process_crt_download(last_byte_flag, dev);
            }
        }

        if (rslt == 0)
        {

            write_len = 2;
            rslt = set_maxburst_len(write_len, dev);


            for (index = balance_byte;
                 (index < (start_index + config_file_size)) && (rslt == 0);
                 index += write_len)
            {
                rslt = upload_file((dev->config_file_ptr + index), index, write_len, dev);
                if (index < ((start_index + config_file_size) - write_len))
                {
                    last_byte_flag = 1;
                }

                if (rslt == 0)
                {
                    rslt = process_crt_download(last_byte_flag, dev);
                }
            }
        }
    }

    return rslt;
}




static int8_t wait_rdy_for_dl_toggle(uint8_t retry_complete, uint8_t download_ready, struct bmi2_dev *dev)
{
    int8_t rslt = 0;
    uint8_t dl_ready = 0;
    uint8_t st_status = 0;

    while ((rslt == 0) && (retry_complete--))
    {
        rslt = get_rdy_for_dl(&dl_ready, dev);
        if (download_ready != dl_ready)
        {
            break;
        }

        dev->delay_us(2000, dev->intf_ptr);
    }

    if ((rslt == 0) && (download_ready == dl_ready))
    {
        rslt = -24;
    }

    if (rslt == 0)
    {
        rslt = get_st_running(&st_status, dev);
        if ((rslt == 0) && (st_status == 0))
        {
            rslt = -23;
        }
    }

    return rslt;
}




static int8_t wait_st_running(uint8_t retry_complete, struct bmi2_dev *dev)
{
    uint8_t st_status = 1;
    int8_t rslt = 0;

    while (retry_complete--)
    {
        rslt = get_st_running(&st_status, dev);
        if ((rslt == 0) && (st_status == 0))
        {
            break;
        }

        dev->delay_us(10000, dev->intf_ptr);
    }

    if ((rslt == 0) && (st_status == 1))
    {
        rslt = -23;
    }

    return rslt;
}




int8_t bmi2_do_gyro_st(struct bmi2_dev *dev)
{
    int8_t rslt;

    rslt = do_gtrigger_test(0, dev);

    return rslt;
}




int8_t bmi2_do_crt(struct bmi2_dev *dev)
{
    int8_t rslt;

    rslt = do_gtrigger_test(1, dev);

    return rslt;
}




static int8_t do_gtrigger_test(uint8_t gyro_st_crt, struct bmi2_dev *dev)
{
    int8_t rslt;
    uint8_t st_status = 0;
    uint8_t max_burst_length = 0;
    struct bmi2_gyro_self_test_status gyro_st_result = { 0 };


    uint8_t aps_stat = 0;

    rslt = null_ptr_check(dev);
    if (rslt == 0)
    {

        if (dev->variant_feature & 0x01)
        {

            aps_stat = dev->aps_status;
            if (aps_stat == 1)
            {

                rslt = bmi2_set_adv_power_save(0, dev);
            }


            if (rslt == 0)
            {
                rslt = get_maxburst_len(&max_burst_length, dev);
            }


            if (rslt == 0)
            {
                rslt = get_st_running(&st_status, dev);
            }


            if (st_status == 0)
            {
                rslt = gyro_crt_test(max_burst_length, gyro_st_crt, dev);
            }
            else
            {
                rslt = -23;
            }

            if (rslt == 0)
            {
                if (gyro_st_crt == 0)
                {
                    rslt = gyro_self_test_completed(&gyro_st_result, dev);
                }
            }




            if ((aps_stat == 1) && (rslt == 0))
            {
                rslt = bmi2_set_adv_power_save(1, dev);
            }
        }
        else
        {
            rslt = -8;
        }
    }

    return rslt;
}




static int8_t crt_prepare_setup(struct bmi2_dev *dev)
{
    int8_t rslt;


    uint8_t sens_list = 1;

    rslt = null_ptr_check(dev);

    if (rslt == 0)
    {

        rslt = bmi2_sensor_disable(&sens_list, 1, dev);
    }


    if (rslt == 0)
    {
        rslt = bmi2_set_fifo_config(0xE000, 0, dev);
    }

    if (rslt == 0)
    {

        sens_list = 0;
        rslt = bmi2_sensor_enable(&sens_list, 1, dev);
    }

    if (rslt == 0)
    {

        dev->delay_us(1000, dev->intf_ptr);
        rslt = abort_bmi2(0, dev);
    }

    return rslt;
}




static int8_t crt_gyro_st_update_result(struct bmi2_dev *dev)
{
    int8_t rslt;
    struct bmi2_gyr_user_gain_status user_gain_stat = { 0, 0, 0, 0 };

    rslt = null_ptr_check(dev);


    if (rslt == 0)
    {
        rslt = get_gyro_gain_update_status(&user_gain_stat, dev);
    }

    if (rslt == 0)
    {
        switch (user_gain_stat.g_trigger_status)
        {
            case 0x00:


                rslt = set_maxburst_len(0, dev);
                break;

            case 0x02:


                rslt = set_maxburst_len(dev->read_write_len, dev);
                if (rslt == 0)
                {
                    rslt = -25;
                }

                break;
            case 0x03:




                rslt = set_maxburst_len(dev->read_write_len, dev);
                if (rslt == 0)
                {
                    rslt = -27;
                }

                break;

            case 0x01:


                rslt = -26;
                break;

            default:
                rslt = -21;

                break;
        }
    }

    return rslt;
}




static int8_t get_maxburst_len(uint8_t *max_burst_len, struct bmi2_dev *dev)
{
    int8_t rslt = 0;
    uint8_t feat_config[16] = { 0 };
    uint8_t idx = 0;
    uint8_t feat_found = 0;
    struct bmi2_feature_config maxburst_length_bytes = { 0, 0, 0 };
    uint8_t aps_stat;

    if ((dev->variant_feature & 0x10) != 0)
    {
        *max_burst_len = 0;

        return 0;
    }


    aps_stat = dev->aps_status;
    if (aps_stat == 1)
    {

        rslt = bmi2_set_adv_power_save(0, dev);
    }

    if (rslt == 0)
    {

        feat_found = bmi2_extract_input_feat_config(&maxburst_length_bytes, 36, dev);
        if (feat_found)
        {
            rslt = bmi2_get_feat_config(maxburst_length_bytes.page, feat_config, dev);
            if (rslt == 0)
            {

                idx = maxburst_length_bytes.start_addr;


                *max_burst_len = feat_config[idx];
            }
        }
        else
        {
            rslt = -8;
        }




        if ((aps_stat == 1) && (rslt == 0))
        {
            rslt = bmi2_set_adv_power_save(1, dev);
        }
    }

    return rslt;
}




static int8_t set_maxburst_len(const uint16_t write_len_byte, struct bmi2_dev *dev)
{
    int8_t rslt = 0;
    uint8_t feat_config[16] = { 0 };
    uint8_t idx = 0;
    uint8_t reg_addr = 0;
    uint8_t max_burst_len = 0;
    uint8_t feat_found = 0;
    struct bmi2_feature_config maxburst_length_bytes = { 0, 0, 0 };
    uint8_t aps_stat;
    uint16_t burst_len = write_len_byte / 2;


    if ((dev->variant_feature & 0x10) != 0)
    {
        return 0;
    }


    if (burst_len > 255)
    {
        max_burst_len = 0xFF;
    }
    else
    {
        max_burst_len = (uint8_t)burst_len;
    }


    aps_stat = dev->aps_status;
    if (aps_stat == 1)
    {

        rslt = bmi2_set_adv_power_save(0, dev);
    }

    if (rslt == 0)
    {

        feat_found = bmi2_extract_input_feat_config(&maxburst_length_bytes, 36, dev);
        if (feat_found)
        {



            rslt = bmi2_get_feat_config(maxburst_length_bytes.page, feat_config, dev);
            if (rslt == 0)
            {

                idx = maxburst_length_bytes.start_addr;


                feat_config[idx] = max_burst_len;


                reg_addr = 0x30 + maxburst_length_bytes.start_addr;


                rslt = bmi2_set_regs(reg_addr, &feat_config[maxburst_length_bytes.start_addr], 2, dev);
            }
        }
        else
        {
            rslt = -8;
        }




        if ((aps_stat == 1) && (rslt == 0))
        {
            rslt = bmi2_set_adv_power_save(1, dev);
        }
    }

    return rslt;
}




static int8_t set_nvm_prep_prog(uint8_t nvm_prep, struct bmi2_dev *dev)
{

    int8_t rslt = 0;


    uint8_t feat_config[16] = { 0 };


    uint8_t idx = 0;


    uint8_t feat_found;
    uint8_t reg_addr = 0;


    struct bmi2_feature_config nvm_config = { 0, 0, 0 };




    feat_found = bmi2_extract_input_feat_config(&nvm_config, 44, dev);
    if (feat_found)
    {


        rslt = bmi2_get_feat_config(nvm_config.page, feat_config, dev);
        if (rslt == 0)
        {

            idx = nvm_config.start_addr;


            feat_config[idx] = ((feat_config[idx] & ~(0x04)) | ((nvm_prep << 0x02) & 0x04));


            reg_addr = 0x30 + nvm_config.start_addr - 1;


            rslt = bmi2_set_regs(reg_addr, &feat_config[nvm_config.start_addr - 1], 2, dev);
        }
    }
    else
    {
        rslt = -8;
    }

    return rslt;
}




static int8_t select_self_test(uint8_t gyro_st_crt, struct bmi2_dev *dev)
{
    int8_t rslt;

    uint8_t feat_config[16] = { 0 };

    uint8_t idx = 0;

    uint8_t feat_found;
    uint8_t reg_addr = 0;

    struct bmi2_feature_config gyro_self_test_crt_config = { 0, 0, 0 };


    feat_found = bmi2_extract_input_feat_config(&gyro_self_test_crt_config, 42, dev);
    if (feat_found)
    {


        rslt = bmi2_get_feat_config(gyro_self_test_crt_config.page, feat_config, dev);
        if (rslt == 0)
        {

            idx = gyro_self_test_crt_config.start_addr;


            feat_config[idx] = ((feat_config[idx] & ~(0x01)) | (gyro_st_crt & 0x01));


            reg_addr = 0x30 + (gyro_self_test_crt_config.start_addr - 1);


            rslt = bmi2_set_regs(reg_addr, &feat_config[gyro_self_test_crt_config.start_addr - 1], 2, dev);
        }
    }
    else
    {
        rslt = -8;
    }

    return rslt;
}




int8_t bmi2_abort_crt_gyro_st(struct bmi2_dev *dev)
{
    int8_t rslt = 0;
    uint8_t aps_stat;
    uint8_t st_running = 0;
    uint8_t cmd = 0x02;


    aps_stat = dev->aps_status;
    if (aps_stat == 1)
    {

        rslt = bmi2_set_adv_power_save(0, dev);
    }


    if (rslt == 0)
    {
        rslt = get_st_running(&st_running, dev);
        if (rslt == 0)
        {

            if (st_running == 0)
            {
                rslt = -32;
            }
        }
    }

    if (rslt == 0)
    {
        rslt = abort_bmi2(1, dev);
    }


    if (rslt == 0)
    {
        rslt = bmi2_set_regs(0x7E, &cmd, 1, dev);
    }

    if (rslt == 0)
    {

        rslt = wait_st_running(200, dev);
    }


    if (rslt == 0)
    {
        rslt = crt_gyro_st_update_result(dev);
        if (rslt == -27)
        {
            rslt = 0;
        }
        else
        {
            rslt = -27;
        }
    }




    if ((aps_stat == 1) && (rslt == 0))
    {
        rslt = bmi2_set_adv_power_save(1, dev);
    }

    return rslt;
}




static int8_t abort_bmi2(uint8_t abort_enable, struct bmi2_dev *dev)
{

    int8_t rslt;


    uint8_t feat_config[16] = { 0 };


    uint8_t idx = 0;


    uint8_t feat_found;
    uint8_t reg_addr = 0;


    struct bmi2_feature_config block_config = { 0, 0, 0 };


    feat_found = bmi2_extract_input_feat_config(&block_config, 43, dev);
    if (feat_found)
    {

        rslt = bmi2_get_feat_config(block_config.page, feat_config, dev);
        if (rslt == 0)
        {

            idx = block_config.start_addr;


            feat_config[idx] = ((feat_config[idx] & ~(0x02)) | ((abort_enable << 0x1) & 0x02));


            reg_addr = 0x30 + (block_config.start_addr - 1);


            rslt = bmi2_set_regs(reg_addr, &feat_config[block_config.start_addr - 1], 2, dev);
        }
    }
    else
    {
        rslt = -8;
    }

    return rslt;
}





static int8_t gyro_self_test_completed(struct bmi2_gyro_self_test_status *gyro_st_result, struct bmi2_dev *dev)
{
    int8_t rslt;
    uint8_t reg_data;

    rslt = bmi2_get_regs(0x6E, &reg_data, 1, dev);
    if (rslt == 0)
    {
        gyro_st_result->gyr_st_axes_done = (reg_data & (0x01));
        if (gyro_st_result->gyr_st_axes_done == 0x01)
        {
            gyro_st_result->gyr_axis_x_ok = ((reg_data & (0x02)) >> (0x01));
            gyro_st_result->gyr_axis_y_ok = ((reg_data & (0x04)) >> (0x02));
            gyro_st_result->gyr_axis_z_ok = ((reg_data & (0x08)) >> (0x03));
        }
        else
        {
            rslt = -19;
        }
    }

    return rslt;
}


int8_t bmi2_nvm_prog(struct bmi2_dev *dev)
{
    int8_t rslt = 0;


    uint8_t aps_stat;
    uint8_t status;
    uint8_t cmd_rdy;
    uint8_t reg_data;
    uint8_t write_timeout = 100;


    aps_stat = dev->aps_status;
    if (aps_stat == 1)
    {

        rslt = bmi2_set_adv_power_save(0, dev);
    }


    if (rslt == 0)
    {
        rslt = bmi2_get_status(&status, dev);

        cmd_rdy = ((status & (0x10)) >> (0x04));
        if (cmd_rdy)
        {
            rslt = set_nvm_prep_prog(1, dev);
            if (rslt == 0)
            {
                dev->delay_us(40000, dev->intf_ptr);



                reg_data = 0x02;
                rslt = bmi2_set_regs(0x6A, &reg_data, 1, dev);
                if (rslt == 0)
                {

                    reg_data = 0xA0;
                    rslt = bmi2_set_regs(0x7E, &reg_data, 1, dev);
                }


                if (rslt == 0)
                {
                    while (write_timeout--)
                    {
                        rslt = bmi2_get_status(&status, dev);
                        if (rslt == 0)
                        {
                            cmd_rdy = ((status & (0x10)) >> (0x04));


                            if (cmd_rdy)
                            {
                                break;
                            }



                            dev->delay_us(20000, dev->intf_ptr);
                        }
                    }
                }

                if ((rslt == 0) && (cmd_rdy != 1))
                {
                    rslt = -30;
                }
            }
        }
        else
        {
            rslt = -30;
        }
    }

    if (rslt == 0)
    {

        rslt = bmi2_soft_reset(dev);
    }


    if ((aps_stat == 1) && (rslt == 0))
    {
        rslt = bmi2_set_adv_power_save(1, dev);
    }

    return rslt;
}





static int8_t extract_config_file(uint8_t *config_major, uint8_t *config_minor, struct bmi2_dev *dev)
{

    int8_t rslt = 0;


    uint8_t idx = 0;


    uint16_t lsb = 0;


    uint16_t msb = 0;


    uint16_t lsb_msb = 0;


    uint8_t feat_found;


    uint8_t aps_stat;


    uint8_t feat_config[16] = { 0 };


    struct bmi2_feature_config config_id = { 0, 0, 0 };


    aps_stat = dev->aps_status;
    if (aps_stat == 1)
    {

        rslt = bmi2_set_adv_power_save(0, dev);
    }

    if (rslt == 0)
    {


        feat_found = bmi2_extract_input_feat_config(&config_id, 47, dev);
        if (feat_found)
        {


            rslt = bmi2_get_feat_config(config_id.page, feat_config, dev);
            if (rslt == 0)
            {

                idx = config_id.start_addr;


                lsb = (uint16_t) feat_config[idx++];
                msb = ((uint16_t) feat_config[idx++] << 8);
                lsb_msb = lsb | msb;


                *config_major = ((lsb_msb & (0x3C0)) >> (0x06));
                *config_minor = (lsb & (0x3F));
            }
        }




        if ((aps_stat == 1) && (rslt == 0))
        {
            rslt = bmi2_set_adv_power_save(1, dev);
        }
    }
    else
    {
        rslt = -8;
    }

    return rslt;
}




static void extract_feat_int_map(struct bmi2_map_int *map_int, uint8_t type, const struct bmi2_dev *dev)
{

    uint8_t loop = 0;


    while (loop < dev->sens_int_map)
    {
        if (dev->map_int[loop].type == type)
        {
            *map_int = dev->map_int[loop];
            break;
        }

        loop++;
    }
}





static int8_t get_gyro_gain_update_status(struct bmi2_gyr_user_gain_status *user_gain_stat, struct bmi2_dev *dev)
{

    int8_t rslt;


    uint8_t feat_config[16] = { 0 };


    uint8_t idx = 0;


    uint8_t feat_found;


    struct bmi2_feature_config user_gain_cfg = { 0, 0, 0 };




    feat_found = extract_output_feat_config(&user_gain_cfg, 9, dev);
    if (feat_found)
    {

        rslt = bmi2_get_feat_config(user_gain_cfg.page, feat_config, dev);
        if (rslt == 0)
        {

            idx = user_gain_cfg.start_addr;


            user_gain_stat->sat_x = (feat_config[idx] & (0x01));


            user_gain_stat->sat_y = ((feat_config[idx] & (0x02)) >> (0x01));


            user_gain_stat->sat_z = ((feat_config[idx] & (0x04)) >> (0x02));


            user_gain_stat->g_trigger_status = ((feat_config[idx] & (0x38)) >> (0x03));
        }
    }
    else
    {
        rslt = -8;
    }

    return rslt;
}





static uint8_t extract_output_feat_config(struct bmi2_feature_config *feat_output,
                                          uint8_t type,
                                          const struct bmi2_dev *dev)
{

    uint8_t loop = 0;


    uint8_t feat_found = 0;


    while (loop < dev->out_sens)
    {
        if (dev->feat_output[loop].type == type)
        {
            *feat_output = dev->feat_output[loop];
            feat_found = 1;
            break;
        }

        loop++;
    }


    return feat_found;
}





static int8_t get_gyro_cross_sense(int16_t *cross_sense, struct bmi2_dev *dev)
{

    int8_t rslt;


    uint8_t feat_config[16] = { 0 };


    uint8_t idx = 0;


    uint8_t feat_found;

    uint8_t corr_fact_zx;


    struct bmi2_feature_config cross_sense_out_config = { 0, 0, 0 };

    if (dev->variant_feature & 0x20)
    {

        rslt = bmi2_get_regs(0x1E, &corr_fact_zx, 1, dev);
        if (rslt == 0)
        {

            if (corr_fact_zx & 0x40)
            {
                *cross_sense = (int16_t)(((int16_t)corr_fact_zx) - 128);
            }
            else
            {
                *cross_sense = (int16_t)(corr_fact_zx);
            }
        }
    }
    else
    {

        feat_found = extract_output_feat_config(&cross_sense_out_config, 41, dev);
        if (feat_found)
        {


            rslt = bmi2_get_feat_config(cross_sense_out_config.page, feat_config, dev);
            if (rslt == 0)
            {

                idx = cross_sense_out_config.start_addr;


                feat_config[idx] = feat_config[idx] & 0x7F;


                if (feat_config[idx] & 0x40)
                {
                    *cross_sense = (int16_t)(((int16_t)feat_config[idx]) - 128);
                }
                else
                {
                    *cross_sense = (int16_t)(feat_config[idx]);
                }
            }
        }
        else
        {
            rslt = -8;
        }
    }

    return rslt;
}





static int8_t select_sensor(const uint8_t *sens_list, uint8_t n_sens, uint64_t *sensor_sel)
{

    int8_t rslt = 0;


    uint8_t count;

    for (count = 0; count < n_sens; count++)
    {
        switch (sens_list[count])
        {
            case 0:
                *sensor_sel |= (1);
                break;
            case 1:
                *sensor_sel |= (1 << 1);
                break;
            case 2:
                *sensor_sel |= (1 << 2);
                break;
            case 32:
                *sensor_sel |= ((uint64_t)1 << 32);
                break;
            default:
                rslt = -8;
                break;
        }
    }

    return rslt;
}




static int8_t sensor_enable(uint64_t sensor_sel, struct bmi2_dev *dev)
{

    int8_t rslt;


    uint8_t reg_data = 0;

    rslt = bmi2_get_regs(0x7D, &reg_data, 1, dev);
    if (rslt == 0)
    {

        if (sensor_sel & (1))
        {
            reg_data = ((reg_data & ~(0x04)) | ((1 << 0x02) & 0x04));
        }


        if (sensor_sel & (1 << 1))
        {
            reg_data = ((reg_data & ~(0x02)) | ((1 << 0x01) & 0x02));
        }


        if (sensor_sel & (1 << 2))
        {
            reg_data = ((reg_data & ~(0x01)) | (1 & 0x01));
        }


        if (sensor_sel & ((uint64_t)1 << 32))
        {
            reg_data = ((reg_data & ~(0x08)) | ((1 << 0x03) & 0x08));
        }


        if (sensor_sel & ((1) | (1 << 1) | (1 << 2) | ((uint64_t)1 << 32)))
        {
            rslt = bmi2_set_regs(0x7D, &reg_data, 1, dev);
        }
    }

    return rslt;
}




static int8_t sensor_disable(uint64_t sensor_sel, struct bmi2_dev *dev)
{

    int8_t rslt;


    uint8_t reg_data = 0;

    rslt = bmi2_get_regs(0x7D, &reg_data, 1, dev);
    if (rslt == 0)
    {

        if (sensor_sel & (1))
        {
            reg_data = (reg_data & ~(0x04));
        }


        if (sensor_sel & (1 << 1))
        {
            reg_data = (reg_data & ~(0x02));
        }


        if (sensor_sel & (1 << 2))
        {
            reg_data = (reg_data & ~(0x01));
        }


        if (sensor_sel & ((uint64_t)1 << 32))
        {
            reg_data = (reg_data & ~(0x08));
        }


        if (sensor_sel & ((1) | (1 << 1) | (1 << 2) | ((uint64_t)1 << 32)))
        {
            rslt = bmi2_set_regs(0x7D, &reg_data, 1, dev);
        }
    }

    return rslt;
}




static int8_t read_sensor_data(uint8_t aux_len,
                               uint8_t acc_len,
                               uint8_t gyr_len,
                               uint8_t *sensor_data,
                               struct bmi2_dev *dev)
{
    int8_t rslt;
    uint8_t start_addr = 0;
    uint8_t len = 0;


    if (aux_len != 0)
    {

        if ((acc_len != 0) && (gyr_len != 0))
        {
            start_addr = 0x04;
            len = 20;
        }

        else if ((acc_len != 0) && (gyr_len == 0))
        {
            start_addr = 0x04;
            len = 14;
        }

        else if ((gyr_len != 0) && (acc_len == 0))
        {
            start_addr = 0x04;
            len = 20;
        }

        else if ((acc_len == 0) && (gyr_len == 0))
        {
            start_addr = 0x04;
            len = 8;
        }
    }

    else
    {

        if ((acc_len != 0) && (gyr_len != 0))
        {
            start_addr = 0x0C;
            len = 12;
        }

        else if ((acc_len != 0) && (gyr_len == 0))
        {
            start_addr = 0x0C;
            len = 6;
        }

        else if ((gyr_len != 0) && (acc_len == 0))
        {
            start_addr = 0x12;
            len = 6;
        }
    }


    rslt = bmi2_get_regs(start_addr, sensor_data, len, dev);

    return rslt;
}




static int8_t parse_data(uint8_t aux_len,
                         uint8_t acc_len,
                         uint8_t gyr_len,
                         struct bmi2_sens_data *data,
                         const uint8_t *sensor_data,
                         struct bmi2_dev *dev)
{
    int8_t rslt;

    uint8_t sens_time[3] = { 0 };


    uint8_t count = 0;


    uint8_t index = 0;

    uint32_t sensor_time_byte3 = 0;
    uint16_t sensor_time_byte2 = 0;
    uint8_t sensor_time_byte1 = 0;


    if (aux_len != 0)
    {

        do
        {
            *(data->aux_data + count++) = *(sensor_data + index++);
        } while (count < 8);
    }


    if (acc_len != 0)
    {

        get_acc_gyr_data(&data->acc, sensor_data + (acc_len - 6));


        get_remapped_data(&data->acc, dev);
    }


    if (gyr_len != 0)
    {
        if ((aux_len != 0) && (acc_len != 0))
        {

            get_acc_gyr_data(&data->gyr, sensor_data + 14);
        }

        if ((aux_len != 0) && (acc_len == 0))
        {

            get_acc_gyr_data(&data->gyr, sensor_data + 14);
        }

        if ((acc_len != 0) && (aux_len == 0))
        {

            get_acc_gyr_data(&data->gyr, sensor_data + 6);
        }

        if ((acc_len == 0) && (aux_len == 0))
        {

            get_acc_gyr_data(&data->gyr, sensor_data);
        }


        comp_gyro_cross_axis_sensitivity(&data->gyr, dev);


        get_remapped_data(&data->gyr, dev);
    }


    rslt = bmi2_get_regs(0x18, sens_time, 3, dev);
    if (rslt == 0)
    {
        sensor_time_byte3 = sens_time[2] << 16;
        sensor_time_byte2 = sens_time[1] << 8;
        sensor_time_byte1 = sens_time[0];

        data->sens_time = (uint32_t)(sensor_time_byte3 | sensor_time_byte2 | sensor_time_byte1);
    }

    return rslt;
}




static int8_t gyro_crt_test(uint8_t max_burst_length, uint8_t gyro_st_crt, struct bmi2_dev *dev)
{
    int8_t rslt;
    int8_t rslt_crt = 0;
    uint8_t cmd = 0x02;
    uint8_t download_ready = 0;

    rslt = set_st_running(1, dev);


    if (rslt == 0)
    {
        rslt = crt_prepare_setup(dev);
    }


    if (rslt == 0)
    {
        rslt = select_self_test(gyro_st_crt, dev);
    }


    if ((rslt == 0) && (max_burst_length == 0))
    {

        rslt = bmi2_set_regs(0x7E, &cmd, 1, dev);
        if (rslt == 0)
        {

            rslt = wait_st_running(200, dev);


            if (rslt == 0)
            {
                rslt = crt_gyro_st_update_result(dev);
            }
        }
    }
    else
    {

        if (rslt == 0)
        {
            if (dev->read_write_len < 2)
            {
                dev->read_write_len = 2;
            }

            if (dev->read_write_len > (255 * 2))
            {
                dev->read_write_len = 255 * 2;
            }


            rslt = set_maxburst_len(dev->read_write_len, dev);
        }

        if (rslt == 0)
        {
            rslt = get_rdy_for_dl(&download_ready, dev);
        }


        if (rslt == 0)
        {
            rslt = bmi2_set_regs(0x7E, &cmd, 1, dev);
        }


        if (rslt == 0)
        {
            rslt = wait_rdy_for_dl_toggle(100, download_ready, dev);
            if (rslt == 0)
            {
                rslt = write_crt_config_file(dev->read_write_len, 2048, 0x1800, dev);
            }

            if (rslt == 0)
            {
                rslt = wait_st_running(200, dev);
                rslt_crt = crt_gyro_st_update_result(dev);
                if (rslt == 0)
                {
                    rslt = rslt_crt;
                }
            }
        }
    }

    return rslt;
}
